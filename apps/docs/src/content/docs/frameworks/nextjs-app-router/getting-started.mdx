---
title: Next.js App Router - Getting Started
description: Set up Scenarist with Next.js App Router in 5 minutes
---

import { Aside } from '@astrojs/starlight/components';

Test your Next.js App Router application with Server Components, Route Handlers, and Server Actions all executing. No mocking of Next.js internals required.

## Installation

```bash
npm install @scenarist/core @scenarist/nextjs-adapter
npm install -D @playwright/test @scenarist/playwright-helpers
```

<Aside type="note" title="Testing Apps with Database Access?">

If your Next.js app uses **direct database access** (PostgreSQL, MongoDB, Prisma, etc.) instead of HTTP APIs, Scenarist cannot mock those calls directly. However, you can make your app testable by adding a thin API route layer.

**[→ Read the Database Testing Guide](/guides/testing-database-apps)** to learn how to test database-heavy Next.js applications with Scenarist.

**[→ See what Scenarist can and cannot mock](/introduction/why-scenarist#what-scenarist-intercepts)**

</Aside>

## 1. Define Scenarios

```typescript
// lib/scenarios.ts
import type { ScenaristScenario, ScenaristScenarios } from '@scenarist/nextjs-adapter/app';

// ✅ RECOMMENDED - Default scenario with complete happy path
const defaultScenario: ScenaristScenario = {
  id: 'default',
  name: 'Happy Path',
  description: 'All external APIs succeed with valid responses',
  mocks: [
    // Stripe: Successful payment
    {
      method: 'POST',
      url: 'https://api.stripe.com/v1/charges',
      response: {
        status: 200,
        body: { id: 'ch_123', status: 'succeeded', amount: 5000 },
      },
    },
    // Auth0: Authenticated standard user
    {
      method: 'GET',
      url: 'https://api.auth0.com/userinfo',
      response: {
        status: 200,
        body: { sub: 'user_123', email: 'john@example.com', tier: 'standard' },
      },
    },
    // SendGrid: Email sent successfully
    {
      method: 'POST',
      url: 'https://api.sendgrid.com/v3/mail/send',
      response: {
        status: 202,
        body: { message_id: 'msg_123' },
      },
    },
  ],
};

// Specialized scenario: Override ONLY Auth0 for premium user
const premiumUserScenario: ScenaristScenario = {
  id: 'premiumUser',
  name: 'Premium User',
  description: 'Premium tier user, everything else succeeds',
  mocks: [
    // Override: Auth0 returns premium tier
    {
      method: 'GET',
      url: 'https://api.auth0.com/userinfo',
      response: {
        status: 200,
        body: { sub: 'user_456', email: 'premium@example.com', tier: 'premium' },
      },
    },
    // Stripe and SendGrid automatically fall back to default (happy path)
  ],
};

export const scenarios = {
  default: defaultScenario,
  premiumUser: premiumUserScenario,
} as const satisfies ScenaristScenarios;
```

## 2. Set Up Scenarist

```typescript
// lib/scenarist.ts
import { createScenarist } from '@scenarist/nextjs-adapter/app';
import { scenarios } from './scenarios';

// createScenarist is async - use top-level await
export const scenarist = await createScenarist({
  enabled: process.env.NODE_ENV === 'test',
  scenarios,
});

// Auto-start MSW server in test environment
if (typeof window === 'undefined' && scenarist) {
  scenarist.start();
}
```

<Aside type="tip" title="Top-Level Await">

**Top-level await** is supported in Next.js 13+ and works seamlessly. The `await` keyword enables defense-in-depth production safety through dynamic imports.

</Aside>

<Aside type="danger" title="CRITICAL: Singleton Pattern Required">

**You MUST use the `export const scenarist` pattern shown above.** Do NOT create scenarist inside functions or components:

```typescript
// ❌ WRONG - Creates new instance each time
export async function getScenarist() {
  return await createScenarist({ enabled: true, scenarios });
}

// ❌ WRONG - Creates new instance per import
export default await createScenarist({ enabled: true, scenarios });

// ✅ CORRECT - Single exported constant with await
export const scenarist = await createScenarist({ enabled: true, scenarios });
```

**Why this matters:** Scenarist handles a Next.js-specific issue for you. Next.js can cause module duplication, where the same file is loaded multiple times in the same process ([see Next.js Discussion #68572](https://github.com/vercel/next.js/discussions/68572)). This breaks the singleton pattern and can cause:

- `[MSW] Multiple handlers with the same URL` warnings
- Intermittent 500 errors from MSW
- Different tests getting wrong scenarios
- Scenarios not switching properly

**How Scenarist solves this:** The `createScenarist()` function includes built-in singleton protection using `global.__scenarist_instance`, ensuring only ONE instance exists even when Next.js duplicates your module. However, this protection **only works if you export a constant** - wrapping it in a function bypasses the singleton guard because each function call creates a new instance.

**The pattern:** Always use `export const scenarist = createScenarist(...)`. Scenarist handles the complex singleton logic for you so you don't need to understand Next.js internals or manage global variables yourself.

</Aside>

<Aside type="tip" title="Why Scenarist Handles This For You">

The module duplication issue is a [well-known Next.js challenge](https://github.com/vercel/next.js/discussions/68572) that affects any library using singletons. Rather than forcing every application to implement the `globalThis` pattern correctly, Scenarist builds singleton protection directly into the adapter. You just use a simple `export const` and everything works.

</Aside>

## 3. Enable Instrumentation Hook (REQUIRED)

<Aside type="danger" title="⚠️ CRITICAL: This Step is REQUIRED">

**You MUST create this file for Scenarist to work with Next.js.** Without it, MSW won't be initialized before your Server Components or Route Handlers try to fetch data, causing real HTTP requests instead of mocked responses.

</Aside>

Now that we've created `lib/scenarist.ts`, we need to ensure it loads before Next.js starts processing requests. Create `instrumentation.ts` at the root of your Next.js project:

```typescript
// instrumentation.ts
export async function register() {
  // MSW requires Node.js APIs not available in Edge runtime
  if (process.env.NEXT_RUNTIME !== 'edge') {
    // Import and start scenarist on server startup
    // This ensures MSW is ready before Server Components fetch data
    await import('./lib/scenarist');
  }
}
```

**Enable instrumentation in `next.config.js`:**

```javascript
// next.config.js
module.exports = {
  experimental: {
    instrumentationHook: true,
  },
};
```

**Why this is required:** Next.js Server Components and data fetching run immediately on server startup. The instrumentation hook ensures MSW is initialized before any components try to fetch data.

**Why Edge runtime is excluded:** MSW requires Node.js APIs (fs, crypto) that aren't available in Edge runtime. This isn't a problem because:
- Tests always use Node.js runtime (where Scenarist works)
- Production tree-shakes Scenarist completely (0kb bundle)
- Edge Functions can't be tested with Scenarist (fundamental MSW limitation)

**Learn more:** [Next.js Instrumentation Docs](https://nextjs.org/docs/app/building-your-application/optimizing/instrumentation)

## 4. Create Scenario Control Endpoint

```typescript
// app/api/%5F%5Fscenario%5F%5F/route.ts
import { NextResponse } from 'next/server';
import { scenarist } from '@/lib/scenarist';

// Fallback handler for production (when scenarist is undefined)
const productionHandler = async () => {
  return NextResponse.json(
    { error: 'Scenario endpoint not available in production' },
    { status: 404 }
  );
};

const handler = scenarist?.createScenarioEndpoint() ?? productionHandler;

export const POST = handler;
export const GET = handler;
```

:::note[Why URL-encoded folder name?]
The folder is named `%5F%5Fscenario%5F%5F` (URL-encoded underscores) because Next.js treats folders starting with `_` as [private folders](https://nextjs.org/docs/app/getting-started/project-structure#private-folders) that are excluded from routing. To create a public route with underscores, you must URL-encode them.

The route will be accessible at `/__scenario__` in your application. While this endpoint path is configurable via `scenarist` config options, using `/__scenario__` is the recommended approach.
:::

## 5. Set Up Playwright Fixtures

```typescript
// tests/fixtures.ts
import { withScenarios, expect } from '@scenarist/playwright-helpers';
import { scenarios } from '../lib/scenarios';

// Create type-safe test object with scenario IDs
export const test = withScenarios(scenarios);
export { expect };
```

## 6. Write Tests

```typescript
// tests/products.spec.ts
import { test, expect } from './fixtures'; // ✅ Import from fixtures

test('premium users see premium pricing', async ({ page, switchScenario }) => {
  await switchScenario(page, 'premiumUser'); // ✅ Type-safe! Autocomplete works

  await page.goto('/products');

  // Your Server Component executes and renders
  // Auth0 API returns premium tier, Stripe/SendGrid fall back to default
  await expect(page.getByText('Premium Plan')).toBeVisible();
  await expect(page.getByText('$50.00')).toBeVisible();
});

test('standard users see standard pricing', async ({ page, switchScenario }) => {
  await switchScenario(page, 'default'); // Default scenario (happy path)

  await page.goto('/products');

  await expect(page.getByText('Standard Plan')).toBeVisible();
  await expect(page.getByText('$25.00')).toBeVisible();
});
```

:::tip[Recommended: Playwright Testing]
We recommend using **Playwright** for testing Next.js applications with Scenarist. The fixtures pattern shown above provides type-safe scenario switching with autocomplete.

**Why Playwright?**
- Test Server Components with real rendering
- Type-safe scenario IDs with autocomplete
- Parallel test execution with test ID isolation
- No mocking of Next.js internals

**[Learn more about Playwright testing →](/introduction/testing-with-playwright)**
:::

**Example Server Component:**

```typescript
// app/products/page.tsx
export default async function ProductsPage() {
  // This fetch is mocked by Scenarist
  const response = await fetch('https://api.stripe.com/v1/products', {
    headers: { 'Authorization': `Bearer ${process.env.STRIPE_KEY}` },
  });

  const { data: products } = await response.json();

  // Your component renders with mocked data
  return (
    <div>
      {products.map(product => (
        <div key={product.id}>
          <h2>{product.name}</h2>
          <span className="price">${(product.price / 100).toFixed(2)}</span>
        </div>
      ))}
    </div>
  );
}
```

## Forwarding Headers to External APIs

**Why header forwarding matters:** When your Server Components or Route Handlers call external APIs (that you're mocking with Scenarist), you must forward the test ID header so MSW knows which scenario to use.

### Server Components (ReadonlyHeaders)

Server Components use `headers()` from `next/headers`, which returns `ReadonlyHeaders` (not a `Request` object):

```typescript
// app/products/page.tsx
import { headers } from 'next/headers';
import { getScenaristHeadersFromReadonlyHeaders } from '@scenarist/nextjs-adapter/app';

export default async function ProductsPage() {
  // Get headers from Next.js Server Component
  const headersList = await headers();

  // Forward Scenarist headers to external API
  const response = await fetch('https://api.stripe.com/v1/products', {
    headers: {
      ...getScenaristHeadersFromReadonlyHeaders(headersList), // ✅ For ReadonlyHeaders
      'Authorization': `Bearer ${process.env.STRIPE_KEY}`,
    },
  });

  const { data: products } = await response.json();

  return (
    <div>
      {products.map(product => (
        <div key={product.id}>
          <h2>{product.name}</h2>
          <span className="price">${(product.price / 100).toFixed(2)}</span>
        </div>
      ))}
    </div>
  );
}
```

<Aside type="tip" title="Production Safety">

**All helper functions are production-safe:**
- Return `{}` (empty object) when scenarist is undefined
- Safe to spread in headers without guards
- Zero runtime overhead (tree-shaken in production builds)

You don't need `if (scenarist)` checks - just spread the helpers directly into your fetch headers.

</Aside>

### Route Handlers (Request object)

Route Handlers have access to the `Request` object:

```typescript
// app/api/products/route.ts
import { getScenaristHeaders } from '@scenarist/nextjs-adapter/app';

export async function GET(request: Request) {
  const response = await fetch('https://api.stripe.com/v1/products', {
    headers: {
      ...getScenaristHeaders(request), // ✅ For Request objects
      'Authorization': `Bearer ${process.env.STRIPE_KEY}`,
    },
  });

  const data = await response.json();
  return Response.json(data);
}
```

### When to use which helper

- **`getScenaristHeadersFromReadonlyHeaders(headersList)`** - Server Components (using `headers()` from `next/headers`)
- **`getScenaristHeaders(request)`** - Route Handlers (using `Request` object)

Both helpers extract the test ID header and respect your configured header names and defaults. Import them from `@scenarist/nextjs-adapter/app`

## What Makes App Router Setup Special

**Server Components Actually Execute** - Unlike traditional mocking, your React Server Components render and run your application logic.

**Route Handlers Run Normally** - Your validation, error handling, and business logic all execute.

**Test Isolation** - Each test gets isolated scenario state. Run tests in parallel with zero interference.

**No App Restart** - Switch scenarios instantly during test execution.

## Next Steps

- **[Testing Database Apps →](/guides/testing-database-apps)** - Learn how to test Next.js apps with database access using API route abstraction
- **[Example App →](/frameworks/nextjs-app-router/example-app)** - See a complete working example with Server Components, sequences, and stateful mocks
- **[Architecture →](/concepts/architecture)** - Learn how Scenarist works under the hood
