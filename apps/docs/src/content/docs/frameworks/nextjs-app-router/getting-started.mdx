---
title: Next.js App Router - Getting Started
description: Set up Scenarist with Next.js App Router in 5 minutes
---

# Next.js App Router - Getting Started

Test your Next.js App Router application with Server Components, Route Handlers, and Server Actions all executing. No mocking of Next.js internals required.

## Installation

```bash
npm install @scenarist/core @scenarist/nextjs-adapter
npm install -D @playwright/test @scenarist/playwright-helpers
```

## 1. Define Scenarios

```typescript
// lib/scenarios.ts
import type { ScenaristScenario, ScenaristScenarios } from '@scenarist/core';

const successScenario: ScenaristScenario = {
  id: 'success',
  name: 'Payment Success',
  mocks: [
    {
      method: 'GET',
      url: 'https://api.stripe.com/v1/products',
      response: {
        status: 200,
        body: { data: [{ id: 'prod_123', name: 'Premium Plan', price: 5000 }] },
      },
    },
  ],
};

export const scenarios = {
  default: successScenario,
  success: successScenario,
} as const satisfies ScenaristScenarios;
```

## 2. Set Up Scenarist

```typescript
// lib/scenarist.ts
import { createScenarist } from '@scenarist/nextjs-adapter/app';
import { scenarios } from './scenarios';

export const scenarist = createScenarist({
  enabled: process.env.NODE_ENV === 'test',
  scenarios,
});
```

:::caution[CRITICAL: Singleton Pattern Required]
**You MUST use the `export const scenarist` pattern shown above.** Do NOT create scenarist inside functions or components:

```typescript
// ❌ WRONG - Creates new instance each time
export function getScenarist() {
  return createScenarist({ enabled: true, scenarios });
}

// ❌ WRONG - Creates new instance per import
export default createScenarist({ enabled: true, scenarios });

// ✅ CORRECT - Single exported constant
export const scenarist = createScenarist({ enabled: true, scenarios });
```

**Why this matters:** Next.js dev server (and Turbopack) can cause module duplication, where the same file is loaded multiple times. If `createScenarist()` is called multiple times, you'll get multiple MSW servers trying to intercept the same requests, causing conflicts and 500 errors.

The singleton pattern inside `createScenarist()` ensures that even if the module is loaded twice, only ONE MSW server is created. But this ONLY works if you export a constant, not a function that calls `createScenarist()` on each invocation.

**Symptoms of violation:**
- `[MSW] Multiple handlers with the same URL` warnings
- Intermittent 500 errors from JSON-server
- Different tests getting wrong scenarios
- Scenarios not switching properly

**The Fix:** Always use `export const scenarist = createScenarist(...)` pattern.
:::

## 3. Create Scenario Control Endpoint

```typescript
// app/api/%5F%5Fscenario%5F%5F/route.ts
import { scenarist } from '@/lib/scenarist';

export const POST = scenarist.createScenarioEndpoint();
export const GET = scenarist.createScenarioEndpoint();
```

:::note[Why URL-encoded folder name?]
The folder is named `%5F%5Fscenario%5F%5F` (URL-encoded underscores) because Next.js treats folders starting with `_` as [private folders](https://nextjs.org/docs/app/getting-started/project-structure#private-folders) that are excluded from routing. To create a public route with underscores, you must URL-encode them.

The route will be accessible at `/__scenario__` in your application. While this endpoint path is configurable via `scenarist` config options, using `/__scenario__` is the recommended approach.
:::

## 4. Test Server Components

```typescript
// tests/products.spec.ts
import { expect, withScenarios } from '@scenarist/playwright-helpers';
import { scenarios } from '../lib/scenarios';

export const test = withScenarios(scenarios);

test('Server Component fetches and renders product data', async ({ page, switchScenario }) => {
  await switchScenario(page, 'success'); // ✅ Type-safe!

  await page.goto('/products');

  // Your Server Component executes and renders
  // fetch() call to Stripe API is mocked
  await expect(page.locator('h2')).toContainText('Premium Plan');
  await expect(page.locator('.price')).toContainText('$50.00');
});
```

**Example Server Component:**

```typescript
// app/products/page.tsx
export default async function ProductsPage() {
  // This fetch is mocked by Scenarist
  const response = await fetch('https://api.stripe.com/v1/products', {
    headers: { 'Authorization': `Bearer ${process.env.STRIPE_KEY}` },
  });

  const { data: products } = await response.json();

  // Your component renders with mocked data
  return (
    <div>
      {products.map(product => (
        <div key={product.id}>
          <h2>{product.name}</h2>
          <span className="price">${(product.price / 100).toFixed(2)}</span>
        </div>
      ))}
    </div>
  );
}
```

## What Makes App Router Setup Special

**Server Components Actually Execute** - Unlike traditional mocking, your React Server Components render and run your application logic.

**Route Handlers Run Normally** - Your validation, error handling, and business logic all execute.

**Test Isolation** - Each test gets isolated scenario state. Run tests in parallel with zero interference.

**No App Restart** - Switch scenarios instantly during test execution.

## Next Steps

- **[Example App →](/frameworks/nextjs-app-router/example-app)** - See a complete working example with Server Components, sequences, and stateful mocks
- **[Architecture →](/concepts/architecture)** - Learn how Scenarist works under the hood
