---
title: Testing React Server Components
description: Complete guide to testing React Server Components with Scenarist - data fetching, stateful mocks, sequences, and request matching
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

React Server Components (RSC) represent a fundamental shift in how React applications render - but they also create new testing challenges. This guide shows you how to effectively test RSC using Scenarist and Playwright.

## Why Server Components Need Different Testing

### The Testing Gap

Where do Server Components fit in the testing pyramid? They don't fit neatly into traditional categories:

- **Not isolated units** - They fetch data, read cookies, access headers, and depend on server infrastructure
- **Not traditional integration tests** - They render UI, not just return data
- **Full E2E is too slow** - Spinning up browsers for every scenario combination doesn't scale

<Aside type="note" title="Broader Context">
This testing gap applies to all modern server-side code. See [Why Scenarist?](/getting-started/why-scenarist) for how Scenarist addresses middleware, session handling, and other server-side testing challenges, or explore the [Philosophy](/concepts/philosophy) for the core beliefs that guide Scenarist's design.
</Aside>

### The Jest Problem

```typescript
// This FAILS in Jest:
import { render } from '@testing-library/react';
import ProductsPage from './app/products/page';

test('renders products', async () => {
  render(<ProductsPage />);  // Error: Objects are not valid as a React child (found: [object Promise])
});
```

Jest and React Testing Library cannot render async Server Components because:

1. **Server Components return Promises** - RTL expects synchronous React elements
2. **Server-only APIs** - `headers()`, `cookies()` from `next/headers` throw outside Next.js
3. **No browser environment** - Server Components have no DOM to render into

From the [Next.js Testing Documentation](https://nextjs.org/docs/app/building-your-application/testing):

> "Since async Server Components are new to the React ecosystem, some tools do not fully support them. In the meantime, we recommend using End-to-End Testing over Unit Testing for async components."

### The Scenarist Solution

Scenarist + Playwright fills this gap by testing your server-side code **as it actually runs** - in a real Next.js environment with actual server-side rendering, middleware execution, and session handling:

```typescript
// This WORKS with Scenarist + Playwright:
import { test, expect } from './fixtures';

test('premium users see discounted pricing', async ({ page, switchScenario }) => {
  await switchScenario(page, 'premiumUser');

  await page.goto('/products?tier=premium');

  // Everything executes: middleware, session checks, RSC data fetching, rendering
  await expect(page.getByText('£99.99')).toBeVisible();
});
```

### What This Enables for RSC

Testing Server Components with Scenarist gives you capabilities that unit tests cannot provide:

| RSC Challenge | Unit Tests | Scenarist + Playwright |
|---------------|------------|------------------------|
| Async component rendering | ❌ RTL can't render Promises | ✅ Full server-side rendering |
| `headers()` / `cookies()` APIs | ❌ Throw outside Next.js | ✅ Real Next.js execution |
| Data fetching in components | ❌ Must mock fetch globally | ✅ Real fetch, mocked external APIs |
| Error boundaries | ❌ Must mock error conditions | ✅ Real error propagation |

**Why this matters for RSC specifically:**

- **No mocking Next.js internals** - `headers()`, `cookies()`, and other server APIs work naturally
- **Real server-side rendering** - HTML is generated exactly as in production
- **Actual component composition** - Parent/child RSC relationships execute correctly
- **Fast scenario switching** - Test many data fetching scenarios without server restarts

<Aside type="tip" title="Speed + Confidence">
Test dozens of RSC data fetching scenarios in the time it takes to run a few traditional E2E tests. Scenario switching is instant - no server restarts needed.
</Aside>

## Setup Requirements for App Router

Before testing RSC patterns, ensure your setup includes header forwarding. This is critical because Server Components need to forward the test ID header to external APIs.

### Header Forwarding in Server Components

Server Components use `headers()` from `next/headers`, which returns `ReadonlyHeaders`. Use the dedicated helper:

```typescript
// app/products/page.tsx
import { headers } from 'next/headers';
import { getScenaristHeadersFromReadonlyHeaders } from '@scenarist/nextjs-adapter/app';

export default async function ProductsPage() {
  const headersList = await headers();

  const response = await fetch('https://api.stripe.com/v1/products', {
    headers: {
      ...getScenaristHeadersFromReadonlyHeaders(headersList), // Forward test ID
      'Authorization': `Bearer ${process.env.STRIPE_KEY}`,
    },
  });

  const products = await response.json();
  return <ProductList products={products} />;
}
```

<Aside type="tip" title="Why Header Forwarding Matters">
Each Playwright test has a unique test ID (`x-scenarist-test-id`). This header tells MSW which scenario to use for each request. Without forwarding, your Server Component's fetch calls won't be associated with the correct test scenario.
</Aside>

For complete setup instructions, see [Getting Started with Next.js App Router](/frameworks/nextjs-app-router/getting-started).

---

## Pattern 1: Data Fetching in Server Components

The most common RSC pattern is fetching data server-side. Scenarist makes this testable by intercepting the fetch calls and returning scenario-defined responses.

### Example: Products Page

**Server Component:** [`app/products/page.tsx`](https://github.com/citypaul/scenarist/blob/main/apps/nextjs-app-router-example/app/products/page.tsx)

```typescript
// app/products/page.tsx
import { headers } from 'next/headers';
import { getScenaristHeadersFromReadonlyHeaders } from '@scenarist/nextjs-adapter/app';

type ProductsPageProps = {
  searchParams: Promise<{ tier?: string }>;
};

async function fetchProducts(tier: string = 'standard'): Promise<ProductsResponse> {
  const headersList = await headers();

  const response = await fetch('http://localhost:3001/products', {
    headers: {
      ...getScenaristHeadersFromReadonlyHeaders(headersList),
      'x-user-tier': tier,  // Application context for API
    },
    cache: 'no-store',
  });

  return response.json();
}

export default async function ProductsPage({ searchParams }: ProductsPageProps) {
  const { tier = 'standard' } = await searchParams;
  const data = await fetchProducts(tier);

  return (
    <div>
      <h1>Products</h1>
      {data.products.map((product) => (
        <div key={product.id}>
          <h2>{product.name}</h2>
          <span>£{product.price.toFixed(2)}</span>
        </div>
      ))}
    </div>
  );
}
```

### Scenario Definition

**Scenarios:** [`lib/scenarios.ts`](https://github.com/citypaul/scenarist/blob/main/apps/nextjs-app-router-example/lib/scenarios.ts)

```typescript
// lib/scenarios.ts
import type { ScenaristScenario } from '@scenarist/nextjs-adapter/app';

export const premiumUserScenario: ScenaristScenario = {
  id: 'premiumUser',
  name: 'Premium User',
  description: 'Premium tier pricing',
  mocks: [
    {
      method: 'GET',
      url: 'http://localhost:3001/products',
      match: {
        headers: { 'x-user-tier': 'premium' },
      },
      response: {
        status: 200,
        body: {
          products: [
            { id: 1, name: 'Product A', price: 99.99, tier: 'premium' },
            { id: 2, name: 'Product B', price: 199.99, tier: 'premium' },
          ],
        },
      },
    },
  ],
};

export const standardUserScenario: ScenaristScenario = {
  id: 'standardUser',
  name: 'Standard User',
  description: 'Standard tier pricing',
  mocks: [
    {
      method: 'GET',
      url: 'http://localhost:3001/products',
      match: {
        headers: { 'x-user-tier': 'standard' },
      },
      response: {
        status: 200,
        body: {
          products: [
            { id: 1, name: 'Product A', price: 149.99, tier: 'standard' },
            { id: 2, name: 'Product B', price: 249.99, tier: 'standard' },
          ],
        },
      },
    },
  ],
};
```

<Aside type="tip" title="Request Matching">
The `match` criteria above route requests to different responses based on headers. Scenarist supports matching on headers, query params, body content, and regex patterns. See [Request Matching](/scenarios/request-matching) for the complete reference.
</Aside>

### Test Implementation

**Test:** [`tests/playwright/products-server-components.spec.ts`](https://github.com/citypaul/scenarist/blob/main/apps/nextjs-app-router-example/tests/playwright/products-server-components.spec.ts)

```typescript
// tests/playwright/products-server-components.spec.ts
import { test, expect } from './fixtures';

test.describe('Products Page - React Server Components', () => {
  test('should render products with premium tier pricing', async ({
    page,
    switchScenario,
  }) => {
    await switchScenario(page, 'premiumUser');

    await page.goto('/products?tier=premium');

    // Verify Server Component rendered
    await expect(page.getByRole('heading', { name: 'Products' })).toBeVisible();

    // Verify premium pricing from mocked API
    await expect(page.getByText('£99.99')).toBeVisible();
  });

  test('should render products with standard tier pricing', async ({
    page,
    switchScenario,
  }) => {
    await switchScenario(page, 'standardUser');

    await page.goto('/products?tier=standard');

    // Verify standard pricing from mocked API
    await expect(page.getByText('£149.99')).toBeVisible();
  });

  test('should switch tiers at runtime without app restart', async ({
    page,
    switchScenario,
  }) => {
    // Start with premium
    await switchScenario(page, 'premiumUser');
    await page.goto('/products?tier=premium');
    await expect(page.getByText('£99.99')).toBeVisible();

    // Switch to standard - no restart needed!
    await switchScenario(page, 'standardUser');
    await page.goto('/products?tier=standard');
    await expect(page.getByText('£149.99')).toBeVisible();
  });
});
```

---

## Pattern 2: Stateful Mocks with RSC

Stateful mocks capture data from one request and inject it into later responses. This is essential for testing flows like shopping carts where state builds up across multiple requests. **State is isolated per test ID**, so parallel tests never conflict—each test maintains its own cart state.

### Example: Server-Side Cart

**Server Component:** [`app/cart-server/page.tsx`](https://github.com/citypaul/scenarist/blob/main/apps/nextjs-app-router-example/app/cart-server/page.tsx)

```typescript
// app/cart-server/page.tsx
import { headers } from 'next/headers';
import { getScenaristHeadersFromReadonlyHeaders } from '@scenarist/nextjs-adapter/app';

type CartResponse = {
  readonly items?: ReadonlyArray<string>;
};

async function fetchCart(): Promise<CartResponse> {
  const headersList = await headers();

  const response = await fetch('http://localhost:3001/cart', {
    headers: {
      ...getScenaristHeadersFromReadonlyHeaders(headersList),
    },
    cache: 'no-store',
  });

  return response.json();
}

export default async function CartServerPage() {
  const cartData = await fetchCart();
  const cartItems = aggregateCartItems(cartData.items);

  return (
    <div>
      <h1>Shopping Cart</h1>
      {cartItems.length === 0 ? (
        <p>Your cart is empty</p>
      ) : (
        <div>
          {cartItems.map((item) => (
            <div key={item.id}>
              <h3>{item.name}</h3>
              <p>Quantity: {item.quantity}</p>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
```

### Stateful Scenario Definition

```typescript
// lib/scenarios.ts
import type { ScenaristScenario } from '@scenarist/nextjs-adapter/app';

export const cartWithStateScenario: ScenaristScenario = {
  id: 'cartWithState',
  name: 'Shopping Cart with State',
  description: 'Stateful cart that captures and injects items',
  mocks: [
    // GET /cart - Inject cartItems from state (null initially)
    {
      method: 'GET',
      url: 'http://localhost:3001/cart',
      response: {
        status: 200,
        body: {
          items: '{{state.cartItems}}',  // Template injection from state
        },
      },
    },
    // PATCH /cart - Capture full items array into state
    {
      method: 'PATCH',
      url: 'http://localhost:3001/cart',
      captureState: {
        cartItems: 'body.items',  // Capture from request body
      },
      response: {
        status: 200,
        body: {
          items: '{{body.items}}',  // Echo back
        },
      },
    },
  ],
};
```

### Test Implementation

**Test:** [`tests/playwright/cart-server-components.spec.ts`](https://github.com/citypaul/scenarist/blob/main/apps/nextjs-app-router-example/tests/playwright/cart-server-components.spec.ts)

```typescript
// tests/playwright/cart-server-components.spec.ts
import { test, expect } from './fixtures';

test.describe('Cart Server Page - Stateful Mocks', () => {
  test('should show empty cart initially', async ({ page, switchScenario }) => {
    await switchScenario(page, 'cartWithState');
    await page.goto('/cart-server');

    await expect(page.getByText('Your cart is empty')).toBeVisible();
  });

  test('should display cart item after adding product', async ({
    page,
    switchScenario,
  }) => {
    const testId = await switchScenario(page, 'cartWithState');

    // Add product through API route
    // Note: page.request uses a separate context, so include test ID header
    await page.request.post('http://localhost:3002/api/cart/add', {
      headers: {
        'Content-Type': 'application/json',
        'x-scenarist-test-id': testId,
      },
      data: { productId: 'prod-1' },
    });

    // Navigate to cart - Server Component fetches with same test ID
    await page.goto('/cart-server');

    // State was captured from POST and injected into GET response
    await expect(page.getByText('Product A')).toBeVisible();
    await expect(page.getByText('Quantity: 1')).toBeVisible();
  });

  test('should aggregate quantities for same product', async ({
    page,
    switchScenario,
  }) => {
    const testId = await switchScenario(page, 'cartWithState');

    // Add same product 3 times
    for (let i = 0; i < 3; i++) {
      await page.request.post('http://localhost:3002/api/cart/add', {
        headers: {
          'Content-Type': 'application/json',
          'x-scenarist-test-id': testId,
        },
        data: { productId: 'prod-1' },
      });
    }

    await page.goto('/cart-server');

    // Should show aggregated quantity
    await expect(page.getByText('Quantity: 3')).toBeVisible();
  });
});
```

<Aside type="note" title="State Isolation">
Each test gets its own isolated state via the test ID. Parallel tests won't interfere with each other's cart contents.
</Aside>

---

## Pattern 3: Polling & Sequences in RSC

Sequences return different responses on successive requests - perfect for testing polling scenarios, retry logic, or multi-step workflows.

### Example: Job Polling Page

**Server Component:** [`app/polling/page.tsx`](https://github.com/citypaul/scenarist/blob/main/apps/nextjs-app-router-example/app/polling/page.tsx)

```typescript
// app/polling/page.tsx
import { headers } from 'next/headers';
import { getScenaristHeadersFromReadonlyHeaders } from '@scenarist/nextjs-adapter/app';

type JobStatus = {
  readonly jobId: string;
  readonly status: 'pending' | 'processing' | 'complete';
  readonly progress: number;
};

async function fetchJobStatus(jobId: string): Promise<JobStatus> {
  const headersList = await headers();

  const response = await fetch(`http://localhost:3001/github/jobs/${jobId}`, {
    headers: {
      ...getScenaristHeadersFromReadonlyHeaders(headersList),
    },
    cache: 'no-store',
  });

  return response.json();
}

export default async function PollingPage({ searchParams }) {
  const { jobId = '123' } = await searchParams;
  const job = await fetchJobStatus(jobId);

  return (
    <div>
      <h1>Job Status</h1>
      <span>{job.status.toUpperCase()}</span>
      <div>Progress: {job.progress}%</div>
    </div>
  );
}
```

### Sequence Scenario Definition

```typescript
// lib/scenarios.ts
import type { ScenaristScenario } from '@scenarist/nextjs-adapter/app';

export const githubPollingScenario: ScenaristScenario = {
  id: 'githubPolling',
  name: 'GitHub Job Polling',
  description: 'Polling sequence: pending → processing → complete',
  mocks: [
    {
      method: 'GET',
      url: 'http://localhost:3001/github/jobs/:id',
      sequence: {
        responses: [
          {
            status: 200,
            body: { jobId: '123', status: 'pending', progress: 0 },
          },
          {
            status: 200,
            body: { jobId: '123', status: 'processing', progress: 50 },
          },
          {
            status: 200,
            body: { jobId: '123', status: 'complete', progress: 100 },
          },
        ],
        repeat: 'last',  // After exhaustion, keep returning 'complete'
      },
    },
  ],
};
```

### Test Implementation

**Test:** [`tests/playwright/polling-server-components.spec.ts`](https://github.com/citypaul/scenarist/blob/main/apps/nextjs-app-router-example/tests/playwright/polling-server-components.spec.ts)

```typescript
// tests/playwright/polling-server-components.spec.ts
import { test, expect } from './fixtures';

test.describe('Polling Page - Sequences with Server Components', () => {
  test('should show pending status on first request', async ({
    page,
    switchScenario,
  }) => {
    await switchScenario(page, 'githubPolling');

    await page.goto('/polling?jobId=123');

    // First sequence position: pending
    await expect(page.getByText('PENDING')).toBeVisible();
    await expect(page.getByText('0%')).toBeVisible();
  });

  test('should advance through sequence on page reloads', async ({
    page,
    switchScenario,
  }) => {
    await switchScenario(page, 'githubPolling');

    // First request: pending
    await page.goto('/polling?jobId=123');
    await expect(page.getByText('PENDING')).toBeVisible();

    // Second request: processing
    await page.reload();
    await expect(page.getByText('PROCESSING')).toBeVisible();
    await expect(page.getByText('50%')).toBeVisible();

    // Third request: complete
    await page.reload();
    await expect(page.getByText('COMPLETE')).toBeVisible();
    await expect(page.getByText('100%')).toBeVisible();
  });

  test('should repeat last response after sequence exhaustion', async ({
    page,
    switchScenario,
  }) => {
    await switchScenario(page, 'githubPolling');

    // Advance through all sequence positions
    await page.goto('/polling?jobId=123');  // pending
    await page.reload();  // processing
    await page.reload();  // complete

    // Verify complete
    await expect(page.getByText('COMPLETE')).toBeVisible();

    // Fourth request - should still be complete (repeat: 'last')
    await page.reload();
    await expect(page.getByText('COMPLETE')).toBeVisible();
  });
});
```

### Sequence Repeat Modes

| Mode | Behavior | Use Case |
|------|----------|----------|
| `'last'` | Repeat final response forever | Polling until completion |
| `'cycle'` | Loop back to first response | Cyclical patterns (weather) |
| `'none'` | Fall through to next mock | Rate limiting after N attempts |

---

## Pattern 4: Streaming & Suspense

React Server Components support streaming - sending HTML progressively as data becomes available. When combined with Suspense boundaries, you can show fallback UI immediately while async components load. Scenarist makes testing these patterns straightforward.

### How Streaming Works with RSC

1. **Initial Response**: The shell (layout, navigation) streams immediately with fallback UI
2. **Suspense Fallback**: A loading skeleton shows while the async component fetches data
3. **Streaming Update**: When data is ready, React streams the actual content, replacing the skeleton

### Example: Streaming Products Page

The streaming page demonstrates Suspense boundaries with an async Server Component.

**Page with Suspense:** [`app/streaming/page.tsx`](https://github.com/citypaul/scenarist/blob/main/apps/nextjs-app-router-example/app/streaming/page.tsx)

```typescript
// app/streaming/page.tsx
import { Suspense } from 'react';
import SlowProducts from './slow-products';

type StreamingPageProps = {
  searchParams: Promise<{ tier?: string }>;
};

function ProductsSkeleton() {
  return (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-6" aria-label="Loading products">
      {[1, 2, 3].map((i) => (
        <div key={i} className="border rounded-lg p-6 animate-pulse">
          <div className="h-6 bg-gray-200 rounded mb-4 w-3/4" />
          <div className="h-4 bg-gray-200 rounded mb-2" />
          <div className="h-8 bg-gray-200 rounded w-24" />
        </div>
      ))}
    </div>
  );
}

export default async function StreamingPage({ searchParams }: StreamingPageProps) {
  const { tier = 'standard' } = await searchParams;

  return (
    <div>
      <h1>Streaming Products</h1>
      <Suspense fallback={<ProductsSkeleton />}>
        <SlowProducts tier={tier} />
      </Suspense>
    </div>
  );
}
```

**Async Component:** [`app/streaming/slow-products.tsx`](https://github.com/citypaul/scenarist/blob/main/apps/nextjs-app-router-example/app/streaming/slow-products.tsx)

```typescript
// app/streaming/slow-products.tsx
import { headers } from 'next/headers';
import { getScenaristHeadersFromReadonlyHeaders } from '@scenarist/nextjs-adapter/app';

type SlowProductsProps = {
  readonly tier: string;
};

async function fetchProducts(tier: string): Promise<ProductsResponse> {
  const headersList = await headers();

  const response = await fetch('http://localhost:3002/api/products', {
    headers: {
      ...getScenaristHeadersFromReadonlyHeaders(headersList),
      'x-user-tier': tier,
    },
    cache: 'no-store',
  });

  return response.json();
}

export default async function SlowProducts({ tier }: SlowProductsProps) {
  const data = await fetchProducts(tier);

  return (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
      {data.products.map((product) => (
        <article key={product.id}>
          <h2>{product.name}</h2>
          <span>£{product.price.toFixed(2)}</span>
          <span>{product.tier}</span>
        </article>
      ))}
    </div>
  );
}
```

<Aside type="tip" title="Suspense Architecture">
The page component is synchronous and renders immediately with the skeleton. The async `SlowProducts` component is wrapped in Suspense - React streams it when ready. This separation is key: fast shell, deferred content.
</Aside>

### Scenario Definition

```typescript
// lib/scenarios.ts
import type { ScenaristScenario } from '@scenarist/nextjs-adapter/app';

export const streamingScenario: ScenaristScenario = {
  id: 'streaming',
  name: 'Streaming Demo',
  description: 'Demonstrates Suspense boundary with streaming RSC',
  mocks: [
    {
      method: 'GET',
      url: 'http://localhost:3001/products',
      match: {
        headers: { 'x-user-tier': 'standard' },
      },
      response: {
        status: 200,
        body: {
          products: [
            { id: 1, name: 'Product A', price: 149.99, tier: 'standard' },
            { id: 2, name: 'Product B', price: 249.99, tier: 'standard' },
            { id: 3, name: 'Product C', price: 349.99, tier: 'standard' },
          ],
        },
      },
    },
  ],
};

export const streamingPremiumUserScenario: ScenaristScenario = {
  id: 'streamingPremiumUser',
  name: 'Streaming Demo (Premium)',
  description: 'Streaming with premium tier products',
  mocks: [
    {
      method: 'GET',
      url: 'http://localhost:3001/products',
      match: {
        headers: { 'x-user-tier': 'premium' },
      },
      response: {
        status: 200,
        body: {
          products: [
            { id: 1, name: 'Product A', price: 99.99, tier: 'premium' },
            { id: 2, name: 'Product B', price: 199.99, tier: 'premium' },
            { id: 3, name: 'Product C', price: 299.99, tier: 'premium' },
          ],
        },
      },
    },
  ],
};
```

### Test Implementation

**Test:** [`tests/playwright/streaming.spec.ts`](https://github.com/citypaul/scenarist/blob/main/apps/nextjs-app-router-example/tests/playwright/streaming.spec.ts)

```typescript
// tests/playwright/streaming.spec.ts
import { test, expect } from './fixtures';

test.describe('Streaming Page - Suspense Boundaries', () => {
  test('should render products after Suspense boundary resolves', async ({
    page,
    switchScenario,
  }) => {
    await switchScenario(page, 'streaming');
    await page.goto('/streaming');

    // Wait for products to render (Suspense resolved)
    await expect(page.getByRole('article')).toHaveCount(3);

    // Verify product names are visible
    await expect(page.getByRole('heading', { name: 'Product A' })).toBeVisible();
    await expect(page.getByRole('heading', { name: 'Product B' })).toBeVisible();
    await expect(page.getByRole('heading', { name: 'Product C' })).toBeVisible();
  });

  test('should render standard tier products with standard pricing', async ({
    page,
    switchScenario,
  }) => {
    await switchScenario(page, 'streaming');
    await page.goto('/streaming?tier=standard');

    // Standard price for Product A is £149.99
    await expect(page.getByText('£149.99')).toBeVisible();

    // Verify tier badge shows standard
    const firstProduct = page.getByRole('article').first();
    await expect(firstProduct.getByText('standard', { exact: false })).toBeVisible();
  });

  test('should render premium tier products with premium pricing', async ({
    page,
    switchScenario,
  }) => {
    await switchScenario(page, 'streamingPremiumUser');
    await page.goto('/streaming?tier=premium');

    // Premium price for Product A is £99.99 (lower than standard)
    await expect(page.getByText('£99.99')).toBeVisible();

    // Verify tier badge shows premium
    const firstProduct = page.getByRole('article').first();
    await expect(firstProduct.getByText('premium', { exact: false })).toBeVisible();
  });

  test('should show loading skeleton initially before products load', async ({
    page,
    switchScenario,
  }) => {
    await switchScenario(page, 'streaming');
    await page.goto('/streaming', { waitUntil: 'domcontentloaded' });

    const skeleton = page.getByLabel('Loading products');

    // Handle race condition: skeleton may or may not be visible
    // depending on how fast the response comes back
    await Promise.race([
      skeleton.waitFor({ state: 'visible', timeout: 1000 }).catch(() => {}),
      page.getByRole('article').first().waitFor({ state: 'visible' }),
    ]);

    // Eventually, products should appear
    await expect(page.getByRole('article')).toHaveCount(3);

    // Skeleton should no longer be visible
    await expect(skeleton).not.toBeVisible();
  });
});
```

<Aside type="note" title="Testing Fallback UI">
Testing the loading skeleton requires handling a race condition - the fallback may only be visible briefly before the Suspense boundary resolves. The test above uses `Promise.race` to handle both cases: skeleton visible momentarily, or products appearing immediately. The key assertion is that products eventually render and the skeleton disappears.
</Aside>

### Key Points for Streaming Tests

| Aspect | Consideration |
|--------|---------------|
| **Fallback visibility** | May be brief; use race conditions or `waitUntil: 'domcontentloaded'` |
| **Scenario isolation** | Different scenarios (standard/premium) verify correct data flows through |
| **Header forwarding** | Async component must forward test ID via `getScenaristHeadersFromReadonlyHeaders()` |
| **Aria labels** | Add `aria-label` to skeleton for reliable test selection |

---

## Pattern 5: Authentication Flows

Authentication is a critical RSC pattern - protected routes must check auth status server-side before rendering. Scenarist makes this testable by letting you switch between authenticated and unauthenticated states.

### Example: Protected Route with Auth Check

**Auth Helper:** [`lib/auth.ts`](https://github.com/citypaul/scenarist/blob/main/apps/nextjs-app-router-example/lib/auth.ts)

```typescript
// lib/auth.ts
import { z } from 'zod';
import { getScenaristHeadersFromReadonlyHeaders } from '@scenarist/nextjs-adapter/app';
import type { ReadonlyHeaders } from 'next/dist/server/web/spec-extension/adapters/headers';

const UserSchema = z.object({
  id: z.string(),
  email: z.string(),
  name: z.string(),
});

type User = z.infer<typeof UserSchema>;

type AuthResult =
  | { readonly authenticated: true; readonly user: User }
  | { readonly authenticated: false; readonly error: string };

export const checkAuth = async (
  headersList: ReadonlyHeaders,
): Promise<AuthResult> => {
  const response = await fetch('http://localhost:3001/auth/me', {
    headers: {
      ...getScenaristHeadersFromReadonlyHeaders(headersList),
    },
    cache: 'no-store',  // Don't cache auth checks
  });

  if (!response.ok) {
    return { authenticated: false, error: 'Authentication required' };
  }

  const data: unknown = await response.json();
  const user = UserSchema.parse(data);

  return { authenticated: true, user };
};
```

**Protected Layout:** [`app/protected/layout.tsx`](https://github.com/citypaul/scenarist/blob/main/apps/nextjs-app-router-example/app/protected/layout.tsx)

```typescript
// app/protected/layout.tsx
import { headers } from 'next/headers';
import { redirect } from 'next/navigation';
import { checkAuth } from '@/lib/auth';

type ProtectedLayoutProps = {
  children: React.ReactNode;
};

export default async function ProtectedLayout({
  children,
}: ProtectedLayoutProps) {
  const headersList = await headers();
  const auth = await checkAuth(headersList);

  if (!auth.authenticated) {
    // Redirect to login with the original URL
    redirect('/login?from=/protected');
  }

  // User is authenticated - render with user context
  return (
    <div>
      <header>
        <span>Welcome, {auth.user.name}</span>
        <span>{auth.user.email}</span>
      </header>
      <main>{children}</main>
    </div>
  );
}
```

### Authentication Scenarios

**Scenarios:** [`lib/scenarios.ts`](https://github.com/citypaul/scenarist/blob/main/apps/nextjs-app-router-example/lib/scenarios.ts)

```typescript
// lib/scenarios.ts
import type { ScenaristScenario } from '@scenarist/nextjs-adapter/app';

export const authenticatedUserScenario: ScenaristScenario = {
  id: 'authenticatedUser',
  name: 'Authenticated User',
  description: 'User is authenticated with valid session',
  mocks: [
    {
      method: 'GET',
      url: 'http://localhost:3001/auth/me',
      response: {
        status: 200,
        body: {
          id: 'user-123',
          email: 'test@example.com',
          name: 'Test User',
        },
      },
    },
  ],
};

export const unauthenticatedUserScenario: ScenaristScenario = {
  id: 'unauthenticatedUser',
  name: 'Unauthenticated User',
  description: 'User is not authenticated',
  mocks: [
    {
      method: 'GET',
      url: 'http://localhost:3001/auth/me',
      response: {
        status: 401,
        body: {
          error: 'Unauthorized',
          message: 'Authentication required',
        },
      },
    },
  ],
};
```

### Test Implementation

**Test:** [`tests/playwright/auth-flows.spec.ts`](https://github.com/citypaul/scenarist/blob/main/apps/nextjs-app-router-example/tests/playwright/auth-flows.spec.ts)

```typescript
// tests/playwright/auth-flows.spec.ts
import { test, expect } from './fixtures';

test.describe('Authentication Flow - Protected Routes', () => {
  test('should render protected content when authenticated', async ({
    page,
    switchScenario,
  }) => {
    await switchScenario(page, 'authenticatedUser');

    await page.goto('/protected');

    // Verify protected content is visible
    await expect(
      page.getByRole('heading', { name: 'Protected Dashboard' }),
    ).toBeVisible();

    // Verify user info is displayed
    await expect(page.getByText('test@example.com')).toBeVisible();
    await expect(page.getByText('Welcome, Test User')).toBeVisible();
  });

  test('should redirect to login when not authenticated', async ({
    page,
    switchScenario,
  }) => {
    await switchScenario(page, 'unauthenticatedUser');

    await page.goto('/protected');

    // Should be redirected to login page
    await expect(page).toHaveURL(/\/login\?from=\/protected/);

    // Verify login page content
    await expect(
      page.getByRole('heading', { name: 'Sign In' }),
    ).toBeVisible();
  });

  test('should switch between auth states at runtime', async ({
    page,
    switchScenario,
  }) => {
    // Start as authenticated user
    await switchScenario(page, 'authenticatedUser');
    await page.goto('/protected');
    await expect(
      page.getByRole('heading', { name: 'Protected Dashboard' }),
    ).toBeVisible();

    // Switch to unauthenticated (simulating session expiry)
    await switchScenario(page, 'unauthenticatedUser');
    await page.reload();

    // Now redirected to login
    await expect(page).toHaveURL(/\/login/);
  });
});
```

<Aside type="tip" title="Testing Auth Without Real Auth">
Scenarist lets you test authentication flows without setting up real auth providers. Switch scenarios to simulate different auth states - no tokens, cookies, or sessions required.
</Aside>

---

## Common Pitfalls and Debugging

### Pitfall 1: Missing Header Forwarding

**Symptom:** Tests fail with "no mock matched" or default responses instead of scenario-specific ones.

**Cause:** Server Component fetches don't include the test ID header.

**Fix:** Always forward headers:

```typescript
// ✅ Correct
const headersList = await headers();
const response = await fetch(url, {
  headers: {
    ...getScenaristHeadersFromReadonlyHeaders(headersList),
  },
});

// ❌ Wrong - missing header forwarding
const response = await fetch(url);
```

### Pitfall 2: page.request Doesn't Include Test ID

**Symptom:** API calls from `page.request.post()` don't use the correct scenario.

**Cause:** `page.request` uses a separate HTTP context from the browser page.

**Fix:** Explicitly include the test ID header:

```typescript
test('adds item to cart', async ({ page, switchScenario }) => {
  const testId = await switchScenario(page, 'cartWithState');  // ✅ Capture testId

  await page.request.post('http://localhost:3002/api/cart/add', {
    headers: {
      'Content-Type': 'application/json',
      'x-scenarist-test-id': testId,  // ✅ Explicitly include
    },
    data: { productId: 'prod-1' },
  });
});
```

### Pitfall 3: Next.js Caching

**Symptom:** Same response returned despite scenario changes.

**Cause:** Next.js caches fetch responses by default.

**Fix:** Disable caching for testable fetches:

```typescript
const response = await fetch(url, {
  headers: { ... },
  cache: 'no-store',  // ✅ Disable caching
});
```

### Pitfall 4: Sequence Not Advancing

**Symptom:** Same response returned on every request.

**Cause:** Requests going to a different mock or different test ID.

**Fix:** Ensure URL matches exactly and headers are forwarded:

```typescript
// Scenario mock
{ method: 'GET', url: 'http://localhost:3001/github/jobs/:id', sequence: {...} }

// Component fetch - must match URL pattern
await fetch(`http://localhost:3001/github/jobs/${jobId}`, {  // ✅ Matches pattern
  headers: { ...getScenaristHeadersFromReadonlyHeaders(headersList) },
});
```

### Debugging Tips

1. **Check MSW logs** - Set `DEBUG=msw:*` environment variable
2. **Verify test ID** - Log `testId` from `switchScenario()` return value
3. **Inspect network** - Use Playwright's network recording
4. **Check scenario endpoint** - Verify `/__scenario__` returns success

---

## Coming Soon

The following advanced RSC patterns will be covered in upcoming documentation:

### Server Actions

Testing form submissions and mutations with Server Actions:

```typescript
// Future pattern preview
test('submits form via Server Action', async ({ page, switchScenario }) => {
  await switchScenario(page, 'formSubmission');
  await page.goto('/checkout');
  await page.fill('[name="email"]', 'test@example.com');
  await page.click('button[type="submit"]');
  await expect(page.getByText('Order confirmed')).toBeVisible();
});
```

### Error Boundaries

Testing error handling in Server Components with error boundaries.

<Aside type="note" title="Example Implementations">
These patterns require example implementations that are being developed. Once available, this guide will be updated with complete working examples and tests.
</Aside>

---

## Next Steps

- **[Next.js App Router Getting Started](/frameworks/nextjs-app-router/getting-started)** - Complete setup guide
- **[Example App](/frameworks/nextjs-app-router/example-app)** - Full working example with all patterns
- **[Writing Scenarios](/scenarios/overview)** - Request matching, sequences, and stateful mocks in depth
- **[Philosophy](/concepts/philosophy)** - Core beliefs behind Scenarist's testing approach
