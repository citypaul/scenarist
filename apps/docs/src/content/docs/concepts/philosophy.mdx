---
title: Philosophy
description: The core beliefs and principles that guide Scenarist's design
---

import { Aside } from '@astrojs/starlight/components';

Scenarist is built on a set of core beliefs about testing. These beliefs guide every design decision - from the scenario format to the architecture to what we deliberately don't support. Understanding them helps you use Scenarist effectively and evaluate whether it's right for your needs.

## Core Beliefs

### 1. Tests Should Verify Behavior, Not Implementation

The purpose of a test is to verify that your system **does the right thing**. Not that it calls the right functions. Not that it uses the right libraries. Not that it structures code a certain way.

**A good test passes when behavior is correct and fails when behavior is wrong.** Nothing else should affect it.

This sounds obvious, but most test suites violate it constantly:

```typescript
// This test is coupled to implementation
test('processes payment', () => {
  const spy = jest.spyOn(stripeClient, 'createCharge');

  processPayment({ amount: 5000 });

  expect(spy).toHaveBeenCalledWith({ amount: 5000 });
});
```

This test will break if you:
- Rename `createCharge` to `create`
- Switch from Stripe SDK to raw HTTP calls
- Add a payment abstraction layer
- Change the internal parameter format

None of these changes affect what the system **does** - they only change **how** it does it. Yet the test breaks.

**Scenarist tests behavior:**

```typescript
test('successful payment shows confirmation', async ({ page, switchScenario }) => {
  await switchScenario(page, 'paymentSucceeds');

  await page.goto('/checkout');
  await page.click('button[type="submit"]');

  await expect(page.getByText('Payment confirmed')).toBeVisible();
});
```

This test verifies: "When payment succeeds, user sees confirmation." It passes regardless of how your payment code is structured internally.

**The principle:** Mock at the boundary between your system and external services - the HTTP contract. Everything inside that boundary is your code, and it should run for real.

---

### 2. Real Execution Builds Confidence

Every line of code you mock is a line you're **not testing**.

When you mock extensively, you're testing your mocks - verifying that fake things behave the way you configured them to behave. This builds false confidence.

```typescript
// What are you actually testing here?
const mockAuth = jest.fn().mockReturnValue({ user: { id: 1, tier: 'premium' } });
const mockPricing = jest.fn().mockReturnValue({ discount: 0.2 });
const mockCart = jest.fn().mockImplementation((items, discount) =>
  items.reduce((sum, i) => sum + i.price, 0) * (1 - discount)
);

test('premium discount', () => {
  const result = calculateTotal(mockAuth, mockPricing, mockCart, items);
  expect(result).toBe(80);
});
```

If `mockCart` has a bug in its implementation, your test passes but production fails. You're testing your mock's arithmetic, not your system's.

**With Scenarist, your real code runs:**

- Your real authentication middleware
- Your real pricing logic
- Your real cart calculations
- Your real error handling
- Your real data validation

Only the external API responses are controlled. Everything else executes exactly as it would in production.

**The principle:** Maximize real execution. The gap between your test environment and production is where bugs hide.

---

### 3. Declarative Beats Imperative for Test Setup

Test scenarios should be **scannable**, not **traceable**.

When you look at a scenario, you should immediately understand what it does. You shouldn't need to step through code, trace execution paths, or debug your test setup.

**Imperative scenarios hide intent:**

```typescript
const scenario = (req, res) => {
  const user = getUserFromHeader(req);
  if (user?.tier === 'premium') {
    if (req.url.includes('/pricing')) {
      const basePrice = getBasePrice(req.body.product);
      const discount = calculatePremiumDiscount(user.history);
      return res.json({ price: basePrice * (1 - discount) });
    }
  }
  // ... 50 more lines
};
```

To understand this scenario, you must trace execution. What does `calculatePremiumDiscount` do? What's in `user.history`? You're debugging your test setup.

**Declarative scenarios reveal intent:**

```typescript
const scenario = {
  id: 'premiumUser',
  name: 'Premium User with Discount',
  mocks: [{
    method: 'GET',
    url: 'https://api.example.com/pricing',
    match: { headers: { 'x-user-tier': 'premium' } },
    response: { status: 200, body: { price: 80, discount: 0.2 } },
  }],
};
```

You can scan this and immediately understand: "Premium users get price 80 with 20% discount." No tracing required.

**The principle:** Scenarios are data, not code. Data is inspectable. Code is opaque.

---

### 4. Constraints Guide Better Design

Scenarist deliberately prevents you from writing functions in scenarios. This isn't a limitation - it's a feature.

When you can't write arbitrary code, you must find the right abstraction. This mirrors successful patterns across software:

| System | Constraint | What It Forces |
|--------|-----------|----------------|
| SQL | No procedural loops | Think in set operations |
| CSS | No programmatic positioning | Think in layout patterns |
| React | No imperative DOM updates | Think in component composition |
| **Scenarist** | **No functions in scenarios** | **Think in match/sequence/state patterns** |

Every time you're tempted to write `if (req.something)`, the constraint forces you to ask: "What pattern am I actually trying to express?"

Usually the answer is one of:
- **Match criteria** - Different responses based on request content
- **Sequences** - Ordered progression through states
- **State capture** - Values that flow between requests

These patterns are explicit, composable, and debuggable. The imperative code you wanted to write would have hidden the same logic in conditionals.

**The principle:** Constraints aren't limitations. They're guides toward better abstractions.

---

### 5. The Testing Pyramid Has a Missing Layer

The traditional testing pyramid assumes:
- **Unit tests** at the bottom (fast, isolated, many)
- **Integration tests** in the middle (slower, some dependencies)
- **E2E tests** at the top (slow, full system, few)

But modern frameworks break this model. Where does a Server Component fit?

- It's not a pure function (it fetches data)
- It's not a traditional "unit" (it depends on Next.js internals)
- It renders UI (so it's not just a service)
- But full E2E is too slow for comprehensive coverage

The same applies to middleware, route handlers, and server actions. They live in a gap the traditional pyramid doesn't address.

**Scenarist fills this gap:**

```
         /\
        /  \      E2E (few)
       /    \     Complete user journeys
      /------\
     /        \   Scenarist (many)
    /          \  HTTP-level behavior
   /            \ Real server execution
  /--------------\
       Unit       Pure functions
    (foundation)  Isolated logic
```

**The principle:** New paradigms need new testing approaches. Server-side rendering created a gap; Scenarist fills it.

---

### 6. Architecture Enables Testability

Testability isn't something you add to code. It's a property of well-designed systems.

Scenarist works because it operates at a natural boundary - the HTTP interface between your application and external services. This boundary exists whether you use Scenarist or not.

Good architecture has clear boundaries:
- Your code vs. external services
- Your domain logic vs. framework code
- Your business rules vs. infrastructure

When these boundaries are clear, testing becomes natural. You test your side of the boundary with the other side controlled.

**The principle:** If something is hard to test, the design might be the problem, not the testing approach.

---

## What Scenarist Is Not

Understanding the philosophy also means understanding what Scenarist deliberately doesn't do:

**Not a mocking library.** Mocking libraries let you fake anything. Scenarist only intercepts HTTP to external services. This constraint keeps you honest - your code runs for real.

**Not a unit testing tool.** Unit tests verify isolated functions. Scenarist verifies HTTP-level behavior with real server execution. Different tools for different purposes.

**Not a replacement for E2E tests.** E2E tests verify complete user journeys including visual rendering. Scenarist verifies server-side behavior. You need both.

**Not framework-specific.** The same scenarios work across Express, Next.js, and other frameworks. Your test definitions shouldn't be coupled to your framework choice.

---

## Practical Consequences

These beliefs have practical consequences for how you use Scenarist:

**Write scenarios that describe API behavior, not internal implementation.**
Good: "Stripe returns declined" â†’ Bad: "stripeClient.charges.create throws"

**Let your real code run. Don't mock your own modules.**
Scenarist mocks external APIs so your code can execute for real.

**Use declarative patterns even when imperative feels easier.**
Match criteria, sequences, and state capture cover most needs. If you're fighting the constraint, reconsider your approach.

**Test at the right level.**
Unit test pure logic. Scenarist test HTTP behavior. E2E test user journeys. Each layer has its purpose.

**Design for testability.**
If testing is painful, examine your architecture. Clear boundaries make testing natural.

---

## Influences

Scenarist's philosophy draws from established traditions:

**Test-Driven Development (Kent Beck)** - Tests verify behavior. Red-green-refactor. Tests as documentation.

**Behavior-Driven Development (Dan North)** - Describe behavior in domain terms. Scenarios over test cases.

**Hexagonal Architecture (Alistair Cockburn)** - Ports and adapters. Dependencies point inward. Framework independence.

**Functional Programming** - Data over functions. Composition over inheritance. Explicit over implicit.

**The Testing Pyramid (Mike Cohn)** - Different tests serve different purposes. Balance speed and confidence.

These aren't new ideas. Scenarist applies them to the specific challenge of testing modern server-side code.

---

## Summary

1. **Behavior over implementation** - Test what the system does, not how
2. **Real execution over mocking** - Your code should run for real
3. **Declarative over imperative** - Scenarios are data, not code
4. **Constraints over freedom** - Limitations guide better design
5. **Fill the gap** - Server-side code needs HTTP-level testing
6. **Architecture matters** - Testability comes from good design

These beliefs guide every decision in Scenarist. When you understand them, the tool makes sense. When you share them, the tool fits naturally into how you work.
