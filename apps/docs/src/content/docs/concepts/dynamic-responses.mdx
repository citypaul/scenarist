---
title: Dynamic Responses
description: Request matching, sequences, and stateful mocks for realistic test scenarios
---

:::tip[Syntax Reference]
This page explains **what Scenarist can do**. For syntax reference, see [Scenario Format Reference â†’](/concepts/scenario-format).
:::

Scenarist supports three types of dynamic responses for realistic test scenarios. These capabilities work together to simulate complex external API behaviors.

## Request Content Matching

Return different responses based on request content. Multiple mocks can exist for the same URL, and Scenarist selects the most specific match based on the actual request.

### Matching Criteria

Match on request body, headers, or query parameters:

```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'POST',
  url: '/api/checkout',
  match: {
    body: { tier: 'premium' },
    headers: { 'x-api-version': 'v2' },
    query: { detailed: 'true' }
  },
  response: { status: 200, body: { discount: 20 } }
};
```

### Specificity-Based Selection

When multiple mocks match the same URL, Scenarist uses specificity scoring:

- Mocks with match criteria are more specific than mocks without
- Among mocks with criteria, more fields = higher specificity
- Ties are broken by position (first wins)

**Example:**

```typescript
import type { ScenaristScenario } from '@scenarist/express-adapter';

const premiumScenario: ScenaristScenario = {
  id: 'premium',
  mocks: [
    // Specificity: 2 (body.tier + body.category)
    {
      method: 'POST',
      url: '/api/products',
      match: {
        body: { tier: 'premium', category: 'electronics' }
      },
      response: { status: 200, body: { discount: 30 } }
    },
    // Specificity: 1 (body.tier only)
    {
      method: 'POST',
      url: '/api/products',
      match: {
        body: { tier: 'premium' }
      },
      response: { status: 200, body: { discount: 20 } }
    },
    // Specificity: 0 (no match criteria, fallback)
    {
      method: 'POST',
      url: '/api/products',
      response: { status: 200, body: { discount: 10 } }
    }
  ]
};

// Request with tier='premium' and category='electronics'
// â†’ Returns 30% discount (specificity 2 wins)

// Request with tier='premium' only
// â†’ Returns 20% discount (specificity 1 wins)

// Request with neither
// â†’ Returns 10% discount (fallback)
```

### Partial Body Matching

Body matching is **partial** - only the specified fields must match:

```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'POST',
  url: '/api/create-order',
  match: {
    body: { itemType: 'premium' }  // Only checks itemType field
  },
  response: { status: 201, body: { orderId: 'premium-order-123' } }
};

// Matches requests with itemType='premium', regardless of other fields:
// { itemType: 'premium', quantity: 5, color: 'red' } âœ“
// { itemType: 'premium' } âœ“
// { itemType: 'standard' } âœ—
```

### Header and Query Matching

Header and query parameter matching is **exact** for specified keys:

```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'GET',
  url: '/api/data',
  match: {
    headers: { 'x-tier': 'premium' },  // Exact match
    query: { format: 'json' }          // Exact match
  },
  response: { status: 200, body: { detailed: true } }
};
```

### Combining Multiple Match Criteria with Different Strategies

You can combine multiple match criteria across body, headers, and query parameters, with **each field using a different matching strategy**. ALL criteria must match (AND logic) for the mock to be selected.

**Example with mixed strategies:**

```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'POST',
  url: '/api/checkout',
  match: {
    // Body: Different strategy per field
    body: {
      itemType: { contains: 'premium' },        // Contains substring
      category: { startsWith: 'electronics' }   // Starts with prefix
    },
    // Headers: Mix of exact, regex, and pattern matching
    headers: {
      'x-user-tier': { equals: 'gold' },        // Exact match
      'x-campaign': { regex: { source: 'summer|winter', flags: 'i' } },  // Regex
      'referer': { endsWith: '/checkout' }      // Ends with suffix
    },
    // Query: Plain string and pattern matching
    query: {
      region: 'us',                             // Plain string (exact)
      email: { contains: '@company.com' }       // Contains substring
    }
  },
  response: { status: 200, body: { discount: 30 } }
};
```

**This mock matches ONLY if ALL of the following are true:**
- âœ… `body.itemType` contains 'premium' (e.g., 'premium-item', 'super-premium')
- âœ… `body.category` starts with 'electronics' (e.g., 'electronics-phones')
- âœ… `x-user-tier` header exactly equals 'gold'
- âœ… `x-campaign` header matches 'summer' OR 'winter' (case-insensitive)
- âœ… `referer` header ends with '/checkout'
- âœ… `region` query param exactly equals 'us'
- âœ… `email` query param contains '@company.com'

**AND Logic:** All criteria must match. If ANY criterion fails, the mock is not selected.

**Specificity Calculation:** Each matched field adds to the specificity score:
- 2 body fields + 3 headers + 2 query params = **specificity of 7**
- Higher specificity = more specific mock wins

**OR Logic via Separate Mocks:**

Since match criteria use AND logic, implement OR logic by creating multiple mocks:

```typescript
import type { ScenaristScenario } from '@scenarist/express-adapter';

const scenario: ScenaristScenario = {
  id: 'premium-or-vip',
  mocks: [
    // Mock 1: Premium users
    {
      method: 'GET',
      url: '/api/products',
      match: { headers: { 'x-tier': 'premium' } },
      response: { status: 200, body: { pricing: 'discounted' } }
    },
    // Mock 2: VIP users (OR - separate mock)
    {
      method: 'GET',
      url: '/api/products',
      match: { headers: { 'x-tier': 'vip' } },
      response: { status: 200, body: { pricing: 'discounted' } }
    },
    // Fallback: Standard users
    {
      method: 'GET',
      url: '/api/products',
      response: { status: 200, body: { pricing: 'standard' } }
    }
  ]
};
```

**OR Logic via Regex:**

For true OR logic within a single field, use regex patterns:

```typescript
match: {
  headers: {
    'x-tier': { regex: { source: '^(premium|vip|enterprise)$', flags: '' } }
  }
}
// Matches x-tier='premium' OR 'vip' OR 'enterprise' in one mock
```

### Pattern Matching with Regex

For flexible pattern matching, use regex instead of exact values. This is useful for marketing campaigns, user agents, referer patterns, or any dynamic string matching.

#### Matching Strategies Reference

Scenarist provides **6 matching strategies** that work across request body fields, headers, and query parameters:

| Strategy | Syntax | Behavior | Use Case |
|----------|--------|----------|----------|
| **Plain String** | `'value'` | Exact match (backward compatible) | Simple exact matching |
| **Equals** | `{ equals: 'value' }` | Explicit exact match | Same as plain string, more explicit |
| **Contains** | `{ contains: 'substring' }` | Value contains substring | Partial matching (emails, campaigns) |
| **Starts With** | `{ startsWith: 'prefix' }` | Value starts with prefix | API keys, URL paths, prefixes |
| **Ends With** | `{ endsWith: 'suffix' }` | Value ends with suffix | File extensions, email domains |
| **Regex** | `{ regex: { source: 'pattern', flags: 'i' } }` | Pattern matching with flags | Complex patterns, alternatives |

**Where These Strategies Apply:**

- âœ… **Request Body Fields** (`match.body`) - All 6 strategies supported
- âœ… **Request Headers** (`match.headers`) - All 6 strategies supported
- âœ… **Query Parameters** (`match.query`) - All 6 strategies supported
- ðŸ”œ **URL Field** (`match.url`) - **Coming in Phase 2.5** ([#99](https://github.com/citypaul/scenarist/issues/99))

:::note[URL Matching Coming Soon]
URL matching with all MatchValue strategies is planned for Phase 2.5. Currently, the `url` field supports exact string matching, path parameters (`:id`), and glob patterns (`*`) for routing purposes.

For now, use query parameter matching for dynamic URL filtering:
```typescript
// Current approach - Use query parameters
url: '/api/users',
match: {
  query: { userId: { startsWith: 'usr_' } }
}

// Phase 2.5 - URL matching will support (future)
url: '/api/*',
match: {
  url: { contains: '/users/' }  // Coming soon!
}
```

**Phase 2 (Current):** String matching for headers, query params, and body fields
**Phase 2.5 (Planned):** URL matching with all strategies + route param combinations

See [Issue #99](https://github.com/citypaul/scenarist/issues/99) for details.
:::

#### Strategy Examples by Location

**Headers:**
```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'GET',
  url: '/api/products',
  match: {
    headers: {
      'x-api-version': 'v2',                              // Plain string (exact)
      'x-tier': { equals: 'premium' },                    // Explicit exact
      'user-agent': { contains: 'Mobile' },               // Contains
      'referer': { startsWith: 'https://example.com' },   // Starts with
      'accept': { endsWith: 'json' },                     // Ends with
      'x-campaign': { regex: { source: 'premium|vip', flags: 'i' } }  // Regex
    }
  },
  response: { status: 200, body: { matched: true } }
};
```

**Query Parameters:**
```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'GET',
  url: '/api/search',
  match: {
    query: {
      format: 'json',                                     // Plain string (exact)
      tier: { equals: 'premium' },                        // Explicit exact
      email: { contains: '@company.com' },                // Contains
      userId: { startsWith: 'usr_' },                     // Starts with
      file: { endsWith: '.pdf' },                         // Ends with
      category: { regex: { source: '^(tech|science)$', flags: 'i' } }  // Regex
    }
  },
  response: { status: 200, body: { matched: true } }
};
```

**Body Fields:**
```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'POST',
  url: '/api/process',
  match: {
    body: {
      action: 'create',                                   // Plain string (exact)
      status: { equals: 'active' },                       // Explicit exact
      email: { contains: '@example.com' },                // Contains
      apiKey: { startsWith: 'sk_' },                      // Starts with
      filename: { endsWith: '.json' },                    // Ends with
      version: { regex: { source: '^\\d+\\.\\d+\\.\\d+$', flags: '' } }  // Regex (semver)
    }
  },
  response: { status: 200, body: { processed: true } }
};
```

#### Regex Examples

**Marketing Campaigns:**

```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'GET',
  url: '/api/products',
  match: {
    headers: {
      'x-campaign': {
        regex: { source: 'premium|vip|exclusive', flags: 'i' }
      }
    }
  },
  response: {
    status: 200,
    body: { pricing: 'premium', discount: 25 }
  }
};

// Matches:
// x-campaign: 'summer-premium-sale' âœ“
// x-campaign: 'early-VIP-access' âœ“ (case-insensitive)
// x-campaign: 'exclusive-members-2024' âœ“
// x-campaign: 'standard-sale' âœ— (falls back to default)
```

**Referer Patterns:**

```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'POST',
  url: '/api/checkout',
  match: {
    headers: {
      'referer': {
        regex: { source: '/checkout/(confirm|review)', flags: '' }
      }
    }
  },
  response: { status: 200, body: { allowCheckout: true } }
};

// Matches:
// referer: 'https://example.com/checkout/confirm' âœ“
// referer: 'https://example.com/checkout/review' âœ“
// referer: 'https://example.com/checkout/cart' âœ—
```

**User Agent Detection:**

```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'GET',
  url: '/api/config',
  match: {
    headers: {
      'user-agent': {
        regex: { source: '(iPhone|iPad|Android)', flags: 'i' }
      }
    }
  },
  response: {
    status: 200,
    body: { layout: 'mobile', features: ['touch', 'swipe'] }
  }
};
```

#### Supported Regex Flags

Scenarist supports all standard JavaScript regex flags:

- `i` - **Case-insensitive matching** (most common)
- `m` - **Multiline mode** (^ and $ match line boundaries)
- `s` - **Dotall mode** (. matches newlines)
- `u` - **Unicode mode** (enables Unicode features)
- `v` - **Unicode sets mode** (enhanced Unicode support)
- `g` - **Global matching** (allowed but has no effect in Scenarist)
- `y` - **Sticky matching** (allowed but has no effect in Scenarist)

**Examples:**

```typescript
// Case-insensitive campaign matching
{ regex: { source: 'premium|vip', flags: 'i' } }

// Multiline referer matching
{ regex: { source: '^/checkout', flags: 'm' } }

// Unicode emoji detection
{ regex: { source: '[ðŸ˜€-ðŸ˜¿]', flags: 'u' } }

// Multiple flags combined
{ regex: { source: '/api/v\\d+/', flags: 'im' } }
```

#### Security: ReDoS Protection

Scenarist validates all regex patterns for **ReDoS (Regular Expression Denial of Service)** vulnerabilities:

```typescript
// âœ… SAFE - Simple alternation
{ regex: { source: 'premium|vip', flags: 'i' } }

// âœ… SAFE - Character classes
{ regex: { source: '[A-Z]{3}-\\d{4}', flags: '' } }

// âŒ REJECTED - Catastrophic backtracking risk
{ regex: { source: '(a+)+b', flags: '' } }
// Error: Regex pattern may cause ReDoS attack
```

**Protection mechanisms:**
- Pattern validation using `redos-detector` before scenario registration
- Unsafe patterns rejected immediately with clear error messages
- No runtime regex compilation for invalid patterns

#### Regex in Different Locations

Regex patterns work identically in headers, query parameters, and body fields:

**Headers:**
```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'GET',
  url: '/api/products',
  match: {
    headers: {
      'user-agent': {
        regex: { source: '(Chrome|Firefox|Safari)/', flags: 'i' }
      }
    }
  },
  response: { status: 200, body: { browser: 'supported' } }
};
```

**Query Parameters:**
```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'GET',
  url: '/api/search',
  match: {
    query: {
      email: {
        regex: { source: '@(gmail|yahoo|outlook)\\.com$', flags: 'i' }
      }
    }
  },
  response: { status: 200, body: { provider: 'common-email' } }
};

// Matches:
// /api/search?email=user@gmail.com âœ“
// /api/search?email=user@YAHOO.com âœ“ (case-insensitive)
// /api/search?email=user@hotmail.com âœ— (not in pattern)
```

**Body Fields:**
```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'POST',
  url: '/api/upload',
  match: {
    body: {
      filename: {
        regex: { source: '\\.(jpg|png|gif|webp)$', flags: 'i' }
      }
    }
  },
  response: { status: 200, body: { type: 'image', accepted: true } }
};

// Matches:
// { filename: 'photo.jpg' } âœ“
// { filename: 'avatar.PNG' } âœ“ (case-insensitive)
// { filename: 'document.pdf' } âœ— (not an image)
```

#### When to Use Regex

**Use regex when:**
- Matching campaign codes with variable formats
- Detecting mobile vs desktop user agents
- Validating referer patterns (checkout flows, auth redirects)
- Matching version patterns (`v1.2.3`, `2024-01-15`)

**Use exact/contains when:**
- Simple substring matching is sufficient
- Performance is critical (regex is slower)
- Pattern is known exactly

[Learn more about scenario format â†’](/concepts/scenario-format)

## Response Sequences

Simulate multi-step processes like polling, where each request advances through a sequence of responses.

### Basic Sequence

```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'GET',
  url: '/api/job/status',
  sequence: {
    responses: [
      { status: 200, body: { status: 'pending' } },
      { status: 200, body: { status: 'processing' } },
      { status: 200, body: { status: 'complete' } }
    ],
    repeat: 'last'  // Options: 'last' | 'cycle' | 'none'
  }
};
```

**Behavior:**
1. First request â†’ returns 'pending'
2. Second request â†’ returns 'processing'
3. Third request â†’ returns 'complete'
4. Fourth+ requests â†’ returns 'complete' (repeats last)

### Repeat Modes

**`repeat: 'last'`** - Repeat the last response indefinitely (most common)

```typescript
sequence: {
  responses: [
    { status: 200, body: { status: 'pending' } },
    { status: 200, body: { status: 'complete' } }
  ],
  repeat: 'last'
}
// Request 1: pending
// Request 2: complete
// Request 3+: complete (keeps repeating)
```

**`repeat: 'cycle'`** - Loop back to the beginning

```typescript
sequence: {
  responses: [
    { status: 200, body: { weather: 'sunny' } },
    { status: 200, body: { weather: 'cloudy' } },
    { status: 200, body: { weather: 'rainy' } }
  ],
  repeat: 'cycle'
}
// Request 1: sunny
// Request 2: cloudy
// Request 3: rainy
// Request 4: sunny (cycles back)
// Request 5: cloudy
```

**`repeat: 'none'`** - After sequence exhausts, fall through to next mock

```typescript
import type { ScenaristScenario } from '@scenarist/express-adapter';

const scenario: ScenaristScenario = {
  id: 'payment-sequence',
  mocks: [
    {
      method: 'POST',
      url: '/api/payment',
      sequence: {
        responses: [
          { status: 200, body: { id: 'ch_1', status: 'pending' } },
          { status: 200, body: { id: 'ch_2', status: 'pending' } },
          { status: 200, body: { id: 'ch_3', status: 'succeeded' } }
        ],
        repeat: 'none'  // After 3rd request, sequence exhausted
      }
    },
    {
      method: 'POST',
      url: '/api/payment',
      response: { status: 429, body: { error: 'Rate limit exceeded' } }
    }
  ]
};
// Request 1-3: Sequence responses
// Request 4+: Rate limit error (sequence exhausted, falls through to next mock)
```

### Combining Sequences with Matching

Sequences can be combined with match criteria:

```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'GET',
  url: '/api/onboarding/step',
  match: {
    headers: { 'x-tier': 'premium' }
  },
  sequence: {
    responses: [
      { status: 200, body: { step: 1, message: 'Welcome!' } },
      { status: 200, body: { step: 2, message: 'Configure...' } },
      { status: 200, body: { step: 3, message: 'Complete!' } }
    ],
    repeat: 'last'
  }
};
```

**Important:** Only matching requests advance the sequence. Non-matching requests don't affect sequence position.

## Stateful Mocks

Capture data from requests and inject it into subsequent responses, enabling stateful scenarios like shopping carts.

**State is isolated per test ID.** Each parallel test maintains its own stateâ€”one test's captured cart items never leak into another test's responses. This isolation is automatic via the test ID header.

### Basic State Capture and Injection

```typescript
import type { ScenaristScenario } from '@scenarist/express-adapter';

const scenario: ScenaristScenario = {
  id: 'cart-state',
  mocks: [
    // Capture state from POST request
    {
      method: 'POST',
      url: '/api/cart/add',
      captureState: {
        cartItems: { from: 'body', path: 'productId' }
      },
      response: { status: 201 }
    },
    // Inject state into GET response
    {
      method: 'GET',
      url: '/api/cart',
      response: {
        status: 200,
        body: {
          items: '{{state.cartItems}}'
        }
      }
    }
  ]
};
```

**How it works:**

1. POST to `/api/cart/add` with body `{ productId: 'prod-1' }`
2. Scenarist captures `productId` value and stores as `cartItems`
3. GET to `/api/cart` returns `{ items: 'prod-1' }`

### Array Append Syntax

Use `stateKey[]` to append values to an array:

```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'POST',
  url: '/api/cart/add',
  captureState: {
    'cartItems[]': { from: 'body', path: 'productId' }  // Note the [] suffix
  },
  response: { status: 201 }
};
```

**Behavior:**

```typescript
// Request 1: { productId: 'prod-1' }
// State: { cartItems: ['prod-1'] }

// Request 2: { productId: 'prod-2' }
// State: { cartItems: ['prod-1', 'prod-2'] }

// Request 3: { productId: 'prod-3' }
// State: { cartItems: ['prod-1', 'prod-2', 'prod-3'] }
```

### Nested Path Support

Capture deeply nested values using dot notation:

```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'POST',
  url: '/api/profile/update',
  captureState: {
    userName: { from: 'body', path: 'user.profile.name' }
  },
  response: { status: 200 }
};

// Request body:
// {
//   user: {
//     profile: {
//       name: 'John Doe',
//       email: 'john@example.com'
//     }
//   }
// }

// Captured: userName = 'John Doe'
```

### Template Replacement

Use `{{state.key}}` syntax to inject captured state into responses:

```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'GET',
  url: '/api/profile',
  response: {
    status: 200,
    body: {
      username: '{{state.userName}}',
      items: '{{state.cartItems}}',
      itemCount: '{{state.cartItems.length}}'  // Can access array length
    }
  }
};
```

### State Isolation Per Test ID

State is isolated per test ID, ensuring parallel tests don't interfere:

```typescript
// Test 1 (test-id: abc-123)
POST /api/cart/add { productId: 'prod-1' }
GET /api/cart  // Returns { items: ['prod-1'] }

// Test 2 (test-id: xyz-789) - runs simultaneously
POST /api/cart/add { productId: 'prod-999' }
GET /api/cart  // Returns { items: ['prod-999'] }

// No interference - each test has isolated state
```

### State Reset on Scenario Switch

When a test switches scenarios, all state for that test ID is cleared:

```typescript
test('cart workflow', async ({ page, switchScenario }) => {
  await switchScenario(page, 'cart-scenario');

  // Add items...
  await fetch('/api/cart/add', { body: { productId: 'prod-1' } });

  // Switch to different scenario
  await switchScenario(page, 'different-scenario');

  // State is cleared when switching - cart is now empty
});
```

## Combining All Three Capabilities

The power comes from combining request matching, sequences, and state together:

```typescript
import type { ScenaristScenario } from '@scenarist/express-adapter';

const scenario: ScenaristScenario = {
  id: 'premium-onboarding',
  mocks: [
    // Match premium users, advance through onboarding sequence, capture profile
    {
      method: 'POST',
      url: '/api/onboarding',
      match: {
        headers: { 'x-tier': 'premium' }
      },
      sequence: {
        responses: [
          { status: 200, body: { step: 1, message: 'Welcome premium user!' } },
          { status: 200, body: { step: 2, message: 'Set up your profile' } },
          { status: 200, body: { step: 3, message: 'You are all set!' } }
        ],
        repeat: 'last'
      },
      captureState: {
        'completedSteps[]': { from: 'body', path: 'stepNumber' }
      }
    },
    // Use captured state in dashboard
    {
      method: 'GET',
      url: '/api/dashboard',
      response: {
        status: 200,
        body: {
          completedSteps: '{{state.completedSteps}}',
          onboardingComplete: '{{state.completedSteps.length >= 3}}'
        }
      }
    }
  ]
};
```

**This enables:**
- Request with premium header triggers premium onboarding sequence
- Each step is captured in state
- Dashboard shows progress based on captured steps
- All isolated per test ID for parallel execution

## Next Steps

- [Scenario Format Reference â†’](/concepts/scenario-format) - Complete schema and syntax
- [Philosophy â†’](/concepts/philosophy) - Core beliefs behind Scenarist's design
- [Example Apps â†’](/frameworks/express/example-app) - See capabilities in action
- [Framework Guides â†’](/frameworks/nextjs-app-router/getting-started) - Start building tests
