---
title: Request Content Matching
description: Return different responses based on request body, headers, or query parameters
---

Return different responses based on request content. Multiple mocks can exist for the same URL, and Scenarist selects the most specific match based on the actual request.

## Matching Criteria

Match on request body, headers, or query parameters:

```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'POST',
  url: '/api/checkout',
  match: {
    body: { tier: 'premium' },
    headers: { 'x-api-version': 'v2' },
    query: { detailed: 'true' }
  },
  response: { status: 200, body: { discount: 20 } }
};
```

## Specificity-Based Selection

When multiple mocks match the same URL, Scenarist uses specificity scoring:

- Mocks with match criteria are more specific than mocks without
- Among mocks with criteria, more fields = higher specificity
- Ties are broken by position (first wins)

**Example:**

```typescript
import type { ScenaristScenario } from '@scenarist/express-adapter';

const premiumScenario: ScenaristScenario = {
  id: 'premium',
  mocks: [
    // Specificity: 2 (body.tier + body.category)
    {
      method: 'POST',
      url: '/api/products',
      match: {
        body: { tier: 'premium', category: 'electronics' }
      },
      response: { status: 200, body: { discount: 30 } }
    },
    // Specificity: 1 (body.tier only)
    {
      method: 'POST',
      url: '/api/products',
      match: {
        body: { tier: 'premium' }
      },
      response: { status: 200, body: { discount: 20 } }
    },
    // Specificity: 0 (no match criteria, fallback)
    {
      method: 'POST',
      url: '/api/products',
      response: { status: 200, body: { discount: 10 } }
    }
  ]
};

// Request with tier='premium' and category='electronics'
// ‚Üí Returns 30% discount (specificity 2 wins)

// Request with tier='premium' only
// ‚Üí Returns 20% discount (specificity 1 wins)

// Request with neither
// ‚Üí Returns 10% discount (fallback)
```

## Partial Body Matching

Body matching is **partial** - only the specified fields must match:

```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'POST',
  url: '/api/create-order',
  match: {
    body: { itemType: 'premium' }  // Only checks itemType field
  },
  response: { status: 201, body: { orderId: 'premium-order-123' } }
};

// Matches requests with itemType='premium', regardless of other fields:
// { itemType: 'premium', quantity: 5, color: 'red' } ‚úì
// { itemType: 'premium' } ‚úì
// { itemType: 'standard' } ‚úó
```

## Header and Query Matching

Header and query parameter matching is **exact** for specified keys:

```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'GET',
  url: '/api/data',
  match: {
    headers: { 'x-tier': 'premium' },  // Exact match
    query: { format: 'json' }          // Exact match
  },
  response: { status: 200, body: { detailed: true } }
};
```

## Combining Multiple Match Criteria

You can combine multiple match criteria across body, headers, and query parameters, with **each field using a different matching strategy**. ALL criteria must match (AND logic) for the mock to be selected.

**Example with mixed strategies:**

```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'POST',
  url: '/api/checkout',
  match: {
    // Body: Different strategy per field
    body: {
      itemType: { contains: 'premium' },        // Contains substring
      category: { startsWith: 'electronics' }   // Starts with prefix
    },
    // Headers: Mix of exact, regex, and pattern matching
    headers: {
      'x-user-tier': { equals: 'gold' },        // Exact match
      'x-campaign': { regex: { source: 'summer|winter', flags: 'i' } },  // Regex
      'referer': { endsWith: '/checkout' }      // Ends with suffix
    },
    // Query: Plain string and pattern matching
    query: {
      region: 'us',                             // Plain string (exact)
      email: { contains: '@company.com' }       // Contains substring
    }
  },
  response: { status: 200, body: { discount: 30 } }
};
```

**This mock matches ONLY if ALL of the following are true:**
- `body.itemType` contains 'premium' (e.g., 'premium-item', 'super-premium')
- `body.category` starts with 'electronics' (e.g., 'electronics-phones')
- `x-user-tier` header exactly equals 'gold'
- `x-campaign` header matches 'summer' OR 'winter' (case-insensitive)
- `referer` header ends with '/checkout'
- `region` query param exactly equals 'us'
- `email` query param contains '@company.com'

**AND Logic:** All criteria must match. If ANY criterion fails, the mock is not selected.

**Specificity Calculation:** Each matched field adds to the specificity score:
- 2 body fields + 3 headers + 2 query params = **specificity of 7**
- Higher specificity = more specific mock wins

## OR Logic

**OR Logic via Separate Mocks:**

Since match criteria use AND logic, implement OR logic by creating multiple mocks:

```typescript
import type { ScenaristScenario } from '@scenarist/express-adapter';

const scenario: ScenaristScenario = {
  id: 'premium-or-vip',
  mocks: [
    // Mock 1: Premium users
    {
      method: 'GET',
      url: '/api/products',
      match: { headers: { 'x-tier': 'premium' } },
      response: { status: 200, body: { pricing: 'discounted' } }
    },
    // Mock 2: VIP users (OR - separate mock)
    {
      method: 'GET',
      url: '/api/products',
      match: { headers: { 'x-tier': 'vip' } },
      response: { status: 200, body: { pricing: 'discounted' } }
    },
    // Fallback: Standard users
    {
      method: 'GET',
      url: '/api/products',
      response: { status: 200, body: { pricing: 'standard' } }
    }
  ]
};
```

**OR Logic via Regex:**

For true OR logic within a single field, use regex patterns:

```typescript
match: {
  headers: {
    'x-tier': { regex: { source: '^(premium|vip|enterprise)$', flags: '' } }
  }
}
// Matches x-tier='premium' OR 'vip' OR 'enterprise' in one mock
```

## Pattern Matching with Regex

For flexible pattern matching, use regex instead of exact values. This is useful for marketing campaigns, user agents, referer patterns, or any dynamic string matching.

### Matching Strategies Reference

Scenarist provides **6 matching strategies** that work across request body fields, headers, and query parameters:

| Strategy | Syntax | Behavior | Use Case |
|----------|--------|----------|----------|
| **Plain String** | `'value'` | Exact match (backward compatible) | Simple exact matching |
| **Equals** | `{ equals: 'value' }` | Explicit exact match | Same as plain string, more explicit |
| **Contains** | `{ contains: 'substring' }` | Value contains substring | Partial matching (emails, campaigns) |
| **Starts With** | `{ startsWith: 'prefix' }` | Value starts with prefix | API keys, URL paths, prefixes |
| **Ends With** | `{ endsWith: 'suffix' }` | Value ends with suffix | File extensions, email domains |
| **Regex** | `{ regex: { source: 'pattern', flags: 'i' } }` | Pattern matching with flags | Complex patterns, alternatives |

**Where These Strategies Apply:**

- **Request Body Fields** (`match.body`) - All 6 strategies supported
- **Request Headers** (`match.headers`) - All 6 strategies supported
- **Query Parameters** (`match.query`) - All 6 strategies supported

:::note[URL Matching Coming Soon]
URL matching with all MatchValue strategies is planned for Phase 2.5. Currently, the `url` field supports exact string matching, path parameters (`:id`), and glob patterns (`*`) for routing purposes.

For now, use query parameter matching for dynamic URL filtering:
```typescript
// Current approach - Use query parameters
url: '/api/users',
match: {
  query: { userId: { startsWith: 'usr_' } }
}

// Phase 2.5 - URL matching will support (future)
url: '/api/*',
match: {
  url: { contains: '/users/' }  // Coming soon!
}
```

See [Issue #99](https://github.com/citypaul/scenarist/issues/99) for details.
:::

### Strategy Examples by Location

**Headers:**
```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'GET',
  url: '/api/products',
  match: {
    headers: {
      'x-api-version': 'v2',                              // Plain string (exact)
      'x-tier': { equals: 'premium' },                    // Explicit exact
      'user-agent': { contains: 'Mobile' },               // Contains
      'referer': { startsWith: 'https://example.com' },   // Starts with
      'accept': { endsWith: 'json' },                     // Ends with
      'x-campaign': { regex: { source: 'premium|vip', flags: 'i' } }  // Regex
    }
  },
  response: { status: 200, body: { matched: true } }
};
```

**Query Parameters:**
```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'GET',
  url: '/api/search',
  match: {
    query: {
      format: 'json',                                     // Plain string (exact)
      tier: { equals: 'premium' },                        // Explicit exact
      email: { contains: '@company.com' },                // Contains
      userId: { startsWith: 'usr_' },                     // Starts with
      file: { endsWith: '.pdf' },                         // Ends with
      category: { regex: { source: '^(tech|science)$', flags: 'i' } }  // Regex
    }
  },
  response: { status: 200, body: { matched: true } }
};
```

**Body Fields:**
```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'POST',
  url: '/api/process',
  match: {
    body: {
      action: 'create',                                   // Plain string (exact)
      status: { equals: 'active' },                       // Explicit exact
      email: { contains: '@example.com' },                // Contains
      apiKey: { startsWith: 'sk_' },                      // Starts with
      filename: { endsWith: '.json' },                    // Ends with
      version: { regex: { source: '^\\d+\\.\\d+\\.\\d+$', flags: '' } }  // Regex (semver)
    }
  },
  response: { status: 200, body: { processed: true } }
};
```

### Regex Examples

**Marketing Campaigns:**

```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'GET',
  url: '/api/products',
  match: {
    headers: {
      'x-campaign': {
        regex: { source: 'premium|vip|exclusive', flags: 'i' }
      }
    }
  },
  response: {
    status: 200,
    body: { pricing: 'premium', discount: 25 }
  }
};

// Matches:
// x-campaign: 'summer-premium-sale' ‚úì
// x-campaign: 'early-VIP-access' ‚úì (case-insensitive)
// x-campaign: 'exclusive-members-2024' ‚úì
// x-campaign: 'standard-sale' ‚úó (falls back to default)
```

**Referer Patterns:**

```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'POST',
  url: '/api/checkout',
  match: {
    headers: {
      'referer': {
        regex: { source: '/checkout/(confirm|review)', flags: '' }
      }
    }
  },
  response: { status: 200, body: { allowCheckout: true } }
};

// Matches:
// referer: 'https://example.com/checkout/confirm' ‚úì
// referer: 'https://example.com/checkout/review' ‚úì
// referer: 'https://example.com/checkout/cart' ‚úó
```

**User Agent Detection:**

```typescript
import type { ScenaristMock } from '@scenarist/express-adapter';

const mock: ScenaristMock = {
  method: 'GET',
  url: '/api/config',
  match: {
    headers: {
      'user-agent': {
        regex: { source: '(iPhone|iPad|Android)', flags: 'i' }
      }
    }
  },
  response: {
    status: 200,
    body: { layout: 'mobile', features: ['touch', 'swipe'] }
  }
};
```

### Supported Regex Flags

Scenarist supports all standard JavaScript regex flags:

- `i` - **Case-insensitive matching** (most common)
- `m` - **Multiline mode** (^ and $ match line boundaries)
- `s` - **Dotall mode** (. matches newlines)
- `u` - **Unicode mode** (enables Unicode features)
- `v` - **Unicode sets mode** (enhanced Unicode support)
- `g` - **Global matching** (allowed but has no effect in Scenarist)
- `y` - **Sticky matching** (allowed but has no effect in Scenarist)

**Examples:**

```typescript
// Case-insensitive campaign matching
{ regex: { source: 'premium|vip', flags: 'i' } }

// Multiline referer matching
{ regex: { source: '^/checkout', flags: 'm' } }

// Unicode emoji detection
{ regex: { source: '[üòÄ-üòø]', flags: 'u' } }

// Multiple flags combined
{ regex: { source: '/api/v\\d+/', flags: 'im' } }
```

### Security: ReDoS Protection

Scenarist validates all regex patterns for **ReDoS (Regular Expression Denial of Service)** vulnerabilities:

```typescript
// ‚úÖ SAFE - Simple alternation
{ regex: { source: 'premium|vip', flags: 'i' } }

// ‚úÖ SAFE - Character classes
{ regex: { source: '[A-Z]{3}-\\d{4}', flags: '' } }

// ‚ùå REJECTED - Catastrophic backtracking risk
{ regex: { source: '(a+)+b', flags: '' } }
// Error: Regex pattern may cause ReDoS attack
```

**Protection mechanisms:**
- Pattern validation using `redos-detector` before scenario registration
- Unsafe patterns rejected immediately with clear error messages
- No runtime regex compilation for invalid patterns

## When to Use Regex

**Use regex when:**
- Matching campaign codes with variable formats
- Detecting mobile vs desktop user agents
- Validating referer patterns (checkout flows, auth redirects)
- Matching version patterns (`v1.2.3`, `2024-01-15`)

**Use exact/contains when:**
- Simple substring matching is sufficient
- Performance is critical (regex is slower)
- Pattern is known exactly

## Next Steps

- [Response Sequences ‚Üí](/concepts/dynamic-responses/sequences) - Multi-step processes
- [Stateful Mocks ‚Üí](/concepts/dynamic-responses/stateful-mocks) - Capture and inject state
- [Scenario Format Reference ‚Üí](/concepts/scenario-format) - Complete syntax
