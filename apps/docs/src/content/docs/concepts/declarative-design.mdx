---
title: Testing Philosophy
description: The principles behind Scenarist's approach to testing - behavior over implementation, real execution, and declarative patterns
---

import { Aside } from '@astrojs/starlight/components';

Scenarist is built on established testing principles that prioritize **behavior over implementation**, **real execution over mocking**, and **declarative patterns over imperative procedures**. Understanding these principles helps you write better tests.

## Test Behavior, Not Implementation

The most important principle in testing: **verify what your code does, not how it does it**.

### What This Means

**Implementation-focused tests** are brittle because they break when you refactor:

```typescript
// ❌ IMPLEMENTATION-FOCUSED - Tests HOW, not WHAT
test('calls stripe.charges.create with correct params', () => {
  const spy = jest.spyOn(stripe.charges, 'create');

  processPayment({ amount: 5000, currency: 'gbp' });

  expect(spy).toHaveBeenCalledWith({
    amount: 5000,
    currency: 'gbp',
  });
});
```

This test breaks if you:
- Rename the internal function
- Change to a different Stripe SDK method
- Add a wrapper layer
- Refactor the payment flow

**Behavior-focused tests** verify outcomes:

```typescript
// ✅ BEHAVIOR-FOCUSED - Tests WHAT, not HOW
test('successful payment shows confirmation', async ({ page, switchScenario }) => {
  await switchScenario(page, 'paymentSucceeds');

  await page.goto('/checkout');
  await page.fill('[name="amount"]', '50.00');
  await page.click('button[type="submit"]');

  await expect(page.getByText('Payment confirmed')).toBeVisible();
});
```

This test passes regardless of:
- Which Stripe SDK method you use internally
- How your payment service is structured
- Whether you add caching, retries, or other internal changes

**The behavior stays the same even when implementation changes.**

### Why Scenarist Enables This

Traditional mocking requires you to know implementation details:

```typescript
// You must know the exact internal call to mock it
jest.mock('./stripe-client', () => ({
  charges: {
    create: jest.fn().mockResolvedValue({ status: 'succeeded' }),
  },
}));
```

Scenarist mocks at the HTTP boundary - **the contract between your app and external services**:

```typescript
// You only need to know the API contract, not your internal implementation
{
  method: 'POST',
  url: 'https://api.stripe.com/v1/charges',
  response: {
    status: 200,
    body: { id: 'ch_123', status: 'succeeded' },
  },
}
```

Your internal code can change freely. As long as it makes the same HTTP request to Stripe, the test passes.

## Real Execution Over Mocking

The more you mock, the less you're actually testing. Scenarist minimizes mocking to maximize confidence.

### The Mocking Spectrum

| Approach | What's Real | What's Mocked | Confidence |
|----------|-------------|---------------|------------|
| Unit tests | Function logic | Everything else | Low |
| Integration tests | Multiple modules | External APIs, DB | Medium |
| **Scenarist** | **Everything except external APIs** | **Only HTTP responses** | **High** |
| E2E tests | Everything | Nothing | Highest (but slow) |

### What "Real Execution" Means

With Scenarist, your actual code runs:

```
Browser Request
    ↓
Your Real Middleware (auth, logging, rate limiting)
    ↓
Your Real Route Handler
    ↓
Your Real Business Logic
    ↓
Your Real Data Validation
    ↓
External API Call ← Only this is mocked
    ↓
Your Real Response Handling
    ↓
Your Real Error Handling
    ↓
Browser Response
```

**Everything in your codebase executes exactly as it would in production.** Only the external HTTP responses are controlled by scenarios.

### Why This Matters

Consider testing "premium users get 20% discount":

**With extensive mocking:**
```typescript
// You're testing your mock setup, not your code
const mockAuth = { user: { tier: 'premium' } };
const mockPricing = { getDiscount: () => 0.2 };
const mockCart = { calculateTotal: (items, discount) => items.total * (1 - discount) };

// If any mock is wrong, test passes but production fails
```

**With Scenarist:**
```typescript
// Your REAL auth middleware checks the session
// Your REAL pricing logic calculates discounts
// Your REAL cart service applies them
// Only the external "user tier" API response is mocked

await switchScenario(page, 'premiumUser');
await page.goto('/cart');
await expect(page.getByText('20% discount applied')).toBeVisible();
```

If your discount logic has a bug, the test fails - because the real code ran.

## The Testing Gap

Modern frameworks create code that doesn't fit traditional testing categories.

### Where Server-Side Code Falls

| Code Type | Unit Testable? | Why/Why Not |
|-----------|---------------|-------------|
| Pure functions | ✅ Yes | No dependencies |
| React components (client) | ✅ Yes | RTL renders them |
| **Server Components** | ❌ No | Return Promises, need server APIs |
| **Middleware** | ❌ Difficult | Needs request/response context |
| **Route Handlers** | ❌ Difficult | Needs framework internals |
| **Server Actions** | ❌ No | Tightly coupled to framework |

### The Problem with "Just Mock It"

You *can* unit test server-side code by mocking framework internals:

```typescript
// Mocking Next.js internals
jest.mock('next/headers', () => ({
  headers: () => new Map([['x-user-id', '123']]),
  cookies: () => ({ get: () => ({ value: 'session-token' }) }),
}));

jest.mock('next/cache', () => ({
  revalidatePath: jest.fn(),
}));

// Now test your Server Component...
```

**Problems:**
- You're testing against your *mock* of Next.js, not Next.js itself
- Mocks can diverge from real behavior
- Framework updates break mocks
- You're not testing the integration

### Scenarist's Approach

Instead of mocking framework internals, test through the framework:

```typescript
test('authenticated users see their data', async ({ page, switchScenario }) => {
  await switchScenario(page, 'authenticatedUser');

  // Real Next.js middleware runs
  // Real cookies() and headers() work
  // Real Server Component executes
  // Real data fetching happens (to mocked external API)

  await page.goto('/dashboard');
  await expect(page.getByText('Welcome, John')).toBeVisible();
});
```

**Your code runs in its real environment.** Only external API responses are controlled.

## Declarative Scenarios

Scenarist scenarios are **data structures**, not functions. This isn't arbitrary - it follows from testing principles.

### Why Not Functions?

Functions hide logic:

```typescript
// ❌ What does this test scenario actually do?
const premiumScenario = (req, res) => {
  if (req.headers['x-user-tier'] === 'premium') {
    if (req.url.includes('/pricing')) {
      return res.json({ discount: 0.2 });
    }
    // ... 50 more lines of conditionals
  }
};
```

To understand this scenario, you must **trace execution**. You're essentially debugging your test setup.

### Why Data Structures?

Data is inspectable:

```typescript
// ✅ Scenario intent is immediately visible
const premiumScenario = {
  id: 'premiumUser',
  name: 'Premium User',
  description: 'Premium tier with 20% discount',
  mocks: [
    {
      method: 'GET',
      url: 'https://api.example.com/pricing',
      match: { headers: { 'x-user-tier': 'premium' } },
      response: { status: 200, body: { discount: 0.2 } },
    },
  ],
};
```

You can **scan** this and understand it. No tracing required.

### The Constraint Enables Good Patterns

When you can't write functions, you discover better patterns:

| Imperative Temptation | Declarative Pattern | Why Better |
|----------------------|---------------------|------------|
| if/else on request content | Match criteria | Specificity-based, composable |
| Mutable counter for sequences | Sequence arrays | Explicit progression, inspectable |
| Global state for captured values | State capture/inject | Isolated per test, explicit flow |
| Referer routing hacks | Sequences | Reliable, not URL-dependent |

**The constraint guides you toward clearer test scenarios.**

## Confidence Through Composition

Scenarist's features compose to give you confidence at different levels.

### Testing Pyramid with Scenarist

```
         /\
        /  \      E2E Tests (few)
       /    \     - Complete user journeys
      /      \    - Visual verification
     /--------\
    /          \  Scenarist Tests (many)
   /            \ - Server-side behavior
  /              \- External API scenarios
 /                \- Parallel execution
/------------------\
    Unit Tests      - Pure functions
    (foundation)    - Isolated logic
```

**Scenarist fills the middle layer** - more confidence than unit tests, faster than E2E.

### What Each Layer Tests

| Layer | Tests | Speed | Confidence |
|-------|-------|-------|------------|
| Unit | Pure logic, calculations | Fast | Logic is correct |
| **Scenarist** | **HTTP behavior, scenarios** | **Fast** | **Integration works** |
| E2E | User journeys, visual | Slow | Everything works |

### Example: Payment Flow

**Unit tests:** Verify `calculateDiscount(0.2, 100)` returns `80`

**Scenarist tests:** Verify premium user checkout flow works with real middleware, real business logic, mocked Stripe

**E2E tests:** Verify the complete checkout journey looks correct in the browser

Each layer adds confidence. Scenarist gives you **high confidence with fast execution**.

## Principles Summary

1. **Test behavior, not implementation** - Verify outcomes, not internal calls
2. **Maximize real execution** - Mock only what you must (external APIs)
3. **Use declarative patterns** - Scenarios should be inspectable data, not hidden logic
4. **Fill the testing gap** - Server-side code needs HTTP-level testing
5. **Compose for confidence** - Unit + Scenarist + E2E covers the full spectrum

## Next Steps

- [Scenario Format →](/introduction/scenario-format) - Write effective declarative scenarios
- [Why Scenarist? →](/introduction/why-scenarist) - When to use this approach
- [Architecture →](/concepts/architecture) - How the system enables these principles
