---
title: Tool Comparison
description: How Scenarist compares to WireMock, Nock, Testcontainers, Playwright mocks, and how it builds on MSW
---

import { Card, CardGrid, LinkCard } from '@astrojs/starlight/components';

Choosing the right testing tool depends on your architecture, team, and what you're testing. This guide helps you understand where Scenarist fits and when other tools might be better suited.

## What Scenarist Offers

Scenarist is built on [MSW](https://mswjs.io/) and adds a complete scenario management layer designed for modern testing workflows:

<CardGrid>
  <Card title="Test ID Isolation" icon="random">
    Run hundreds of parallel tests with different scenarios against a single server. Each test gets isolated state via unique test IDs.
  </Card>
  <Card title="Runtime Switching" icon="forward">
    Change scenarios mid-test without restarts. Perfect for testing retry flows, error recovery, and multi-step user journeys.
  </Card>
  <Card title="First-Class Playwright" icon="seti:playwright">
    Dedicated fixtures with type-safe scenario switching and automatic test ID generation. Each test gets isolated state without manual header management.
  </Card>
  <Card title="Response Sequences" icon="list-format">
    Built-in support for polling APIs, retry flows, and state machines. Return different responses on successive calls.
  </Card>
  <Card title="Stateful Mocks" icon="seti:db">
    Capture values from requests and inject them into responses. Build realistic multi-step flows like shopping carts.
  </Card>
  <Card title="Advanced Matching" icon="magnifier">
    Match requests by body, headers, query params, and regex patterns. Specificity-based selection means no careful ordering required.
  </Card>
</CardGrid>

## Quick Comparison Matrix

| Feature | Scenarist | WireMock | Nock | Testcontainers | Playwright Mocks |
|---------|-----------|----------|------|----------------|------------------|
| **Test isolation** | Per-test via test ID | Per-server instance | Per-test setup | Per-container | Per-page |
| **Runtime switching** | Yes (API call) | Requires restart | No | No | No |
| **Server Components** | Full support | Yes | Partial | Yes | No |
| **Setup complexity** | npm install | Java/Docker | npm install | Docker required | Built-in |
| **Parallel tests** | Built-in isolation | Multiple instances | Manual | Per-container | Per-page |
| **Test framework** | First-class Playwright | Generic HTTP | Generic | Generic | Built-in |
| **Response sequences** | Built-in | Extension required | Manual | N/A | Manual |
| **Stateful mocks** | Built-in capture/inject | Extension required | Manual | N/A | Manual |
| **Language** | TypeScript/JS | Language-agnostic | JavaScript | Language-agnostic | JavaScript |

## Understanding the Categories

Testing tools fall into different categories based on how and where they intercept requests:

<CardGrid>
  <Card title="Network-Level Mocking" icon="seti:javascript">
    **Scenarist, Nock, MSW**

    Intercept HTTP requests within your Node.js process. No external services needed. Fast setup, TypeScript-native.
  </Card>
  <Card title="Server-Based Mocking" icon="seti:docker">
    **WireMock**

    Standalone mock server that receives real network traffic. Language-agnostic but requires separate process management.
  </Card>
  <Card title="Container-Based Testing" icon="seti:docker">
    **Testcontainers**

    Runs real services in Docker containers. Different purpose—testing against real databases and services, not mocking.
  </Card>
  <Card title="Browser-Level Mocking" icon="seti:html">
    **Playwright's `page.route()`**

    Intercepts requests in the browser via Playwright's built-in API. Perfect for SPAs, but cannot intercept server-side requests (Server Components, API routes).
  </Card>
</CardGrid>

## Built on MSW

Scenarist is built on top of [Mock Service Worker (MSW)](https://mswjs.io/)—the same battle-tested interception library used by thousands of projects. We don't replace MSW; we add a scenario management layer on top.

**What MSW provides:**
- Request interception at the network level
- Works with any HTTP client (fetch, axios, etc.)
- Proven reliability and active maintenance

**What Scenarist adds:**
- **Test ID isolation** — Parallel tests with different scenarios
- **Runtime switching** — Change scenarios without restart
- **First-class Playwright support** — Dedicated fixtures with type-safe scenario switching and automatic test ID isolation
- **Response sequences** — Built-in support for polling, retry flows, state machines
- **Stateful mocks** — Capture values from requests, inject into responses
- **Advanced matching** — Body, headers, query params, regex patterns
- **Framework adapters** — Express, Next.js integration out of the box

If you need low-level control or use MSW for non-testing purposes (API development, storybook), use MSW directly. If you need scenario management for testing, Scenarist handles that layer.

[Learn more about Scenarist + MSW →](/comparison/with-msw)

## When to Use What

### Choose Scenarist when...

- Testing **server-side code** (Server Components, API routes, middleware)
- Running **parallel tests** that need different external API states
- Wanting to **switch scenarios at runtime** without restarts
- Using **Playwright** and want first-class fixtures with type-safe scenario switching
- Need **response sequences** for polling APIs, retry flows, or state machines
- Need **stateful mocks** that capture request data and inject it into responses
- Working in **TypeScript/JavaScript** ecosystems
- Testing how your app handles various **external API scenarios** (errors, timeouts, edge cases)

### Choose WireMock when...

- Working in **non-JavaScript environments** (Java, Python, .NET)
- Need **recording/playback** of real API interactions
- Want a **standalone mock server** independent of your test process
- Team is already familiar with WireMock's ecosystem

[Compare: Scenarist vs WireMock →](/comparison/vs-wiremock)

### Choose Nock when...

- Writing **simple unit tests** with per-test mock setup
- Don't need **parallel test isolation**
- Prefer **lighter-weight** approach without framework adapters
- Already using Nock and don't need scenario management

[Compare: Scenarist vs Nock →](/comparison/vs-nock)

### Choose Testcontainers when...

- Testing against **real databases** (PostgreSQL, MongoDB)
- Need **actual service behavior**, not mocks
- Testing **infrastructure integration** (Redis, Kafka, Elasticsearch)
- Want **production-like** environment in tests

Testcontainers and Scenarist solve different problems—they're often complementary.

[Compare: Scenarist vs Testcontainers →](/comparison/vs-testcontainers)

### Choose Playwright's built-in `page.route()` when...

- Testing **client-side only** applications (SPAs)
- All HTTP calls originate from the **browser**
- Don't have **server-side rendering** or Server Components
- Want **zero additional dependencies** for simple browser-side mocking

Note: This refers to Playwright's native [`page.route()`](https://playwright.dev/docs/mock) API for browser-side request interception—not Scenarist's `@scenarist/playwright-helpers` package, which provides test fixtures for server-side scenario management.

[Compare: Scenarist vs Playwright Mocks →](/comparison/vs-playwright-mocks)

## Detailed Comparisons

<CardGrid>
  <LinkCard
    title="Scenarist + MSW"
    description="How Scenarist builds on MSW and when to use each"
    href="/comparison/with-msw"
  />
  <LinkCard
    title="vs WireMock"
    description="In-process vs server-based mocking approaches"
    href="/comparison/vs-wiremock"
  />
  <LinkCard
    title="vs Nock"
    description="Declarative scenarios vs imperative per-test setup"
    href="/comparison/vs-nock"
  />
  <LinkCard
    title="vs Testcontainers"
    description="Mocking external APIs vs running real services"
    href="/comparison/vs-testcontainers"
  />
  <LinkCard
    title="vs Playwright Mocks"
    description="Server-side vs browser-side request interception"
    href="/comparison/vs-playwright-mocks"
  />
</CardGrid>

## Making the Decision

Still not sure? Here's a decision tree:

**1. Are you testing server-side code (Server Components, API routes)?**
- Yes → Scenarist, WireMock, or Nock (not Playwright mocks)
- No (client-side only) → Playwright mocks may be sufficient

**2. Do you need parallel tests with different scenarios?**
- Yes → Scenarist (built-in isolation) or WireMock (multiple instances)
- No → Any tool works

**3. Do you need to switch scenarios during a test?**
- Yes → Scenarist (only tool with runtime switching)
- No → Any tool works

**4. Are you using Playwright for E2E testing?**
- Yes → Scenarist (first-class fixtures with type-safe scenarios and automatic test ID isolation)
- No → Any tool works

**5. Do you need response sequences or stateful mocks?**
- Yes → Scenarist (built-in) or WireMock (requires extensions)
- No → Any tool works

**6. Are you in a non-JavaScript environment?**
- Yes → WireMock
- No → Scenarist or Nock

**7. Do you need to test real database/service behavior?**
- Yes → Testcontainers (complements Scenarist for external APIs)
- No → Scenarist for mocked external APIs
