---
title: Tool Comparison
description: How Scenarist compares to WireMock, Nock, Testcontainers, Playwright mocks, and how it builds on MSW
---

import { Card, CardGrid, LinkCard } from '@astrojs/starlight/components';

Choosing the right testing tool depends on your architecture, team, and what you're testing. This guide helps you understand where Scenarist fits and when other tools might be better suited.

## What Scenarist Offers

Scenarist is built on [MSW](https://mswjs.io/) and adds a complete scenario management layer designed for modern testing workflows:

<CardGrid>
  <Card title="Simple Architecture" icon="rocket">
    Just an HTTP header. No Docker, no separate processes, no network proxies. Install, configure scenarios, test. <a href="/concepts/architecture">Learn more →</a>
  </Card>
  <Card title="Test ID Isolation" icon="random">
    Run hundreds of <a href="/testing/parallel-testing">parallel tests</a> with different scenarios against a single server. Each test's header routes to its own scenario.
  </Card>
  <Card title="Runtime Switching" icon="forward">
    Change scenarios mid-test without restarts. Perfect for testing retry flows, error recovery, and multi-step user journeys.
  </Card>
  <Card title="First-Class Playwright" icon="seti:playwright">
    Dedicated <a href="/testing/playwright-integration">fixtures</a> with type-safe scenario switching and automatic test ID handling. Each test gets isolated state without manual header management.
  </Card>
  <Card title="Response Sequences" icon="list-format">
    Ever tested a polling UI that shows pending → processing → complete? Most tools need complex state management. <a href="/concepts/dynamic-responses">Scenarist: three lines of config</a>.
  </Card>
  <Card title="Next.js Multi-Process (Solved)" icon="setting">
    Next.js has <a href="https://github.com/vercel/next.js/discussions/68572">documented singleton issues</a> that break MSW. Scenarist's adapter includes built-in <code>globalThis</code> guards—one stable MSW instance regardless of module loading.
  </Card>
</CardGrid>

### The Parallel Testing Advantage

Most mock tools require separate instances for parallel test isolation. Scenarist uses header-based routing instead:

```
┌─────────────────────────────────────────────────────────────────┐
│  Traditional approach: 10 parallel tests = 10 mock servers     │
│                                                                 │
│   Test 1 → WireMock:8081    Test 6 → WireMock:8086             │
│   Test 2 → WireMock:8082    Test 7 → WireMock:8087             │
│   Test 3 → WireMock:8083    Test 8 → WireMock:8088             │
│   Test 4 → WireMock:8084    Test 9 → WireMock:8089             │
│   Test 5 → WireMock:8085    Test 10 → WireMock:8090            │
├─────────────────────────────────────────────────────────────────┤
│  Scenarist: 10 parallel tests = 1 server, 10 headers           │
│                                                                 │
│   Test 1 ─┬─ x-scenarist-test-id: test-1 ─┬─→ scenario-a       │
│   Test 2 ─┤  x-scenarist-test-id: test-2 ─┤─→ scenario-b       │
│   ...     ├─────────► App Server ─────────┤   ...              │
│   Test 9 ─┤  x-scenarist-test-id: test-9 ─┤─→ scenario-a       │
│   Test 10─┴─ x-scenarist-test-id: test-10─┴─→ scenario-c       │
└─────────────────────────────────────────────────────────────────┘
```

**Result:** No container orchestration, no port allocation, no startup overhead. Tests run faster and CI stays simple.

## Quick Comparison Matrix

| Feature | Scenarist | WireMock | Nock | Testcontainers | Playwright Mocks |
|---------|-----------|----------|------|----------------|------------------|
| **Test isolation** | Per-test via header | Per-server instance | Per-test setup | Per-container | Per-page |
| **Runtime switching** | Yes (single API call) | Yes (Admin API) | No | No | No |
| **Server Components** | Full support | Yes (network proxy) | No (E2E) / Yes (integration) | Yes (with WireMock module) | No |
| **Setup complexity** | npm install | JAR/Docker/npm | npm install | Docker required | Built-in |
| **Parallel tests** | Built-in (header routing) | Multiple instances or scenarios | Scope/persist management | Per-container | Per-page |
| **Test framework** | First-class Playwright | Generic HTTP | Generic | Generic | Built-in |
| **Response sequences** | Built-in | Built-in (Scenarios) | Manual | Via mock server | Manual |
| **Stateful mocks** | Built-in capture/inject | Built-in state machine | Manual | Via mock server | Manual |
| **Language** | TypeScript/JS | Language-agnostic | JavaScript | Language-agnostic | JavaScript |

*Note: "Server Components" refers to E2E testing of React Server Components where requests originate on the server.*

## Understanding the Categories

Testing tools fall into different categories based on how and where they intercept requests:

<CardGrid>
  <Card title="Network-Level Mocking" icon="seti:javascript">
    **Scenarist, Nock, MSW**

    Intercept HTTP requests within your Node.js process. No external services needed. Fast setup, TypeScript-native.
  </Card>
  <Card title="Server-Based Mocking" icon="seti:docker">
    **WireMock**

    Standalone mock server that receives real network traffic. Language-agnostic but requires separate process management.
  </Card>
  <Card title="Container-Based Testing" icon="seti:docker">
    **Testcontainers**

    Runs real services in Docker containers. Different purpose—testing against real databases and services, not mocking.
  </Card>
  <Card title="Browser-Level Mocking" icon="seti:html">
    **Playwright's `page.route()`**

    Intercepts requests in the browser via Playwright's built-in API. Perfect for SPAs, but cannot intercept server-side requests (Server Components, API routes).
  </Card>
</CardGrid>

## Built on MSW

Scenarist is built on top of [Mock Service Worker (MSW)](https://mswjs.io/)—the same battle-tested interception library used by thousands of projects. We don't replace MSW; we add a scenario management layer on top.

**What MSW provides:**
- Request interception at the network level
- Works with any HTTP client (fetch, axios, etc.)
- Proven reliability and active maintenance

**What Scenarist adds:**
- **Test ID isolation** — Parallel tests with different scenarios
- **Runtime switching** — Change scenarios without restart
- **First-class Playwright support** — Dedicated fixtures with type-safe scenario switching and automatic test ID isolation
- **Response sequences** — Built-in support for polling, retry flows, state machines
- **Stateful mocks** — Capture values from requests, inject into responses (state isolated per test ID)
- **Advanced matching** — Body, headers, query params, regex patterns
- **Framework adapters** — Express, Next.js integration out of the box

If you need low-level control or use MSW for non-testing purposes (API development, storybook), use MSW directly. If you need scenario management for testing, Scenarist handles that layer.

[Learn more about Scenarist + MSW →](/comparison/with-msw)

## When to Use What

### Choose Scenarist when...

- Testing **server-side code** (Server Components, API routes, middleware)
- Running **parallel tests** that need different external API states
- Wanting to **switch scenarios at runtime** without restarts
- Using **Playwright** and want first-class fixtures with type-safe scenario switching
- Need **response sequences** for polling APIs, retry flows, or state machines
- Need **stateful mocks** that capture request data and inject it into responses
- Working in **TypeScript/JavaScript** ecosystems
- Testing how your app handles various **external API scenarios** (errors, timeouts, edge cases)

### When NOT to use Scenarist

Being explicit about when Scenarist isn't the right choice:

- **Pure client-side SPAs** — If all HTTP calls originate in the browser, [Playwright's built-in mocks](/comparison/vs-playwright-mocks) may be simpler
- **Java/Python/.NET shops** — WireMock's ecosystem is better suited for non-JavaScript teams
- **Need recording/playback** — Use Nock (nockBack) or WireMock if you need to capture real API responses
- **Simple unit tests without parallelism** — Nock is lighter-weight if you don't need scenario management
- **Database testing** — Scenarist mocks HTTP only. See [Testing Database Apps](/guides/testing-database-apps) for database strategies
- **Contract testing** — Use WireMock with Spring Cloud Contract or similar frameworks

### Choose WireMock when...

- Working in **non-JavaScript environments** (Java, Python, .NET)
- Need **recording/playback** of real API interactions
- Want a **standalone mock server** independent of your test process
- Team is already familiar with WireMock's ecosystem

[Compare: Scenarist vs WireMock →](/comparison/vs-wiremock)

### Choose Nock when...

- Writing **simple unit tests** with per-test mock setup
- Don't need **parallel test isolation**
- Prefer **lighter-weight** approach without framework adapters
- Already using Nock and don't need scenario management

[Compare: Scenarist vs Nock →](/comparison/vs-nock)

### Choose Testcontainers when...

- Testing against **real databases** (PostgreSQL, MongoDB)
- Need **actual service behavior**, not mocks
- Testing **infrastructure integration** (Redis, Kafka, Elasticsearch)
- Want **production-like** environment in tests

Testcontainers and Scenarist solve different problems—they're often **complementary**. Many teams use both: Testcontainers for databases, Scenarist for external HTTP APIs.

:::tip[Database Testing with Scenarist]
If your app uses databases, see our [Testing Database Apps](/guides/testing-database-apps) guide for comprehensive options including:
- **[Repository Pattern](/guides/testing-database-apps/repository-pattern)** — Test ID isolation for databases (our recommendation)
- **[Testcontainers Hybrid](/guides/testing-database-apps/testcontainers-hybrid)** — Use both tools together
- **[Parallelism Options](/guides/testing-database-apps/parallelism-options)** — Compare all approaches and trade-offs
:::

[Compare: Scenarist vs Testcontainers →](/comparison/vs-testcontainers)

### Choose Playwright's built-in `page.route()` when...

- Testing **client-side only** applications (SPAs)
- All HTTP calls originate from the **browser**
- Don't have **server-side rendering** or Server Components
- Want **zero additional dependencies** for simple browser-side mocking

Note: This refers to Playwright's native [`page.route()`](https://playwright.dev/docs/mock) API for browser-side request interception—not Scenarist's `@scenarist/playwright-helpers` package, which provides test fixtures for server-side scenario management.

[Compare: Scenarist vs Playwright Mocks →](/comparison/vs-playwright-mocks)

## Detailed Comparisons

<CardGrid>
  <LinkCard
    title="Scenarist + MSW"
    description="How Scenarist builds on MSW and when to use each"
    href="/comparison/with-msw"
  />
  <LinkCard
    title="vs WireMock"
    description="In-process vs server-based mocking approaches"
    href="/comparison/vs-wiremock"
  />
  <LinkCard
    title="vs Nock"
    description="Declarative scenarios vs imperative per-test setup"
    href="/comparison/vs-nock"
  />
  <LinkCard
    title="vs Testcontainers"
    description="Mocking external APIs vs running real services"
    href="/comparison/vs-testcontainers"
  />
  <LinkCard
    title="vs Playwright Mocks"
    description="Server-side vs browser-side request interception"
    href="/comparison/vs-playwright-mocks"
  />
</CardGrid>

## Making the Decision

Still not sure? Here's a decision tree:

**1. Are you testing server-side code (Server Components, API routes)?**
- Yes → Scenarist, WireMock, or Nock (not Playwright mocks)
- No (client-side only) → Playwright mocks may be sufficient

**2. Do you need parallel tests with different scenarios?**
- Yes → Scenarist (built-in isolation) or WireMock (multiple instances)
- No → Any tool works

**3. Do you need to switch scenarios during a test?**
- Yes → Scenarist (single API call) or WireMock (Admin API)
- No → Any tool works

**4. Are you using Playwright for E2E testing?**
- Yes → Scenarist (first-class fixtures with type-safe scenarios and automatic test ID isolation)
- No → Any tool works

**5. Do you need response sequences or stateful mocks?**
- Yes → Scenarist (built-in, per-test-ID isolation) or WireMock (built-in Scenarios)
- No → Any tool works

**6. Are you in a non-JavaScript environment?**
- Yes → WireMock
- No → Scenarist or Nock

**7. Does your app use databases alongside external HTTP APIs?**
- Yes → See [Testing Database Apps](/guides/testing-database-apps) for options:
  - [Repository Pattern](/guides/testing-database-apps/repository-pattern) for test ID isolation (recommended)
  - [Testcontainers Hybrid](/guides/testing-database-apps/testcontainers-hybrid) for real database + mocked APIs
- No (HTTP APIs only) → Scenarist handles everything
