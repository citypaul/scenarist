---
title: Scenarist
description: Test real backend code with controlled scenarios. Your Server Components render, middleware executes, validation runs‚Äîfor real. Only external APIs are mocked. Switch scenarios instantly without restarting.
template: splash
hero:
  title: Test Real Backend Code. Not Mocks.
  tagline: |
    Your Server Components render. Middleware executes. Validation runs‚Äîall for real.
    Only external APIs are mocked. Switch scenarios instantly without restarting.
  image:
    file: ../../assets/hero-illustration.svg
    alt: Testing real backend code with controlled external API scenarios
  actions:
    - text: Get Started
      link: /introduction/quick-start
      icon: right-arrow
      variant: primary
    - text: Why Scenarist?
      link: /introduction/why-scenarist
      icon: open-book
      variant: secondary
---

import { Card, CardGrid, Tabs, TabItem } from '@astrojs/starlight/components';

<div class="install-command">
  <code>npm install @scenarist/express-adapter</code>
</div>

---

## Why Developers Choose Scenarist

<CardGrid>
  <Card title="Real Execution" icon="rocket">
    Your Server Components render, middleware runs, validation executes‚Äîall for real.

    **No framework mocking required.**

    No mocking `next/headers`, `cookies()`, or Request objects. Test real execution with controlled scenarios.
  </Card>

  <Card title="Controlled Scenarios" icon="setting">
    External APIs mocked via MSW (Stripe, Auth0, SendGrid).

    **Switch scenarios instantly.**

    Test premium flows, error states, and edge cases without restarting your server.
  </Card>

  <Card title="Perfect Isolation" icon="approve-check">
    Unique test IDs prevent interference. Run unlimited scenarios in parallel.

    **True parallel execution.**

    Cryptographic UUIDs ensure parallel tests never collide. Same server, different scenarios.
  </Card>
</CardGrid>

---

## Works With Your Framework

Scenarist provides built-in adapters for popular Node.js frameworks, with more coming soon:

<div class="framework-grid">
  <a href="/frameworks/express/getting-started" class="framework-card">
    <span class="framework-icon">üü¢</span>
    <span class="framework-name">Express</span>
  </a>
  <a href="/frameworks/nextjs-pages-router/getting-started" class="framework-card">
    <span class="framework-icon">‚ñ≤</span>
    <span class="framework-name">Next.js Pages</span>
  </a>
  <a href="/frameworks/nextjs-app-router/getting-started" class="framework-card">
    <span class="framework-icon">‚ñ≤</span>
    <span class="framework-name">Next.js App Router</span>
  </a>
  <div class="framework-card coming-soon">
    <span class="framework-icon">üíø</span>
    <span class="framework-name">Remix <em>(coming soon)</em></span>
  </div>
  <div class="framework-card coming-soon">
    <span class="framework-icon">‚ö°</span>
    <span class="framework-name">Fastify <em>(coming soon)</em></span>
  </div>
  <div class="framework-card coming-soon">
    <span class="framework-icon">üî•</span>
    <span class="framework-name">Hono <em>(coming soon)</em></span>
  </div>
</div>

**Built-in TypeScript support** with autocomplete for scenario IDs and automatic test isolation.

---

## The Framework Mocking Problem

Testing backend code with unit tests requires extensive mocking of framework internals. This creates brittle tests that don't match production behavior.

<div class="comparison-grid">
  <div class="approach-card problem">
    <h3>‚ùå Unit Tests with Mocks</h3>

    **What you mock:**
    - Request objects
    - Cookies and headers
    - Session stores
    - Middleware chains
    - Framework internals

    **The cost:**
    - Brittle tests that break on framework updates
    - Mocks don't match production behavior
    - Each scenario needs duplicate mock setup
    - Your actual code doesn't execute
  </div>

  <div class="approach-card solution">
    <h3>‚úÖ Scenarist Approach</h3>

    **What executes for real:**
    - Server Components render
    - Middleware chains process
    - Validation logic runs
    - Session handling works
    - Real Request/Response objects

    **The benefit:**
    - No framework mocking required
    - Tests match production exactly
    - One scenario, unlimited tests
    - Parallel execution works perfectly
  </div>
</div>

[See detailed comparison ‚Üí](/introduction/why-scenarist#unit-vs-e2e-vs-scenarist)

---

## Get Started in 2 Minutes

<Tabs>
<TabItem label="Express" icon="seti:nodejs">

### 1. Define scenarios

```typescript
import type { ScenaristScenarios } from '@scenarist/express-adapter';

const scenarios = {
  success: {
    id: 'success',
    name: 'Payment Success',
    mocks: [{
      method: 'POST',
      url: 'https://api.stripe.com/v1/charges',
      response: { status: 200, body: { id: 'ch_123', status: 'succeeded' } }
    }]
  }
} as const satisfies ScenaristScenarios;
```

### 2. Write tests

```typescript
import { withScenarios } from '@scenarist/playwright-helpers';
import { scenarios } from './scenarios';

export const test = withScenarios(scenarios);

test('successful checkout', async ({ page, switchScenario }) => {
  await switchScenario(page, 'success');
  await page.goto('/checkout');
  await expect(page.locator('.success')).toBeVisible();
});
```

[See full Express setup guide ‚Üí](/frameworks/express/getting-started)

</TabItem>

<TabItem label="Next.js (Pages)" icon="seti:next">

### 1. Define scenarios

```typescript
import type { ScenaristScenarios } from '@scenarist/nextjs-adapter/pages';

const scenarios = {
  success: {
    id: 'success',
    name: 'Payment Success',
    mocks: [{
      method: 'POST',
      url: 'https://api.stripe.com/v1/charges',
      response: { status: 200, body: { id: 'ch_123', status: 'succeeded' } }
    }]
  }
} as const satisfies ScenaristScenarios;
```

### 2. Write tests

```typescript
import { withScenarios } from '@scenarist/playwright-helpers';
import { scenarios } from './scenarios';

export const test = withScenarios(scenarios);

test('successful checkout', async ({ page, switchScenario }) => {
  await switchScenario(page, 'success');
  await page.goto('/checkout');
  await expect(page.locator('.success')).toBeVisible();
});
```

[See full Next.js Pages setup guide ‚Üí](/frameworks/nextjs-pages-router/getting-started)

</TabItem>

<TabItem label="Next.js (App Router)" icon="seti:next">

### 1. Define scenarios

```typescript
import type { ScenaristScenarios } from '@scenarist/nextjs-adapter/app';

const scenarios = {
  success: {
    id: 'success',
    name: 'Payment Success',
    mocks: [{
      method: 'POST',
      url: 'https://api.stripe.com/v1/charges',
      response: { status: 200, body: { id: 'ch_123', status: 'succeeded' } }
    }]
  }
} as const satisfies ScenaristScenarios;
```

### 2. Write tests

```typescript
import { withScenarios } from '@scenarist/playwright-helpers';
import { scenarios } from './scenarios';

export const test = withScenarios(scenarios);

test('successful checkout', async ({ page, switchScenario }) => {
  await switchScenario(page, 'success');
  await page.goto('/checkout');
  await expect(page.locator('.success')).toBeVisible();
});
```

[See full Next.js App Router setup guide ‚Üí](/frameworks/nextjs-app-router/getting-started)

</TabItem>
</Tabs>

---

## Everything You Need

<CardGrid>
  <Card title="Type-Safe Helpers" icon="approve-check">
    TypeScript autocomplete for scenario IDs. Automatic test ID management. Zero boilerplate.
  </Card>

  <Card title="Perfect Isolation" icon="shield">
    Cryptographic UUIDs per test. Run unlimited tests in parallel without interference.
  </Card>

  <Card title="Runtime Switching" icon="random">
    Change scenarios instantly. No app restarts, no port conflicts, no slowdowns.
  </Card>

  <Card title="Request Matching" icon="magnifier">
    Match on body, headers, or query params. Premium vs free users. Tier-based access. A/B testing.
  </Card>

  <Card title="Response Sequences" icon="list-format">
    Polling flows (pending ‚Üí processing ‚Üí complete). Multi-step workflows. Repeat modes (last/cycle/none).
  </Card>

  <Card title="Stateful Mocks" icon="document">
    Capture state from requests. Inject into responses. Shopping carts, sessions, dynamic flows.
  </Card>

  <Card title="Ephemeral Endpoints" icon="setting">
    Zero production overhead. Endpoints only active when `enabled: true`. Safe for all environments.
  </Card>

  <Card title="Framework Agnostic" icon="puzzle">
    Express, Next.js, Fastify, Hono, Remix, SvelteKit. Hexagonal architecture. Swap frameworks easily.
  </Card>
</CardGrid>

---

## How Scenarist Compares

| What You Need | Unit Tests (Jest/Vitest) | E2E Tests (Playwright) | **Scenarist + Playwright** |
|---------------|-------------------------|------------------------|----------------------------|
| **Backend Code Execution** | ‚ùå Mocked away (isolated) | ‚úÖ Executes for real | ‚úÖ **Executes for real** |
| **Framework Mocking** | ‚ùå Mock Request, cookies, headers | ‚úÖ No mocking needed | ‚úÖ **No mocking needed** |
| **Server Components** | ‚ùå Painful framework mocking | ‚ö†Ô∏è Can't test multiple scenarios easily | ‚úÖ **Multiple scenarios without restarts** |
| **Middleware Chains** | ‚ùå Skipped (isolated) | ‚úÖ Execute | ‚úÖ **Execute** |
| **Session Handling** | ‚ùå Mock session store | ‚úÖ Real sessions | ‚úÖ **Real sessions** |
| **Multiple Scenarios** | ‚ö†Ô∏è One per test suite | ‚ùå One per server spawn | ‚úÖ **Unlimited, runtime switching** |
| **Parallel Execution** | ‚úÖ Yes (isolated) | ‚ö†Ô∏è Limited (port conflicts) | ‚úÖ **Perfect isolation (test IDs)** |

:::tip[The Key Differences]

**Unit Tests:**
```typescript
// ‚ùå Mock framework internals - your code doesn't execute
jest.mock('next/headers', () => ({ cookies: () => mockCookies }));
test('my component', () => {
  // Component doesn't actually render
  // Middleware doesn't actually run
  // Just testing mocked behavior
});
```

**E2E Tests:**
```typescript
// ‚úÖ Real execution, but...
// ‚ùå One scenario per server instance
// ‚ùå Can't test error states easily (hit real APIs)
// ‚ùå Sequential execution required
test('premium flow', ...);  // Spawns server #1
test('free flow', ...);     // Spawns server #2
test('error case', ...);    // Spawns server #3
```

**Scenarist:**
```typescript
// ‚úÖ Real backend execution
// ‚úÖ Multiple scenarios without restarts
// ‚úÖ Only external APIs mocked
test('premium flow', async ({ page, switchScenario }) => {
  await switchScenario(page, 'premium');  // Instant switch, no restart
  // Server Component renders FOR REAL
  // Middleware executes FOR REAL
  // Only Stripe API is mocked
});

test('free flow', async ({ page, switchScenario }) => {
  await switchScenario(page, 'free');  // Same server, different scenario
});
// All run in parallel against one server ‚úÖ
```
:::

---

## Frequently Asked Questions

<details>
<summary><strong>How is this different from unit tests with mocks?</strong></summary>

**Unit tests mock framework internals:** You mock Request, cookies, headers, session stores‚Äîyour actual code doesn't execute.

**Scenarist runs your real code:** Server Components render for real, middleware chains execute for real, validation logic runs for real. Only external APIs (Stripe, Auth0) are mocked.

No more mocking `next/headers`, `req.session`, or Request objects. Test real execution with controlled scenarios.

</details>

<details>
<summary><strong>How is this different from E2E tests?</strong></summary>

**E2E tests require server spawns per scenario:** Testing multiple scenarios means spawning multiple server instances or restarting between tests.

**Scenarist uses runtime switching:** All scenarios run against one server instance. Switch scenarios instantly without restarting. Test unlimited scenarios in parallel with perfect isolation.

Same real execution as E2E, but with unlimited scenarios and instant switching.

</details>

<details>
<summary><strong>What gets mocked vs. what executes?</strong></summary>

**Your code executes:** API routes, Server Components, middleware chains, validation logic, database queries

**External APIs are mocked:** Stripe, Auth0, SendGrid, or any third-party API you don't control

</details>

<details>
<summary><strong>Does this work with Server Components?</strong></summary>

Yes! Next.js Server Components render normally with Scenarist. Your data fetching, logic, and rendering all execute‚Äîonly external API calls are mocked. No Jest configuration pain.

</details>

<details>
<summary><strong>Can tests run in parallel?</strong></summary>

Yes. Each test gets a unique test ID, enabling perfect isolation. Run unlimited tests concurrently against the same server with zero interference.

</details>

<details>
<summary><strong>Do I need to restart my app per scenario?</strong></summary>

No. Scenarios switch instantly at runtime via the `switchScenario()` helper. Same server, same process, different external API responses.

</details>

<details>
<summary><strong>What are the limitations?</strong></summary>

**Single-instance deployments only:** Scenarist uses in-memory state to map test IDs to scenarios. This works perfectly for local development and single-instance CI, but not for load-balanced deployments or testing production environments.

**Not a replacement for all E2E:** Still use a few E2E tests for critical happy paths against real external APIs and production-like environment verification.

[Read full trade-offs ‚Üí](/introduction/why-scenarist#trade-offs--when-to-consider-alternatives)

</details>

---

## Ready to Ship Faster?

<CardGrid>
  <Card title="Quick Start" icon="rocket">
    Framework-agnostic 5-minute guide. Works with Express, Next.js, and more.

    [Get Started ‚Üí](/introduction/quick-start)
  </Card>

  <Card title="Next.js Guide" icon="seti:next">
    Test Server Components, Server Actions, and API routes. Supports Pages and App Router.

    [Next.js Setup ‚Üí](/frameworks/nextjs/getting-started)
  </Card>

  <Card title="Express Guide" icon="seti:nodejs">
    REST APIs, GraphQL servers, microservices. Zero boilerplate with AsyncLocalStorage.

    [Express Setup ‚Üí](/frameworks/express/getting-started)
  </Card>

  <Card title="Example Apps" icon="open-book">
    Explore complete working examples with comprehensive test suites.

    [View Examples ‚Üí](https://github.com/citypaul/scenarist/tree/main/apps)
  </Card>
</CardGrid>
