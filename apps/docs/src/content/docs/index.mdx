---
title: Test Complete User Journeys in the Browser
description: Full-stack integration testing with runtime scenario management
template: splash
hero:
  tagline: Test shopping carts, checkout flows, and multi-step journeys with different backend states. Switch scenarios instantly without restarting your app. Works with Next.js, Express, Remix, and any Node.js framework.
  image:
    file: ../../assets/houston.webp
  actions:
    - text: Get Started
      link: /introduction/quick-start
      icon: right-arrow
      variant: primary
    - text: View on GitHub
      link: https://github.com/citypaul/scenarist
      icon: external
---

import { Card, CardGrid } from '@astrojs/starlight/components';

## The Problem

Testing complete user journeys with different backend states is painful:

<CardGrid>
  <Card title="âŒ App Restart Hell" icon="refresh">
    Want to test checkout with payment errors? Restart your entire app. 60 seconds wasted per scenario.
  </Card>
  <Card title="âŒ Test Pollution" icon="error">
    Shared MSW handlers cause flaky tests. Shopping cart from test A appears in test B.
  </Card>
  <Card title="âŒ Sequential Execution" icon="warning">
    Can't run parallel tests with different backend states. Test suites take hours.
  </Card>
  <Card title="âŒ Scattered Mocks" icon="puzzle">
    Copy-paste cart setup across 50 test files. Change one field, update 50 files.
  </Card>
</CardGrid>

## The Solution

Scenarist enables **full-stack integration testing** with complete user journey support:

<CardGrid>
  <Card title="âœ… Complete Journeys" icon="rocket">
    Test multi-step flows end-to-end. Shopping cart â†’ Checkout â†’ Payment â†’ Confirmation. One test.
  </Card>
  <Card title="âœ… Instant Switching" icon="setting">
    Change backend states in less than 100ms. No app restarts. 10x faster test suites.
  </Card>
  <Card title="âœ… Perfect Isolation" icon="approve-check">
    Every test gets isolated scenario and state. Run 100+ tests concurrently without conflicts.
  </Card>
  <Card title="âœ… Centralized Scenarios" icon="star">
    Define shopping cart flow once. Reuse across all tests. Single source of truth.
  </Card>
</CardGrid>

## Why Full-Stack Frameworks Need This

Modern full-stack frameworks (Next.js, Remix, SvelteKit) make testing complete flows harder than traditional backend APIs:

### The Full-Stack Testing Problem

**Traditional Backend API (Express, Fastify):**
- Test routes in isolation
- Mock external APIs easily
- Fast feedback loops
- âœ… **Already works great with Scenarist**

**Full-Stack Frameworks (Next.js App Router, Remix):**
- Server + client code intermixed
- Server Components fetch during render
- Loader data flows to components
- **Testing requires browser + backend together**

> "Since async Server Components are new to the React ecosystem, some tools do not fully support them. In the meantime, we recommend using End-to-End Testing over Unit Testing for async components."
> â€” Next.js Official Docs

**Translation:** You need E2E tests. But E2E tests with MSW alone = slow, polluted, sequential hell.

**Scenarist Solution:** Fast E2E tests with runtime scenario switching, perfect isolation, and complete journey support. Test your full-stack app like a backend API.

### Works With Any Node.js Framework

- âœ… **Express** - Full support (AsyncLocalStorage)
- âœ… **Next.js** - Pages Router + App Router (Server Components)
- ðŸ”œ **Fastify** - High-performance async framework
- ðŸ”œ **Hono** - Edge runtime compatible
- ðŸ”œ **Remix** - Full-stack React framework
- ðŸ”œ **SvelteKit** - Svelte full-stack framework

## Complete Journey Example

Test a full shopping cart â†’ checkout â†’ payment flow in one test:

```typescript
// Define scenario once (in scenarios.ts)
import type { ScenarioDefinition } from '@scenarist/core';

export const checkoutSuccessScenario: ScenarioDefinition = {
  id: 'checkout-success',
  name: 'Successful Checkout Journey',
  mocks: [
    // Step 1: Browse products
    {
      method: 'GET',
      url: '/api/products',
      response: { status: 200, body: { products: [...] } },
    },
    // Step 2: Add to cart (capture item)
    {
      method: 'POST',
      url: '/api/cart/add',
      captureState: { 'cartItems[]': 'body.item' },  // Append to cart
      response: { status: 200, body: { success: true } },
    },
    // Step 3: View cart (inject captured items)
    {
      method: 'GET',
      url: '/api/cart',
      response: {
        status: 200,
        body: { items: '{{state.cartItems}}', count: '{{state.cartItems.length}}' }
      },
    },
    // Step 4: Checkout (capture order ID)
    {
      method: 'POST',
      url: '/api/checkout',
      captureState: { 'orderId': 'body.id' },
      response: { status: 200, body: { orderId: '12345' } },
    },
    // Step 5: Payment (uses captured order)
    {
      method: 'POST',
      url: '/api/payment',
      response: { status: 200, body: { success: true, order: '{{state.orderId}}' } },
    },
  ],
};

// Test complete journey in one test
test('successful checkout flow', async ({ page }) => {
  await switchScenario(page, 'checkout-success');

  // Complete user journey - all steps work together
  await page.goto('/products');
  await page.click('[data-product="1"]');      // Adds to cart (captured)
  await page.goto('/cart');                     // Shows captured items
  await expect(page.locator('.cart-item')).toBeVisible();

  await page.click('Proceed to Checkout');
  await page.fill('#card-number', '4242...');
  await page.click('Pay Now');                  // Uses captured cart + order

  await expect(page.locator('.success')).toContainText('Order confirmed');
});

// Test error scenario with different backend state
test('payment failure handling', async ({ page }) => {
  await switchScenario(page, 'payment-error');  // Less than 100ms switch, no restart

  // Same journey, different backend state
  await page.goto('/products');
  await page.click('[data-product="1"]');
  await page.goto('/cart');
  await page.click('Proceed to Checkout');
  await page.fill('#card-number', '4242...');
  await page.click('Pay Now');

  await expect(page.locator('.error')).toContainText('Payment declined');
});

// Both tests run in parallel with isolated state
```

## Get Started

<CardGrid>
  <Card title="Express APIs" icon="seti:nodejs">
    REST APIs, GraphQL servers, microservices. Zero boilerplate with AsyncLocalStorage.

    [Get Started â†’](/frameworks/express/getting-started)
  </Card>
  <Card title="Next.js (Pages + App Router)" icon="seti:next">
    Full-stack testing with Server Components, Server Actions, and API routes.

    [Get Started â†’](/frameworks/nextjs/pages/getting-started)
  </Card>
  <Card title="Any Node.js Framework" icon="rocket">
    Fastify, Hono, Remix, SvelteKit, tRPC. Hexagonal architecture means framework-agnostic core.

    [Learn More â†’](/concepts/scenarios)
  </Card>
  <Card title="Core Capabilities" icon="star">
    Dynamic matching, response sequences, stateful mocks, test isolation.

    [View Features â†’](/concepts/scenarios)
  </Card>
</CardGrid>
