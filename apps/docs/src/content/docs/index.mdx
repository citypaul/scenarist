---
title: Scenarist
description: Test real backend code with controlled scenarios. Your Server Components render, middleware executes, validation runs—for real. Only external APIs are mocked. Switch scenarios instantly without restarting.
template: splash
hero:
  title: Test Real Backend Code with Controlled Scenarios
  tagline: Test Server Components, API routes, and middleware with real HTTP requests. Your backend executes for real. Only external APIs are mocked. Switch scenarios instantly without restarting your server.
  image:
    file: ../../assets/hero-illustration.svg
    alt: Testing real backend code with controlled external API scenarios
  actions:
    - text: Get Started
      link: /introduction/quick-start
      icon: right-arrow
      variant: primary
    - text: Why Scenarist?
      link: /introduction/why-scenarist
      icon: open-book
      variant: secondary
---

import { Card, CardGrid, Tabs, TabItem } from '@astrojs/starlight/components';

:::tip[The Key Insight]
**Test through real HTTP requests.** Your Server Components render, middleware chains execute, validation runs—all for real.

**Built-in adapters:** Express, Next.js (Pages + App Router), with more coming. **Type-safe Playwright helpers** included for browser testing, or use supertest/Vitest for API-level tests.

**Real execution + Controlled scenarios + Runtime switching = Comprehensive backend testing**
:::

## What Scenarist Does (and Doesn't)

<CardGrid>
  <Card title="✅ What Scenarist Mocks" icon="approve-check">
    - **External HTTP APIs** - Third-party services (Stripe, SendGrid, Auth0)
    - **Microservice calls** - REST APIs, GraphQL endpoints
    - **Any outgoing HTTP request** - fetch(), axios, node-fetch
  </Card>

  <Card title="❌ What Scenarist Does NOT Mock" icon="warning">
    - **Databases** - Use [Testcontainers](https://testcontainers.com/), Prisma mocks, or real test DBs
    - **Internal functions** - Only intercepts HTTP requests leaving your app
    - **File system** - Not HTTP-based
  </Card>
</CardGrid>

:::note[Complete Testing Strategy]
Most Next.js apps need **both** database queries AND external API calls.

**Best practice:** Combine Scenarist (external APIs) + Testcontainers (databases) for complete Server Component testing.

See our [Hybrid Testing guide](/guides/testing-database-apps/hybrid-testing-strategy) for the complete pattern.
:::

**What executes for real:**
- ✅ Server Components render with actual data fetching
- ✅ Remix loaders execute with real session handling
- ✅ Middleware chains process requests through your logic
- ✅ API routes run validation and business rules
- ✅ Authentication flows work with real cookies/headers

**What's controlled:**
- External APIs return predictable responses via MSW
- No framework mocking, no Request object mocks, no brittle internal mocks

**The magic:**
- **Framework adapters:** Express, Next.js (Pages + App Router) available now, more coming soon
- **Type-safe Playwright helpers:** Automatic test ID management with TypeScript autocomplete
- Switch scenarios at runtime (no app restarts, no port conflicts)
- Run unlimited scenarios in parallel (perfect test isolation)

---

## Quick Example

**See it in action:** Choose your framework below to see a complete working example in 4 steps.

---

<Tabs>
<TabItem label="Express" icon="seti:nodejs">

**File structure:**
```
src/
├── scenarios.ts       ← 1. Define scenarios
├── setup.ts          ← 2. Initialize Scenarist
└── app.ts           ← 3. Add middleware
tests/
└── checkout.spec.ts  ← 4. Write tests
```

---

### 1. Define scenarios

Create `src/scenarios.ts`:

```typescript
import type { ScenaristScenario, ScenaristScenarios } from '@scenarist/express-adapter';

const successScenario: ScenaristScenario = {
  id: 'success',
  name: 'Payment Success',
  mocks: [{
    method: 'POST',
    url: 'https://api.stripe.com/v1/charges',
    response: { status: 200, body: { id: 'ch_123', status: 'succeeded' } },
  }],
};

export const scenarios = {
  default: successScenario,
  success: successScenario,
} as const satisfies ScenaristScenarios;
```

### 2. Initialize Scenarist

Create `src/setup.ts`:

```typescript
import { createScenarist } from '@scenarist/express-adapter';
import { scenarios } from './scenarios';

export const scenarist = createScenarist({
  enabled: process.env.NODE_ENV === 'test',
  scenarios,
});
```

### 3. Add middleware

In your `src/app.ts`:

```typescript
import express from 'express';
import { scenarist } from './setup';

const app = express();
app.use(express.json());

// Add Scenarist middleware
app.use(scenarist.middleware);

// Your routes work normally
app.post('/api/checkout', async (req, res) => {
  // Your validation runs
  // External API calls are mocked
  // Your business logic executes
});

export default app;
```

### 4. Write tests

Create `tests/checkout.spec.ts`:

```typescript
import { expect, withScenarios } from '@scenarist/playwright-helpers';
import { scenarios } from '../src/scenarios';

export const test = withScenarios(scenarios);

test('successful checkout', async ({ page, switchScenario }) => {
  await switchScenario(page, 'success');
  await page.goto('/checkout');
  await page.fill('[name="amount"]', '100');
  await page.click('button[type="submit"]');

  await expect(page.locator('.success')).toBeVisible();
});
```

</TabItem>

<TabItem label="Next.js (Pages)" icon="seti:next">

**File structure:**
```
lib/
├── scenarios.ts       ← 1. Define scenarios
└── scenarist.ts      ← 2. Initialize Scenarist
pages/api/
└── __scenario__.ts   ← 3. Create endpoint
tests/
└── checkout.spec.ts  ← 4. Write tests
```

---

### 1. Define scenarios

Create `lib/scenarios.ts`:

```typescript
import type { ScenaristScenario, ScenaristScenarios } from '@scenarist/nextjs-adapter/pages';

const successScenario: ScenaristScenario = {
  id: 'success',
  name: 'Payment Success',
  mocks: [{
    method: 'POST',
    url: 'https://api.stripe.com/v1/charges',
    response: { status: 200, body: { id: 'ch_123', status: 'succeeded' } },
  }],
};

export const scenarios = {
  default: successScenario,
  success: successScenario,
} as const satisfies ScenaristScenarios;
```

### 2. Initialize Scenarist

Create `lib/scenarist.ts`:

```typescript
import { createScenarist } from '@scenarist/nextjs-adapter/pages';
import { scenarios } from './scenarios';

export const scenarist = createScenarist({
  enabled: process.env.NODE_ENV === 'test',
  scenarios,
});
```

### 3. Create scenario endpoint

Create `pages/api/__scenario__.ts`:

```typescript
import { scenarist } from '@/lib/scenarist';

export default scenarist.createScenarioEndpoint();
```

### 4. Write tests

Create `tests/checkout.spec.ts`:

```typescript
import { expect, withScenarios } from '@scenarist/playwright-helpers';
import { scenarios } from '../lib/scenarios';

export const test = withScenarios(scenarios);

test('successful checkout', async ({ page, switchScenario }) => {
  await switchScenario(page, 'success');
  await page.goto('/checkout');
  await page.fill('[name="amount"]', '100');
  await page.click('button[type="submit"]');

  await expect(page.locator('.success')).toBeVisible();
});
```

</TabItem>

<TabItem label="Next.js (App Router)" icon="seti:next">

**File structure:**
```
lib/
├── scenarios.ts       ← 1. Define scenarios
└── scenarist.ts      ← 2. Initialize Scenarist
app/api/__scenario__/
└── route.ts          ← 3. Create endpoint
tests/
└── checkout.spec.ts  ← 4. Write tests
```

---

### 1. Define scenarios

Create `lib/scenarios.ts`:

```typescript
import type { ScenaristScenario, ScenaristScenarios } from '@scenarist/nextjs-adapter/app';

const successScenario: ScenaristScenario = {
  id: 'success',
  name: 'Payment Success',
  mocks: [{
    method: 'POST',
    url: 'https://api.stripe.com/v1/charges',
    response: { status: 200, body: { id: 'ch_123', status: 'succeeded' } },
  }],
};

export const scenarios = {
  default: successScenario,
  success: successScenario,
} as const satisfies ScenaristScenarios;
```

### 2. Initialize Scenarist

Create `lib/scenarist.ts`:

```typescript
import { createScenarist } from '@scenarist/nextjs-adapter/app';
import { scenarios } from './scenarios';

export const scenarist = createScenarist({
  enabled: process.env.NODE_ENV === 'test',
  scenarios,
});
```

### 3. Create scenario endpoint

Create `app/api/__scenario__/route.ts`:

```typescript
import { scenarist } from '@/lib/scenarist';

const handler = scenarist.createScenarioEndpoint();
export const POST = handler;
export const GET = handler;
```

### 4. Write tests

Create `tests/checkout.spec.ts`:

```typescript
import { expect, withScenarios } from '@scenarist/playwright-helpers';
import { scenarios } from '../lib/scenarios';

export const test = withScenarios(scenarios);

test('successful checkout', async ({ page, switchScenario }) => {
  await switchScenario(page, 'success');
  await page.goto('/checkout');
  await page.fill('[name="amount"]', '100');
  await page.click('button[type="submit"]');

  await expect(page.locator('.success')).toBeVisible();
});
```

</TabItem>
</Tabs>

---

## The Framework Mocking Problem

Unit tests for backend code require extensive mocking of framework internals—Request objects, cookies, headers, session stores. This creates brittle tests that don't match production behavior.

**Scenarist lets your actual backend code execute.** No framework mocking required.

<Tabs>
<TabItem label="❌ Unit Test Pain" icon="warning">

**Testing Next.js Server Components with unit tests:**

```typescript
// You have to mock Next.js framework internals
const mockCookies = {
  get: jest.fn((name) => name === 'tier' ? 'premium' : null),
};
const mockHeaders = {
  get: jest.fn((name) => name === 'x-user-id' ? '123' : null),
};

jest.mock('next/headers', () => ({
  cookies: () => mockCookies,
  headers: () => mockHeaders,
}));

// Now test your component with fake framework objects
// Any change to Next.js internals breaks your tests
// Mocks don't match production Request behavior
```

**The pain:**
- Mock setup is brittle and framework-specific
- Mocks create distance from production reality
- Middleware chains don't execute (you're testing in isolation)
- Session logic doesn't run (mocked away)
- Each scenario needs duplicate mock setup

</TabItem>

<TabItem label="✅ Scenarist Approach" icon="approve-check">

**Testing the same code with Scenarist:**

```typescript
// Define scenario once
const premiumScenario = {
  id: 'premium',
  name: 'Premium User',
  mocks: [{
    method: 'GET',
    url: 'https://auth.external-api.com/session',
    response: { status: 200, body: { tier: 'premium' } }
  }]
};

// Test with real HTTP, real Next.js, real everything
test('premium user sees discount', async ({ page, switchScenario }) => {
  await switchScenario(page, 'premium');
  await page.goto('/dashboard');

  // Real Server Component renders
  // Real cookies() and headers() from Next.js
  // Real middleware chain executes
  // Only external API is mocked
});
```

**The difference:**
- No framework mocking required
- Server Component renders for real
- Middleware chains execute
- Session logic runs
- One scenario definition, unlimited tests

</TabItem>
</Tabs>

[Read more about why this is hard →](/introduction/why-scenarist)

---

## When to Use Scenarist

### ✅ Good Use Cases

**Local development with multiple scenarios:**
- Testing premium vs free user features
- Error states and edge cases
- Multi-step flows with session state
- Different permission levels

**Single-instance CI pipelines:**
- GitHub Actions with single worker
- GitLab CI with one instance
- Local CI servers (Jenkins, TeamCity)

**Integration tests needing real HTTP:**
- Server Components that need real rendering
- Middleware chains that need real execution
- API routes with complex validation
- Session-based authentication flows

### ⚠️ Limitations

**Single-instance deployments only:**
Scenarist uses in-memory state to map test IDs to scenarios. This works perfectly for:
- Local development
- Single-instance CI (most common)
- Tests against `localhost`

This does NOT work for:
- Load-balanced deployments
- Testing production environments
- Distributed testing across multiple instances

**Not a replacement for all E2E:**
Use Scenarist for comprehensive scenario coverage. Still use a few E2E tests for:
- Critical happy paths against real external APIs
- Production-like environment verification
- Contract validation with third-party services

### ❌ When NOT to Use

- **You need true E2E with real external APIs** - Scenarist mocks external services
- **Your app has no external dependencies** - Unnecessary complexity
- **You're testing frontend-only apps** - Scenarist is for backend HTTP behavior
- **You need load-balanced deployment testing** - Current architecture requires single instance

[Understand the trade-offs →](/introduction/why-scenarist#trade-offs--when-to-consider-alternatives)

---

## Why Scenarist?

:::tip[Three Core Pillars]
**Real Execution** - Your Server Components render, middleware runs, validation executes—all for real

**Controlled Scenarios** - External APIs mocked via MSW (Stripe, Auth0, SendGrid)

**Runtime Switching** - Change scenarios instantly without restarting your server
:::

**What this enables:**

✅ **Comprehensive scenario testing**
- Premium vs free user flows
- Error states and edge cases
- Multi-step journeys with session state
- Permission levels and authentication states
- All running in parallel against one server

✅ **No framework mocking required**
- Real `cookies()` and `headers()` from Next.js
- Real session handling in Remix loaders
- Real middleware chains in Express
- Real Request/Response objects everywhere

✅ **Fast parallel execution**
- Unique test IDs prevent interference
- 10+ scenarios run simultaneously
- No port conflicts, no app restarts
- Test suite completes in seconds, not minutes

**How it works:**
- **Built-in framework adapters:** Express, Next.js (Pages + App Router) available now—Remix, Fastify, Hono, SvelteKit coming soon
- **Type-safe Playwright helpers:** `withScenarios()` provides TypeScript autocomplete for scenario IDs and automatic test isolation
- **Ephemeral endpoints:** Scenario switching only active when `enabled: true` (zero production overhead)
- **Guaranteed isolation:** Cryptographic UUIDs per test ensure parallel tests never interfere

---

## Playwright Integration with Type Safety

Scenarist includes **first-class Playwright support** with helpers that eliminate boilerplate and guarantee test isolation:

**Without helpers:**
```typescript
const testId = `test-premium-${Date.now()}`;
const response = await page.request.post('http://localhost:3000/api/__scenario__', {
  headers: { 'x-test-id': testId },
  data: { scenario: 'premiumUser' },
});
expect(response.status()).toBe(200);
await page.setExtraHTTPHeaders({ 'x-test-id': testId });
```

**With helpers:**
```typescript
import { test, expect } from '@scenarist/playwright-helpers';
await switchScenario(page, 'premiumUser');
```

**Type-Safe Scenario IDs** - Get autocomplete and compile-time validation:

```typescript
// Define scenarios once
const scenarios = {
  cartWithState: { id: 'cartWithState', name: 'Cart with State', ... },
  premiumUser: { id: 'premiumUser', name: 'Premium User', ... },
} as const satisfies ScenaristScenarios;

// Create typed test object
export const test = withScenarios(scenarios);

// TypeScript autocomplete in tests
test('my test', async ({ page, switchScenario }) => {
  await switchScenario(page, 'cartWithState'); // ✅ Autocomplete works!
  await switchScenario(page, 'typo');          // ❌ TypeScript error
});
```

**Guaranteed Test Isolation** - Unique test IDs prevent collisions in parallel execution (uses `crypto.randomUUID()` per test).

**Easy Composition** - Extend with your existing Playwright fixtures:

```typescript
export const test = withScenarios(scenarios).extend<MyFixtures>({
  authenticatedPage: async ({ page }, use) => { /* your fixture */ },
  database: async ({}, use) => { /* your fixture */ },
});
```

[Learn more about Playwright helpers →](https://github.com/citypaul/scenarist/tree/main/packages/playwright-helpers)

---

## How Scenarist Compares

| What You Need | Unit Tests (Jest/Vitest) | E2E Tests (Playwright) | **Scenarist + Playwright** |
|---------------|-------------------------|------------------------|----------------------------|
| **Backend Code Execution** | ❌ Mocked away (isolated) | ✅ Executes for real | ✅ **Executes for real** |
| **Framework Mocking** | ❌ Mock Request, cookies, headers | ✅ No mocking needed | ✅ **No mocking needed** |
| **Server Components** | ❌ Painful framework mocking | ⚠️ Can't test multiple scenarios easily | ✅ **Multiple scenarios without restarts** |
| **Middleware Chains** | ❌ Skipped (isolated) | ✅ Execute | ✅ **Execute** |
| **Session Handling** | ❌ Mock session store | ✅ Real sessions | ✅ **Real sessions** |
| **Multiple Scenarios** | ⚠️ One per test suite | ❌ One per server spawn | ✅ **Unlimited, runtime switching** |
| **Parallel Execution** | ✅ Yes (isolated) | ⚠️ Limited (port conflicts) | ✅ **Perfect isolation (test IDs)** |
| **Test Speed** | ✅ Very fast | ❌ Slow (server spawns) | ✅ **Fast (no restarts)** |

:::tip[The Key Differences]

**Unit Tests:**
```typescript
// ❌ Mock framework internals - your code doesn't execute
jest.mock('next/headers', () => ({ cookies: () => mockCookies }));
test('my component', () => {
  // Component doesn't actually render
  // Middleware doesn't actually run
  // Just testing mocked behavior
});
```

**E2E Tests:**
```typescript
// ✅ Real execution, but...
// ❌ One scenario per server instance
// ❌ Can't test error states easily (hit real APIs)
// ❌ Too slow for 10+ scenarios
test('premium flow', ...);  // Spawns server #1
test('free flow', ...);     // Spawns server #2
test('error case', ...);    // Spawns server #3
```

**Scenarist:**
```typescript
// ✅ Real backend execution
// ✅ Multiple scenarios without restarts
// ✅ Only external APIs mocked
test('premium flow', async ({ page, switchScenario }) => {
  await switchScenario(page, 'premium');  // Instant switch, no restart
  // Server Component renders FOR REAL
  // Middleware executes FOR REAL
  // Only Stripe API is mocked
});

test('free flow', async ({ page, switchScenario }) => {
  await switchScenario(page, 'free');  // Same server, different scenario
});
// All run in parallel against one server ✅
```
:::

---

## Frequently Asked Questions

<details>
<summary><strong>How is this different from unit tests with mocks?</strong></summary>

**Unit tests mock framework internals:** You mock Request, cookies, headers, session stores—your actual code doesn't execute.

**Scenarist runs your real code:** Server Components render for real, middleware chains execute for real, validation logic runs for real. Only external APIs (Stripe, Auth0) are mocked.

No more mocking `next/headers`, `req.session`, or Request objects. Test real execution with controlled scenarios.

</details>

<details>
<summary><strong>How is this different from E2E tests?</strong></summary>

**E2E tests require server spawns per scenario:** Testing 10 scenarios means spawning 10 server instances, which is slow and creates port conflicts.

**Scenarist uses runtime switching:** All scenarios run against one server instance. Switch scenarios instantly without restarting. Test 10 scenarios in parallel with perfect isolation.

Same real execution as E2E, but with unlimited scenarios and instant switching.

</details>

<details>
<summary><strong>What gets mocked vs. what executes?</strong></summary>

**Your code executes:** API routes, Server Components, middleware chains, validation logic, database queries

**External APIs are mocked:** Stripe, Auth0, SendGrid, or any third-party API you don't control

</details>

<details>
<summary><strong>Does this work with Server Components?</strong></summary>

Yes! Next.js Server Components render normally with Scenarist. Your data fetching, logic, and rendering all execute—only external API calls are mocked. No Jest configuration pain.

</details>

<details>
<summary><strong>Can tests run in parallel?</strong></summary>

Yes. Each test gets a unique test ID, enabling perfect isolation. Run hundreds of tests concurrently against the same server with zero interference.

</details>

<details>
<summary><strong>Do I need to restart my app per scenario?</strong></summary>

No. Scenarios switch instantly at runtime via the `switchScenario()` helper. Same server, same process, different external API responses.

</details>

<details>
<summary><strong>What if my test uses page.request.post()?</strong></summary>

Use the `withScenarios()` helper to get automatic test ID propagation:
```typescript
export const test = withScenarios(scenarios);
```

For manual `page.request` calls, the helper returns the test ID so you can include it explicitly in headers.

</details>

<details>
<summary><strong>How do I debug failed tests?</strong></summary>

Enable MSW request logging:
```typescript
server.events.on('request:start', ({ request }) => {
  console.log('[MSW]', request.method, request.url);
});
```

Check active scenario:
```typescript
const response = await page.request.get('http://localhost:3000/__scenario__');
console.log(await response.json());
```

</details>

---

## Get Started

<CardGrid>
  <Card title="Quick Start" icon="rocket">
    Framework-agnostic 5-minute guide. Works with Express, Next.js, Fastify, Hono, Remix, and any Node.js framework.

    [Get Started →](/introduction/quick-start)
  </Card>
  <Card title="Playwright Helpers" icon="approve-check">
    Type-safe scenario switching with automatic test ID management. Guaranteed test isolation for parallel execution.

    [Playwright Guide →](https://github.com/citypaul/scenarist/tree/main/packages/playwright-helpers)
  </Card>
  <Card title="Express Setup" icon="seti:nodejs">
    REST APIs, GraphQL servers, microservices. Zero boilerplate with AsyncLocalStorage.

    [Express Guide →](/frameworks/express/getting-started)
  </Card>
  <Card title="Next.js Setup" icon="seti:next">
    Test Server Components, Server Actions, and API routes. Supports Pages and App Router.

    [Next.js Guide →](/frameworks/nextjs/getting-started)
  </Card>
  <Card title="Example Apps" icon="open-book">
    Explore complete working examples with comprehensive test suites.

    [View Examples →](https://github.com/citypaul/scenarist/tree/main/apps)
  </Card>
</CardGrid>
