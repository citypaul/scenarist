---
title: Scenarist
description: Browser-based testing where your backend actually runs. Test API routes, validation logic, SSR, and Server Components with real execution across any Node.js framework.
template: splash
hero:
  title: Browser Testing That Actually Runs Your Backend
  tagline: Test your backend logic in the browser without compromises. Traditional approaches either mock everything (your code never runs) or require slow app restarts per scenario. Scenarist mocks only external APIs while your API routes, validation logic, middleware, SSR, and Server Components execute normally. Works with Express, Next.js, Hono, Fastify, and any Node.js framework. Instant scenario switching in Playwright with type-safe helpers.
  image:
    file: ../../assets/hero-illustration.svg
    alt: Illustration showing backend server with API routes, Server Components, and validation connected to a browser running tests
  actions:
    - text: Get Started
      link: /introduction/quick-start
      icon: right-arrow
      variant: primary
    - text: View on GitHub
      link: https://github.com/citypaul/scenarist
      icon: external
      variant: secondary
---

import { Card, CardGrid, Tabs, TabItem } from '@astrojs/starlight/components';

---

## The Testing Gap (And How Scenarist Fills It)

**Most teams split testing:**
- **Unit tests (Jest/Vitest)** → Test functions in isolation
- **Browser tests (Playwright/Cypress)** → Test happy path only

**The critical gap:**

Unit tests CAN test server-side logic, but it's painful and risky:
- ⚠️ Requires extensive mocking at the code level (sessions, auth, request objects)
- ⚠️ Mocks create a gap between how you test vs. how code actually runs
- ⚠️ Easy to introduce bugs that only surface in real user journeys
- ⚠️ Testing integrated flows requires complex test setup (mocking middleware chains, context, etc.)

Browser tests capture real user journeys, but only for 1-2 scenarios:
- ❌ Can't test error cases, edge cases, different user states
- ❌ Testing multiple scenarios requires complex per-test mocking OR impractical server restarts

**The reality:** You can test server-side logic in unit tests with enough mocking, but those mocks create distance from production reality. Browser tests are closer to reality but limited to happy paths.

**Scenarist fills the gap:**
Test your backend logic through real HTTP requests in the browser with **unlimited scenarios**. Your code executes with real server-side context, sessions, and middleware chains—just like production—but with external APIs mocked per scenario.

:::tip[How It Works]
**Traditional approach:** Unit tests (isolated functions) + Browser tests (happy path only)

**Scenarist approach:** Unit tests (isolated functions) + Browser tests with Scenarist (all scenarios through real server execution)

**What executes:** Your API routes, validation logic, middleware chains, SSR, Server Components (Next.js)—everything runs with real server-side context, sessions, and request lifecycle

**What's mocked:** Only external APIs you don't control (Stripe, SendGrid, Auth0, etc.)

**The difference:** Your code runs as part of actual user journeys in the browser, not in isolation, giving you confidence that server-side logic works correctly in the real execution environment.
:::

**Framework-agnostic:** Express, Next.js (Pages + App Router), Fastify, Hono, Remix, and SvelteKit.

---

## How It Works: Ephemeral Endpoints & Test Isolation

Scenarist creates **ephemeral scenario endpoints** that only exist when testing is enabled:

```typescript
// Express
const scenarist = createScenarist({
  enabled: process.env.NODE_ENV === 'test',  // ← Only creates endpoints in test mode
  scenarios,
});
app.use(scenarist.middleware);  // Middleware no-ops when disabled

// Next.js App Router
export const scenarist = createScenarist({
  enabled: process.env.NODE_ENV === 'test',
  scenarios,
});
// app/api/__scenario__/route.ts exists but returns 404 when disabled
```

**Per-environment control:** The `enabled` flag determines whether:
- Scenario switching endpoints are active (e.g., `POST /api/__scenario__`)
- Middleware intercepts requests to extract test IDs
- MSW handlers are registered for mocking

When `enabled: false` (production), these endpoints return 404 and middleware passes through unchanged—zero runtime overhead, zero attack surface.

**Test isolation via unique test IDs:** Each Playwright test gets a unique ID (via `crypto.randomUUID()`), enabling parallel execution:

```typescript
import { test } from '@scenarist/playwright-helpers';

// Test 1: uuid-abc-123 → scenario: 'premiumUser'
test('premium flow', async ({ page, switchScenario }) => {
  await switchScenario(page, 'premiumUser');  // Sets x-test-id: uuid-abc-123
  // All requests from this test use uuid-abc-123
});

// Test 2: uuid-xyz-789 → scenario: 'standardUser' (runs in parallel!)
test('standard flow', async ({ page, switchScenario }) => {
  await switchScenario(page, 'standardUser');  // Sets x-test-id: uuid-xyz-789
  // Completely isolated from Test 1
});
```

**How isolation works:**
1. Each test gets unique ID from `crypto.randomUUID()`
2. ID sent in `x-test-id` header with every request
3. Scenarist routes requests to correct scenario based on test ID
4. Multiple tests run in parallel with zero interference

**Playwright helpers provide:**
- Automatic test ID generation and header management
- Type-safe scenario IDs with autocomplete
- 77% boilerplate reduction (9 lines → 2 lines)
- Easy composition with existing fixtures

---

## Playwright Integration with Type Safety

Scenarist includes **first-class Playwright support** with helpers that eliminate boilerplate and guarantee test isolation:

**Code Reduction: 77%** - From 9 lines of boilerplate to 2 lines:

```typescript
// ❌ Without helpers (9 lines per test)
const testId = `test-premium-${Date.now()}`;
const response = await page.request.post('http://localhost:3000/api/__scenario__', {
  headers: { 'x-test-id': testId },
  data: { scenario: 'premiumUser' },
});
expect(response.status()).toBe(200);
await page.setExtraHTTPHeaders({ 'x-test-id': testId });

// ✅ With helpers (2 lines - configured once)
import { test, expect } from '@scenarist/playwright-helpers';
await switchScenario(page, 'premiumUser');
```

**Type-Safe Scenario IDs** - Get autocomplete and compile-time validation:

```typescript
// Define scenarios once
const scenarios = {
  cartWithState: { id: 'cartWithState', name: 'Cart with State', ... },
  premiumUser: { id: 'premiumUser', name: 'Premium User', ... },
} as const satisfies ScenaristScenarios;

// Create typed test object
export const test = withScenarios(scenarios);

// TypeScript autocomplete in tests
test('my test', async ({ page, switchScenario }) => {
  await switchScenario(page, 'cartWithState'); // ✅ Autocomplete works!
  await switchScenario(page, 'typo');          // ❌ TypeScript error
});
```

**Guaranteed Test Isolation** - Unique test IDs prevent collisions in parallel execution (uses `crypto.randomUUID()` per test).

**Easy Composition** - Extend with your existing Playwright fixtures:

```typescript
export const test = withScenarios(scenarios).extend<MyFixtures>({
  authenticatedPage: async ({ page }, use) => { /* your fixture */ },
  database: async ({}, use) => { /* your fixture */ },
});
```

[Learn more about Playwright helpers →](https://github.com/citypaul/scenarist/tree/main/packages/playwright-helpers)

---

## Why Scenarist?

### The Standard Approach (and Where It Falls Short)

| What You Test | Jest/Vitest | Playwright/Cypress | **Scenarist + Playwright** |
|---------------|-------------|-------------------|----------------------------|
| **Business Logic** | ✅ Functions in isolation | ❌ Can't test multiple scenarios | ✅ **All scenarios through HTTP** |
| **Server-Side Context** | ⚠️ Can mock, but painful | ❌ Backend mocked away | ✅ **Real sessions, real context** |
| **Middleware Chains** | ⚠️ Can mock, but complex | ❌ Never execute | ✅ **Real execution as integrated flow** |
| **Validation Logic** | ✅ Individual validators | ❌ Not tested with HTTP layer | ✅ **Through full request flow** |
| **Server Components** | ⚠️ Can test, but very painful | ❌ Not tested | ✅ **Real rendering with server context** |
| **Error Scenarios** | ✅ Unlimited (with mocking) | ❌ Only happy path | ✅ **All scenarios in browser** |
| **User Journey** | ⚠️ Can mock, but fragile | ✅ Happy path only | ✅ **All scenarios as real journeys** |
| **External APIs** | ⚠️ Mock at code level | Manual per-test setup | ✅ **Scenario-based (MSW)** |
| **Multiple Scenarios** | ✅ Unlimited (with mocks) | ❌ Just 1-2 (happy paths) | ✅ **Unlimited in browser** |
| **Test Speed** | ✅ Very fast | ⚠️ Moderate | ✅ **Fast** |

:::tip[The Gap Scenarist Fills]

**What teams do today:**
- Unit tests → CAN test everything, but requires extensive mocking at code level (creates gap between tests and reality)
- Browser tests → Real execution without mocks, but limited to happy path only

**The gap:** Mocking sessions, auth, request objects, middleware in unit tests is painful and creates distance from production. Those mocks can hide bugs that only surface in real user journeys.

**Why the gap exists:** Testing multiple scenarios in browser-based tests requires complex per-test mocking setup OR impractical server restarts OR hitting real external APIs (slow/flaky).

**How Scenarist fills it:** Test all scenarios through real HTTP requests with real server execution (no code-level mocking), while mocking only external APIs. Your code runs exactly like production, but with controllable external dependencies.
:::

---

## Quick Example

<Tabs>
<TabItem label="Express" icon="seti:nodejs">

```typescript
// src/scenarios.ts
import type { ScenaristScenario, ScenaristScenarios } from '@scenarist/express-adapter';

const successScenario: ScenaristScenario = {
  id: 'success',
  name: 'Payment Success',
  mocks: [{
    method: 'POST',
    url: 'https://api.stripe.com/v1/charges',
    response: { status: 200, body: { id: 'ch_123', status: 'succeeded' } },
  }],
};

export const scenarios = {
  default: successScenario,
  success: successScenario,
} as const satisfies ScenaristScenarios;

// src/setup.ts
import { createScenarist } from '@scenarist/express-adapter';
import { scenarios } from './scenarios';

export const scenarist = createScenarist({
  enabled: process.env.NODE_ENV === 'test',
  scenarios,
});

// src/app.ts
import { scenarist } from './setup';
const app = express();
app.use(scenarist.middleware);  // Everything wired automatically

// tests/checkout.spec.ts
import { test, expect } from '@scenarist/playwright-helpers';

test('successful checkout', async ({ page, switchScenario }) => {
  await switchScenario(page, 'success');
  await page.goto('/checkout');
  await page.fill('[name="amount"]', '100');
  await page.click('button[type="submit"]');

  await expect(page.locator('.success')).toBeVisible();
});
```

</TabItem>

<TabItem label="Next.js (Pages)" icon="seti:next">

```typescript
// lib/scenarios.ts
import type { ScenaristScenario, ScenaristScenarios } from '@scenarist/nextjs-adapter/pages';

const successScenario: ScenaristScenario = {
  id: 'success',
  name: 'Payment Success',
  mocks: [{
    method: 'POST',
    url: 'https://api.stripe.com/v1/charges',
    response: { status: 200, body: { id: 'ch_123', status: 'succeeded' } },
  }],
};

export const scenarios = {
  default: successScenario,
  success: successScenario,
} as const satisfies ScenaristScenarios;

// lib/scenarist.ts
import { createScenarist } from '@scenarist/nextjs-adapter/pages';
import { scenarios } from './scenarios';

export const scenarist = createScenarist({
  enabled: process.env.NODE_ENV === 'test',
  scenarios,
});

// pages/api/__scenario__.ts
import { scenarist } from '@/lib/scenarist';
export default scenarist.createScenarioEndpoint();

// tests/checkout.spec.ts
import { test, expect } from '@scenarist/playwright-helpers';

test('successful checkout', async ({ page, switchScenario }) => {
  await switchScenario(page, 'success');
  await page.goto('/checkout');
  await page.fill('[name="amount"]', '100');
  await page.click('button[type="submit"]');

  await expect(page.locator('.success')).toBeVisible();
});
```

</TabItem>

<TabItem label="Next.js (App Router)" icon="seti:next">

```typescript
// lib/scenarios.ts
import type { ScenaristScenario, ScenaristScenarios } from '@scenarist/nextjs-adapter/app';

const successScenario: ScenaristScenario = {
  id: 'success',
  name: 'Payment Success',
  mocks: [{
    method: 'POST',
    url: 'https://api.stripe.com/v1/charges',
    response: { status: 200, body: { id: 'ch_123', status: 'succeeded' } },
  }],
};

export const scenarios = {
  default: successScenario,
  success: successScenario,
} as const satisfies ScenaristScenarios;

// lib/scenarist.ts
import { createScenarist } from '@scenarist/nextjs-adapter/app';
import { scenarios } from './scenarios';

export const scenarist = createScenarist({
  enabled: process.env.NODE_ENV === 'test',
  scenarios,
});

// app/api/__scenario__/route.ts
import { scenarist } from '@/lib/scenarist';

const handler = scenarist.createScenarioEndpoint();
export const POST = handler;
export const GET = handler;

// tests/checkout.spec.ts
import { test, expect } from '@scenarist/playwright-helpers';

test('successful checkout', async ({ page, switchScenario }) => {
  await switchScenario(page, 'success');
  await page.goto('/checkout');
  await page.fill('[name="amount"]', '100');
  await page.click('button[type="submit"]');

  await expect(page.locator('.success')).toBeVisible();
});
```

</TabItem>
</Tabs>

---

## Get Started

<CardGrid>
  <Card title="Quick Start" icon="rocket">
    Framework-agnostic 5-minute guide. Works with Express, Next.js, Fastify, Hono, Remix, and any Node.js framework.

    [Get Started →](/introduction/quick-start)
  </Card>
  <Card title="Playwright Helpers" icon="approve-check">
    Type-safe scenario switching with 77% less boilerplate. Guaranteed test isolation for parallel execution.

    [Playwright Guide →](https://github.com/citypaul/scenarist/tree/main/packages/playwright-helpers)
  </Card>
  <Card title="Express Setup" icon="seti:nodejs">
    REST APIs, GraphQL servers, microservices. Zero boilerplate with AsyncLocalStorage.

    [Express Guide →](/frameworks/express/getting-started)
  </Card>
  <Card title="Next.js Setup" icon="seti:next">
    Test Server Components, Server Actions, and API routes. Supports Pages and App Router.

    [Next.js Guide →](/frameworks/nextjs/getting-started)
  </Card>
  <Card title="Example Apps" icon="open-book">
    Explore complete working examples with comprehensive test suites.

    [View Examples →](https://github.com/citypaul/scenarist/tree/main/apps)
  </Card>
</CardGrid>
