---
title: Scenarist
description: Browser-based testing where your backend actually runs. Test API routes, validation logic, SSR, and Server Components with real execution across any Node.js framework.
template: splash
hero:
  title: Browser Testing That Actually Runs Your Backend
  tagline: Test Next.js Server Components, Remix loaders, and Express APIs with unlimited scenarios. Mock only external APIs. Everything runs with real server-side context.
  image:
    file: ../../assets/hero-illustration.svg
    alt: Illustration showing backend server with API routes, Server Components, and validation connected to a browser running tests
  actions:
    - text: Get Started
      link: /introduction/quick-start
      icon: right-arrow
      variant: primary
    - text: View on GitHub
      link: https://github.com/citypaul/scenarist
      icon: external
      variant: secondary
---

import { Card, CardGrid, Tabs, TabItem } from '@astrojs/starlight/components';

**Test the hard stuff:** Server Components, Remix loaders, TanStack Start, middleware chains—code that's difficult to test in isolation.

**Works everywhere:** Express, Next.js (Pages + App Router), Hono, Fastify, Remix, and any Node.js framework.

**Type-safe testing:** Playwright helpers with autocomplete, automatic test ID management, and guaranteed test isolation.

---

## Quick Example

**See it in action:** Choose your framework below to see a complete working example in 4 steps.

---

<Tabs>
<TabItem label="Express" icon="seti:nodejs">

**File structure:**
```
src/
├── scenarios.ts       ← 1. Define scenarios
├── setup.ts          ← 2. Initialize Scenarist
└── app.ts           ← 3. Add middleware
tests/
└── checkout.spec.ts  ← 4. Write tests
```

---

### 1. Define scenarios

Create `src/scenarios.ts`:

```typescript
import type { ScenaristScenario, ScenaristScenarios } from '@scenarist/express-adapter';

const successScenario: ScenaristScenario = {
  id: 'success',
  name: 'Payment Success',
  mocks: [{
    method: 'POST',
    url: 'https://api.stripe.com/v1/charges',
    response: { status: 200, body: { id: 'ch_123', status: 'succeeded' } },
  }],
};

export const scenarios = {
  default: successScenario,
  success: successScenario,
} as const satisfies ScenaristScenarios;
```

### 2. Initialize Scenarist

Create `src/setup.ts`:

```typescript
import { createScenarist } from '@scenarist/express-adapter';
import { scenarios } from './scenarios';

export const scenarist = createScenarist({
  enabled: process.env.NODE_ENV === 'test',
  scenarios,
});
```

### 3. Add middleware

In your `src/app.ts`:

```typescript
import express from 'express';
import { scenarist } from './setup';

const app = express();
app.use(express.json());

// Add Scenarist middleware
app.use(scenarist.middleware);

// Your routes work normally
app.post('/api/checkout', async (req, res) => {
  // Your validation runs
  // External API calls are mocked
  // Your business logic executes
});

export default app;
```

### 4. Write tests

Create `tests/checkout.spec.ts`:

```typescript
import { expect, withScenarios } from '@scenarist/playwright-helpers';
import { scenarios } from '../src/scenarios';

export const test = withScenarios(scenarios);

test('successful checkout', async ({ page, switchScenario }) => {
  await switchScenario(page, 'success');
  await page.goto('/checkout');
  await page.fill('[name="amount"]', '100');
  await page.click('button[type="submit"]');

  await expect(page.locator('.success')).toBeVisible();
});
```

</TabItem>

<TabItem label="Next.js (Pages)" icon="seti:next">

**File structure:**
```
lib/
├── scenarios.ts       ← 1. Define scenarios
└── scenarist.ts      ← 2. Initialize Scenarist
pages/api/
└── __scenario__.ts   ← 3. Create endpoint
tests/
└── checkout.spec.ts  ← 4. Write tests
```

---

### 1. Define scenarios

Create `lib/scenarios.ts`:

```typescript
import type { ScenaristScenario, ScenaristScenarios } from '@scenarist/nextjs-adapter/pages';

const successScenario: ScenaristScenario = {
  id: 'success',
  name: 'Payment Success',
  mocks: [{
    method: 'POST',
    url: 'https://api.stripe.com/v1/charges',
    response: { status: 200, body: { id: 'ch_123', status: 'succeeded' } },
  }],
};

export const scenarios = {
  default: successScenario,
  success: successScenario,
} as const satisfies ScenaristScenarios;
```

### 2. Initialize Scenarist

Create `lib/scenarist.ts`:

```typescript
import { createScenarist } from '@scenarist/nextjs-adapter/pages';
import { scenarios } from './scenarios';

export const scenarist = createScenarist({
  enabled: process.env.NODE_ENV === 'test',
  scenarios,
});
```

### 3. Create scenario endpoint

Create `pages/api/__scenario__.ts`:

```typescript
import { scenarist } from '@/lib/scenarist';

export default scenarist.createScenarioEndpoint();
```

### 4. Write tests

Create `tests/checkout.spec.ts`:

```typescript
import { expect, withScenarios } from '@scenarist/playwright-helpers';
import { scenarios } from '../lib/scenarios';

export const test = withScenarios(scenarios);

test('successful checkout', async ({ page, switchScenario }) => {
  await switchScenario(page, 'success');
  await page.goto('/checkout');
  await page.fill('[name="amount"]', '100');
  await page.click('button[type="submit"]');

  await expect(page.locator('.success')).toBeVisible();
});
```

</TabItem>

<TabItem label="Next.js (App Router)" icon="seti:next">

**File structure:**
```
lib/
├── scenarios.ts       ← 1. Define scenarios
└── scenarist.ts      ← 2. Initialize Scenarist
app/api/__scenario__/
└── route.ts          ← 3. Create endpoint
tests/
└── checkout.spec.ts  ← 4. Write tests
```

---

### 1. Define scenarios

Create `lib/scenarios.ts`:

```typescript
import type { ScenaristScenario, ScenaristScenarios } from '@scenarist/nextjs-adapter/app';

const successScenario: ScenaristScenario = {
  id: 'success',
  name: 'Payment Success',
  mocks: [{
    method: 'POST',
    url: 'https://api.stripe.com/v1/charges',
    response: { status: 200, body: { id: 'ch_123', status: 'succeeded' } },
  }],
};

export const scenarios = {
  default: successScenario,
  success: successScenario,
} as const satisfies ScenaristScenarios;
```

### 2. Initialize Scenarist

Create `lib/scenarist.ts`:

```typescript
import { createScenarist } from '@scenarist/nextjs-adapter/app';
import { scenarios } from './scenarios';

export const scenarist = createScenarist({
  enabled: process.env.NODE_ENV === 'test',
  scenarios,
});
```

### 3. Create scenario endpoint

Create `app/api/__scenario__/route.ts`:

```typescript
import { scenarist } from '@/lib/scenarist';

const handler = scenarist.createScenarioEndpoint();
export const POST = handler;
export const GET = handler;
```

### 4. Write tests

Create `tests/checkout.spec.ts`:

```typescript
import { expect, withScenarios } from '@scenarist/playwright-helpers';
import { scenarios } from '../lib/scenarios';

export const test = withScenarios(scenarios);

test('successful checkout', async ({ page, switchScenario }) => {
  await switchScenario(page, 'success');
  await page.goto('/checkout');
  await page.fill('[name="amount"]', '100');
  await page.click('button[type="submit"]');

  await expect(page.locator('.success')).toBeVisible();
});
```

</TabItem>
</Tabs>

---

## Why Scenarist?

:::tip[TL;DR]
Test your real backend code (Server Components, API routes, middleware) through HTTP with unlimited scenarios. Mock only external APIs. No app restarts, no port conflicts, perfect test isolation.
:::

**The problem:** Most teams test backend logic in one of two ways:

**Unit tests:**
- ✅ Can test everything
- ❌ Require extensive mocking of framework internals (sessions, request objects, middleware)
- ❌ Create distance from production reality

**Browser tests:**
- ✅ Execute real code without mocks
- ❌ Too slow for comprehensive scenario coverage
- ❌ Limited to happy path only

**Scenarist fills this gap:**
- ✅ **Your backend executes:** API routes, Server Components, middleware chains, validation logic
- ✅ **External APIs mocked:** Stripe, Auth0, SendGrid (via MSW)
- ✅ **Unlimited scenarios:** Test success, errors, edge cases—all in parallel
- ✅ **Instant switching:** No app restarts, no port conflicts
- ✅ **Test isolation:** Each test gets unique ID for parallel execution

**Key features:**
- **Ephemeral endpoints:** Scenario switching only active when `enabled: true` (zero production overhead)
- **Test isolation:** Unique test IDs enable parallel execution without interference
- **Type-safe helpers:** Playwright integration with autocomplete and automatic test ID management
- **Framework-agnostic:** Express, Next.js (Pages + App Router), Fastify, Hono, Remix, and SvelteKit

---

## Playwright Integration with Type Safety

Scenarist includes **first-class Playwright support** with helpers that eliminate boilerplate and guarantee test isolation:

**Without helpers:**
```typescript
const testId = `test-premium-${Date.now()}`;
const response = await page.request.post('http://localhost:3000/api/__scenario__', {
  headers: { 'x-test-id': testId },
  data: { scenario: 'premiumUser' },
});
expect(response.status()).toBe(200);
await page.setExtraHTTPHeaders({ 'x-test-id': testId });
```

**With helpers:**
```typescript
import { test, expect } from '@scenarist/playwright-helpers';
await switchScenario(page, 'premiumUser');
```

**Type-Safe Scenario IDs** - Get autocomplete and compile-time validation:

```typescript
// Define scenarios once
const scenarios = {
  cartWithState: { id: 'cartWithState', name: 'Cart with State', ... },
  premiumUser: { id: 'premiumUser', name: 'Premium User', ... },
} as const satisfies ScenaristScenarios;

// Create typed test object
export const test = withScenarios(scenarios);

// TypeScript autocomplete in tests
test('my test', async ({ page, switchScenario }) => {
  await switchScenario(page, 'cartWithState'); // ✅ Autocomplete works!
  await switchScenario(page, 'typo');          // ❌ TypeScript error
});
```

**Guaranteed Test Isolation** - Unique test IDs prevent collisions in parallel execution (uses `crypto.randomUUID()` per test).

**Easy Composition** - Extend with your existing Playwright fixtures:

```typescript
export const test = withScenarios(scenarios).extend<MyFixtures>({
  authenticatedPage: async ({ page }, use) => { /* your fixture */ },
  database: async ({}, use) => { /* your fixture */ },
});
```

[Learn more about Playwright helpers →](https://github.com/citypaul/scenarist/tree/main/packages/playwright-helpers)

---

## How Scenarist Compares

This table shows what gets **real execution** (✅), what requires **painful workarounds** (⚠️), and what **can't be tested** (❌) in each approach:

### The Standard Approach (and Where It Falls Short)

| What You Test | Jest/Vitest | Playwright/Cypress | **Scenarist + Playwright** |
|---------------|-------------|-------------------|----------------------------|
| **Business Logic** | ✅ Functions in isolation | ❌ Can't test multiple scenarios | ✅ **All scenarios through HTTP** |
| **Server-Side Context** | ⚠️ Can mock, but painful | ❌ Backend mocked away | ✅ **Real sessions, real context** |
| **Middleware Chains** | ⚠️ Can mock, but complex | ❌ Never execute | ✅ **Real execution as integrated flow** |
| **Validation Logic** | ✅ Individual validators | ❌ Not tested with HTTP layer | ✅ **Through full request flow** |
| **Server Components** | ⚠️ Can test, but very painful | ❌ Not tested | ✅ **Real rendering with server context** |
| **Error Scenarios** | ✅ Unlimited (with mocking) | ❌ Only happy path | ✅ **All scenarios in browser** |
| **User Journey** | ⚠️ Can mock, but fragile | ✅ Happy path only | ✅ **All scenarios as real journeys** |
| **External APIs** | ⚠️ Mock at code level | Manual per-test setup | ✅ **Scenario-based (MSW)** |
| **Multiple Scenarios** | ✅ Unlimited (with mocks) | ❌ Just 1-2 (happy paths) | ✅ **Unlimited in browser** |
| **Test Speed** | ✅ Very fast | ⚠️ Moderate | ✅ **Fast** |

:::tip[The Gap Scenarist Fills]

**What teams do today:**
- Unit tests → CAN test everything, but requires extensive mocking at code level (creates gap between tests and reality)
- Browser tests → Real execution without mocks, but limited to happy path only

**The gap:** Mocking sessions, auth, request objects, middleware in unit tests is painful and creates distance from production. Those mocks can hide bugs that only surface in real user journeys.

**Why the gap exists:** Testing multiple scenarios in browser-based tests requires complex per-test mocking setup OR impractical server restarts OR hitting real external APIs (slow/flaky).

**How Scenarist fills it:** Test all scenarios through real HTTP requests with real server execution (no code-level mocking), while mocking only external APIs. Your code runs exactly like production, but with controllable external dependencies.
:::

---

## Frequently Asked Questions

<details>
<summary><strong>How is this different from unit tests with mocks?</strong></summary>

Unit tests CAN test backend logic, but require extensive mocking of framework internals (request/response objects, sessions, middleware context). This creates distance from production reality. Scenarist tests your code through real HTTP requests with real server-side context—no framework mocking needed.

</details>

<details>
<summary><strong>How is this different from E2E tests?</strong></summary>

Traditional E2E tests are too slow for testing multiple scenarios (error cases, edge cases, different user states). Scenarist runs all scenarios in parallel against the same server process with instant switching—no app restarts, no port conflicts.

</details>

<details>
<summary><strong>What gets mocked vs. what executes?</strong></summary>

**Your code executes:** API routes, Server Components, middleware chains, validation logic, database queries

**External APIs are mocked:** Stripe, Auth0, SendGrid, or any third-party API you don't control

</details>

<details>
<summary><strong>Does this work with Server Components?</strong></summary>

Yes! Next.js Server Components render normally with Scenarist. Your data fetching, logic, and rendering all execute—only external API calls are mocked. No Jest configuration pain.

</details>

<details>
<summary><strong>Can tests run in parallel?</strong></summary>

Yes. Each test gets a unique test ID, enabling perfect isolation. Run hundreds of tests concurrently against the same server with zero interference.

</details>

<details>
<summary><strong>Do I need to restart my app per scenario?</strong></summary>

No. Scenarios switch instantly at runtime via the `switchScenario()` helper. Same server, same process, different external API responses.

</details>

<details>
<summary><strong>What if my test uses page.request.post()?</strong></summary>

Use the `withScenarios()` helper to get automatic test ID propagation:
```typescript
export const test = withScenarios(scenarios);
```

For manual `page.request` calls, the helper returns the test ID so you can include it explicitly in headers.

</details>

<details>
<summary><strong>How do I debug failed tests?</strong></summary>

Enable MSW request logging:
```typescript
server.events.on('request:start', ({ request }) => {
  console.log('[MSW]', request.method, request.url);
});
```

Check active scenario:
```typescript
const response = await page.request.get('http://localhost:3000/__scenario__');
console.log(await response.json());
```

</details>

---

## Get Started

<CardGrid>
  <Card title="Quick Start" icon="rocket">
    Framework-agnostic 5-minute guide. Works with Express, Next.js, Fastify, Hono, Remix, and any Node.js framework.

    [Get Started →](/introduction/quick-start)
  </Card>
  <Card title="Playwright Helpers" icon="approve-check">
    Type-safe scenario switching with automatic test ID management. Guaranteed test isolation for parallel execution.

    [Playwright Guide →](https://github.com/citypaul/scenarist/tree/main/packages/playwright-helpers)
  </Card>
  <Card title="Express Setup" icon="seti:nodejs">
    REST APIs, GraphQL servers, microservices. Zero boilerplate with AsyncLocalStorage.

    [Express Guide →](/frameworks/express/getting-started)
  </Card>
  <Card title="Next.js Setup" icon="seti:next">
    Test Server Components, Server Actions, and API routes. Supports Pages and App Router.

    [Next.js Guide →](/frameworks/nextjs/getting-started)
  </Card>
  <Card title="Example Apps" icon="open-book">
    Explore complete working examples with comprehensive test suites.

    [View Examples →](https://github.com/citypaul/scenarist/tree/main/apps)
  </Card>
</CardGrid>
