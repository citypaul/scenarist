---
title: Test Complete User Journeys in the Browser
description: Full-stack integration testing with runtime scenario management
template: splash
hero:
  tagline: Test shopping carts, checkout flows, and multi-step journeys with different backend states. Switch scenarios instantly without restarting your app. Works with Next.js, Express, Remix, and any Node.js framework.
  image:
    file: ../../assets/houston.webp
  actions:
    - text: Get Started
      link: /introduction/quick-start
      icon: right-arrow
      variant: primary
    - text: View on GitHub
      link: https://github.com/citypaul/scenarist
      icon: external
---

import { Card, CardGrid } from '@astrojs/starlight/components';

## Your Backend Code Actually Runs

**Unlike pure mocking solutions, Scenarist tests your real application logic.** Your Server Components execute, your API routes process requests, your business logic validates data. Only external API calls (Stripe, SendGrid, etc.) are mocked. This means you're testing the actual code that runs in production, not just mock responses.

:::tip[The Critical Difference]
**Traditional MSW approach:** Mock everything â†’ Your backend never runs â†’ You're testing mocks, not your code

**Scenarist approach:** Mock only external APIs â†’ Your backend runs normally â†’ You're testing real application behavior
:::

Works with **Express**, **Next.js** (Pages + App Router), **Fastify**, **Hono**, **Remix**, and **SvelteKit**.

---

## Why Scenarist?

| Feature | Jest/Vitest | Playwright Alone | MSW Alone | Cypress | **Scenarist + Playwright** |
|---------|-------------|------------------|-----------|---------|----------------------------|
| **Test Type** | Unit tests | E2E tests | HTTP mocking | E2E tests | **Full-stack integration** |
| **Your Backend Runs** | N/A (no server) | âš ï¸ OptionalÂ¹ | âŒ Never runs | âŒ Stubs only | âœ… **Always executes** |
| **Server Components** | âŒ Can't test | âš ï¸ If backend runsÂ¹ | âŒ Never execute | âŒ Not supported | âœ… **Real execution** |
| **Full User Journeys** | âŒ No browser | âœ… Yes | âŒ No browser | âœ… Yes | âœ… **Yes** |
| **Change Scenarios** | N/A | Restart appÂ² | Restart app | Restart tests | âœ… **Instant switching** |
| **Parallel Tests** | âœ… Fast | âœ… Yes | âŒ Shared stateÂ³ | âš ï¸ Limited | âœ… **Perfect isolation** |
| **Test Speed** | âœ… Instant | âš ï¸ SlowÂ²â´ | Slow (restarts) | Slow | âœ… **Fast** |
| **State Management** | N/A | Manual setup | Manual setup | Manual setup | âœ… **Built-in capture** |

:::tip[Why This Matters]
**Jest/Vitest**: Can't test Server Components or browser flows
**Playwright alone**: Either slow (real backend with restarts) or your backend never runs (mocked)
**MSW alone**: Backend never executesâ€”you're testing mock responses, not your code
**Cypress**: Stubs everythingâ€”Server Components never render, validation never runs

**Scenarist + Playwright**: Real backend execution + instant scenario switching + built-in state = fast integration tests
:::

<small>Â¹Playwright *can* run with real backend, but requires app restart per scenario (slow)
Â²Changing scenarios = restart app = slow feedback loop
Â³Shared MSW handlers cause test pollution and flaky tests
â´Fast if mocking backend (but then backend doesn't run)</small>

## The E2E Testing Problem

<CardGrid stagger>
  <Card title="âŒ App Restart Hell" icon="refresh">
    Want to test checkout with payment errors? Restart your entire app. Precious development time wasted per scenario.
  </Card>
  <Card title="âŒ Test Pollution" icon="error">
    Shared MSW handlers cause flaky tests. Shopping cart from test A appears in test B.
  </Card>
  <Card title="âŒ Sequential Execution" icon="warning">
    Can't run parallel tests with different backend states. Test suites take hours.
  </Card>
  <Card title="âŒ Scattered Mocks" icon="puzzle">
    Copy-paste cart setup across dozens of test files. Change one field, update every file.
  </Card>
</CardGrid>

---

## The Scenarist Solution

<CardGrid stagger>
  <Card title="âœ… Complete Journeys" icon="rocket">
    **Test multi-step flows end-to-end in one test.** Shopping cart â†’ Checkout â†’ Payment â†’ Confirmation. Your Server Components execute, your validation runs, your error handling gets tested.
  </Card>
  <Card title="âœ… Instant Switching" icon="setting">
    **Change backend states instantly without app restarts.** Switch from "payment success" to "payment error" in milliseconds. Dramatically faster test suites.
  </Card>
  <Card title="âœ… Perfect Isolation" icon="approve-check">
    **Every test gets isolated scenario and state.** Run large test suites concurrently without conflicts. Test shopping cart in 100 parallel tests with different items.
  </Card>
  <Card title="âœ… Centralized Scenarios" icon="star">
    **Define complete flows once, reuse everywhere.** Single source of truth for checkout journey. Change one scenario file, all tests update automatically.
  </Card>
</CardGrid>

## How It Works

```mermaid
%%{init: {'theme':'base', 'themeVariables': { 'fontSize':'18px'}}}%%
graph TB
    subgraph test["ğŸ§ª TEST ENVIRONMENT"]
        browser["ğŸŒ Browser<br/>Playwright"]
        backend["âš™ï¸ YOUR BACKEND<br/>âœ… Runs Normally<br/><br/>Server Components<br/>API Routes<br/>Business Logic"]
        mock["ğŸ­ SCENARIST<br/>MSW Mock Layer<br/><br/>Intercepts External APIs<br/>Returns Test Data"]
        external["ğŸš« External APIs<br/>Stripe, Payment Gateways<br/><br/>Never Reached"]

        browser -->|"Your API Request"| backend
        backend -->|"External API Call"| mock
        mock -.->|"âŒ Blocked"| external
    end

    style test fill:#f9fafb,stroke:#374151,stroke-width:2px
    style browser fill:#dbeafe,stroke:#2563eb,stroke-width:2px
    style backend fill:#d1fae5,stroke:#059669,stroke-width:3px
    style mock fill:#fed7aa,stroke:#ea580c,stroke-width:2px
    style external fill:#fecaca,stroke:#dc2626,stroke-width:2px,stroke-dasharray: 5 5
```

<CardGrid>
  <Card title="âœ… Your Backend Runs" icon="approve-check">
    **Your actual application code executes:**
    - Server Components render with real data flow
    - API route handlers process requests
    - Business logic validates and transforms data
    - Error handling executes and gets tested
    - Database queries run (against test DB)

    **You're testing real application behavior, not mock responses.**
  </Card>

  <Card title="ğŸ­ Only External APIs Mocked" icon="warning">
    **Scenarist intercepts outbound calls:**
    - Stripe payment processing â†’ test response
    - SendGrid email sending â†’ test confirmation
    - Third-party APIs â†’ test data

    **Your code makes real HTTP calls, they're just intercepted at the network layer.**
  </Card>
</CardGrid>

:::note[Why This Matters]
Traditional E2E testing with pure MSW means your backend never runsâ€”you're testing mock responses, not your actual code. **Scenarist is different:** your Next.js Server Components execute, your Express routes process requests, your validation logic runs. The only things mocked are external dependencies you don't control (payment gateways, email services, etc.).

This gives you **true integration testing** with the speed and reliability of unit tests.
:::

## Quick Example

```typescript
// Define scenario once
export const checkoutScenario = {
  mocks: [
    { method: 'GET', url: '/api/products', response: { products: [...] } },
    { method: 'POST', url: '/api/cart/add', captureState: { 'cart[]': 'body.item' } },
    { method: 'GET', url: '/api/cart', response: { items: '{{state.cart}}' } },
    { method: 'POST', url: '/api/checkout', response: { success: true } },
  ]
};

// Test complete journey
test('checkout flow', async ({ page }) => {
  await switchScenario(page, 'checkout-success');

  await page.goto('/products');
  await page.click('[data-product="1"]');  // Your backend runs
  await page.goto('/cart');                 // State captured & injected
  await page.click('Checkout');             // Validation executes

  await expect(page.locator('.success')).toBeVisible();
});

// Switch scenarios instantly
test('payment error', async ({ page }) => {
  await switchScenario(page, 'payment-error');  // No restart needed
  // ... same test, different backend behavior
});
```

**What's happening:** Your Next.js Server Components render, your API routes validate data, your error handling executes. Only external API calls (Stripe, etc.) are mocked.

## Get Started

<CardGrid>
  <Card title="Express APIs" icon="seti:nodejs">
    REST APIs, GraphQL servers, microservices. Zero boilerplate with AsyncLocalStorage.

    [Get Started â†’](/frameworks/express/getting-started)
  </Card>
  <Card title="Next.js (Pages + App Router)" icon="seti:next">
    Full-stack testing with Server Components, Server Actions, and API routes.

    [Get Started â†’](/frameworks/nextjs/pages/getting-started)
  </Card>
  <Card title="Any Node.js Framework" icon="rocket">
    Fastify, Hono, Remix, SvelteKit, tRPC. Hexagonal architecture means framework-agnostic core.

    [Learn More â†’](/concepts/scenarios)
  </Card>
  <Card title="Core Capabilities" icon="star">
    Dynamic matching, response sequences, stateful mocks, test isolation.

    [View Features â†’](/concepts/scenarios)
  </Card>
</CardGrid>
