---
title: Scenarist
description: Test your backend through real HTTP requests with multiple scenarios—without mocking framework internals or waiting for E2E tests. Faster than E2E. More realistic than unit tests.
template: splash
hero:
  title: The Hardest Part of Testing? The HTTP Boundary
  tagline: Unit tests mock framework internals. E2E tests are too slow for all scenarios. Test your real backend code through HTTP with unlimited scenarios—no framework mocking, no app restarts.
  image:
    file: ../../assets/hero-illustration.svg
    alt: Illustration showing the gap between unit tests with mocks and slow E2E tests
  actions:
    - text: Get Started
      link: /introduction/quick-start
      icon: right-arrow
      variant: primary
    - text: Why Scenarist?
      link: /introduction/why-scenarist
      icon: open-book
      variant: secondary
---

import { Card, CardGrid, Tabs, TabItem } from '@astrojs/starlight/components';

:::tip[The Testing Gap]
**Unit tests:** Fast but require mocking Request objects, cookies, middleware chains—creating distance from production reality.

**E2E tests:** Production-like but too slow for comprehensive scenario coverage (error cases, edge cases, different user states).

**Scenarist:** Test real backend code through HTTP with multiple scenarios. Faster than E2E, more realistic than unit tests.
:::

**What executes:** Server Components, API routes, middleware chains, validation logic—all your backend code runs for real.

**What's mocked:** Only external APIs (Stripe, Auth0, SendGrid) via MSW. No mocking framework internals.

**Works everywhere:** Express, Next.js (Pages + App Router), Hono, Fastify, Remix, and any Node.js framework.

---

## Quick Example

**See it in action:** Choose your framework below to see a complete working example in 4 steps.

---

<Tabs>
<TabItem label="Express" icon="seti:nodejs">

**File structure:**
```
src/
├── scenarios.ts       ← 1. Define scenarios
├── setup.ts          ← 2. Initialize Scenarist
└── app.ts           ← 3. Add middleware
tests/
└── checkout.spec.ts  ← 4. Write tests
```

---

### 1. Define scenarios

Create `src/scenarios.ts`:

```typescript
import type { ScenaristScenario, ScenaristScenarios } from '@scenarist/express-adapter';

const successScenario: ScenaristScenario = {
  id: 'success',
  name: 'Payment Success',
  mocks: [{
    method: 'POST',
    url: 'https://api.stripe.com/v1/charges',
    response: { status: 200, body: { id: 'ch_123', status: 'succeeded' } },
  }],
};

export const scenarios = {
  default: successScenario,
  success: successScenario,
} as const satisfies ScenaristScenarios;
```

### 2. Initialize Scenarist

Create `src/setup.ts`:

```typescript
import { createScenarist } from '@scenarist/express-adapter';
import { scenarios } from './scenarios';

export const scenarist = createScenarist({
  enabled: process.env.NODE_ENV === 'test',
  scenarios,
});
```

### 3. Add middleware

In your `src/app.ts`:

```typescript
import express from 'express';
import { scenarist } from './setup';

const app = express();
app.use(express.json());

// Add Scenarist middleware
app.use(scenarist.middleware);

// Your routes work normally
app.post('/api/checkout', async (req, res) => {
  // Your validation runs
  // External API calls are mocked
  // Your business logic executes
});

export default app;
```

### 4. Write tests

Create `tests/checkout.spec.ts`:

```typescript
import { expect, withScenarios } from '@scenarist/playwright-helpers';
import { scenarios } from '../src/scenarios';

export const test = withScenarios(scenarios);

test('successful checkout', async ({ page, switchScenario }) => {
  await switchScenario(page, 'success');
  await page.goto('/checkout');
  await page.fill('[name="amount"]', '100');
  await page.click('button[type="submit"]');

  await expect(page.locator('.success')).toBeVisible();
});
```

</TabItem>

<TabItem label="Next.js (Pages)" icon="seti:next">

**File structure:**
```
lib/
├── scenarios.ts       ← 1. Define scenarios
└── scenarist.ts      ← 2. Initialize Scenarist
pages/api/
└── __scenario__.ts   ← 3. Create endpoint
tests/
└── checkout.spec.ts  ← 4. Write tests
```

---

### 1. Define scenarios

Create `lib/scenarios.ts`:

```typescript
import type { ScenaristScenario, ScenaristScenarios } from '@scenarist/nextjs-adapter/pages';

const successScenario: ScenaristScenario = {
  id: 'success',
  name: 'Payment Success',
  mocks: [{
    method: 'POST',
    url: 'https://api.stripe.com/v1/charges',
    response: { status: 200, body: { id: 'ch_123', status: 'succeeded' } },
  }],
};

export const scenarios = {
  default: successScenario,
  success: successScenario,
} as const satisfies ScenaristScenarios;
```

### 2. Initialize Scenarist

Create `lib/scenarist.ts`:

```typescript
import { createScenarist } from '@scenarist/nextjs-adapter/pages';
import { scenarios } from './scenarios';

export const scenarist = createScenarist({
  enabled: process.env.NODE_ENV === 'test',
  scenarios,
});
```

### 3. Create scenario endpoint

Create `pages/api/__scenario__.ts`:

```typescript
import { scenarist } from '@/lib/scenarist';

export default scenarist.createScenarioEndpoint();
```

### 4. Write tests

Create `tests/checkout.spec.ts`:

```typescript
import { expect, withScenarios } from '@scenarist/playwright-helpers';
import { scenarios } from '../lib/scenarios';

export const test = withScenarios(scenarios);

test('successful checkout', async ({ page, switchScenario }) => {
  await switchScenario(page, 'success');
  await page.goto('/checkout');
  await page.fill('[name="amount"]', '100');
  await page.click('button[type="submit"]');

  await expect(page.locator('.success')).toBeVisible();
});
```

</TabItem>

<TabItem label="Next.js (App Router)" icon="seti:next">

**File structure:**
```
lib/
├── scenarios.ts       ← 1. Define scenarios
└── scenarist.ts      ← 2. Initialize Scenarist
app/api/__scenario__/
└── route.ts          ← 3. Create endpoint
tests/
└── checkout.spec.ts  ← 4. Write tests
```

---

### 1. Define scenarios

Create `lib/scenarios.ts`:

```typescript
import type { ScenaristScenario, ScenaristScenarios } from '@scenarist/nextjs-adapter/app';

const successScenario: ScenaristScenario = {
  id: 'success',
  name: 'Payment Success',
  mocks: [{
    method: 'POST',
    url: 'https://api.stripe.com/v1/charges',
    response: { status: 200, body: { id: 'ch_123', status: 'succeeded' } },
  }],
};

export const scenarios = {
  default: successScenario,
  success: successScenario,
} as const satisfies ScenaristScenarios;
```

### 2. Initialize Scenarist

Create `lib/scenarist.ts`:

```typescript
import { createScenarist } from '@scenarist/nextjs-adapter/app';
import { scenarios } from './scenarios';

export const scenarist = createScenarist({
  enabled: process.env.NODE_ENV === 'test',
  scenarios,
});
```

### 3. Create scenario endpoint

Create `app/api/__scenario__/route.ts`:

```typescript
import { scenarist } from '@/lib/scenarist';

const handler = scenarist.createScenarioEndpoint();
export const POST = handler;
export const GET = handler;
```

### 4. Write tests

Create `tests/checkout.spec.ts`:

```typescript
import { expect, withScenarios } from '@scenarist/playwright-helpers';
import { scenarios } from '../lib/scenarios';

export const test = withScenarios(scenarios);

test('successful checkout', async ({ page, switchScenario }) => {
  await switchScenario(page, 'success');
  await page.goto('/checkout');
  await page.fill('[name="amount"]', '100');
  await page.click('button[type="submit"]');

  await expect(page.locator('.success')).toBeVisible();
});
```

</TabItem>
</Tabs>

---

## What's Actually Hard About Testing the HTTP Boundary?

Testing Server Components, API routes, and middleware chains in isolation requires mocking framework internals. Here's what that looks like:

<Tabs>
<TabItem label="❌ Unit Test Pain" icon="warning">

**Testing Next.js Server Components with unit tests:**

```typescript
// You have to mock Next.js framework internals
const mockCookies = {
  get: jest.fn((name) => name === 'tier' ? 'premium' : null),
};
const mockHeaders = {
  get: jest.fn((name) => name === 'x-user-id' ? '123' : null),
};

jest.mock('next/headers', () => ({
  cookies: () => mockCookies,
  headers: () => mockHeaders,
}));

// Now test your component with fake framework objects
// Any change to Next.js internals breaks your tests
// Mocks don't match production Request behavior
```

**The pain:**
- Mock setup is brittle and framework-specific
- Mocks create distance from production reality
- Middleware chains don't execute (you're testing in isolation)
- Session logic doesn't run (mocked away)
- Each scenario needs duplicate mock setup

</TabItem>

<TabItem label="✅ Scenarist Approach" icon="approve-check">

**Testing the same code with Scenarist:**

```typescript
// Define scenario once
const premiumScenario = {
  id: 'premium',
  name: 'Premium User',
  mocks: [{
    method: 'GET',
    url: 'https://auth.external-api.com/session',
    response: { status: 200, body: { tier: 'premium' } }
  }]
};

// Test with real HTTP, real Next.js, real everything
test('premium user sees discount', async ({ page, switchScenario }) => {
  await switchScenario(page, 'premium');
  await page.goto('/dashboard');

  // Real Server Component renders
  // Real cookies() and headers() from Next.js
  // Real middleware chain executes
  // Only external API is mocked
});
```

**The difference:**
- No framework mocking required
- Server Component renders for real
- Middleware chains execute
- Session logic runs
- One scenario definition, unlimited tests

</TabItem>
</Tabs>

[Read more about why this is hard →](/introduction/why-scenarist)

---

## When to Use Scenarist

### ✅ Good Use Cases

**Local development with multiple scenarios:**
- Testing premium vs free user features
- Error states and edge cases
- Multi-step flows with session state
- Different permission levels

**Single-instance CI pipelines:**
- GitHub Actions with single worker
- GitLab CI with one instance
- Local CI servers (Jenkins, TeamCity)

**Integration tests needing real HTTP:**
- Server Components that need real rendering
- Middleware chains that need real execution
- API routes with complex validation
- Session-based authentication flows

### ⚠️ Limitations

**Single-instance deployments only:**
Scenarist uses in-memory state to map test IDs to scenarios. This works perfectly for:
- Local development
- Single-instance CI (most common)
- Tests against `localhost`

This does NOT work for:
- Load-balanced deployments
- Testing production environments
- Distributed testing across multiple instances

**Not a replacement for all E2E:**
Use Scenarist for comprehensive scenario coverage. Still use a few E2E tests for:
- Critical happy paths against real external APIs
- Production-like environment verification
- Contract validation with third-party services

### ❌ When NOT to Use

- **You need true E2E with real external APIs** - Scenarist mocks external services
- **Your app has no external dependencies** - Unnecessary complexity
- **You're testing frontend-only apps** - Scenarist is for backend HTTP behavior
- **You need load-balanced deployment testing** - Current architecture requires single instance

[Understand the trade-offs →](/introduction/why-scenarist#trade-offs--when-to-consider-alternatives)

---

## Why Scenarist?

:::tip[TL;DR]
Test your real backend code (Server Components, API routes, middleware) through HTTP with unlimited scenarios. Mock only external APIs. No app restarts, no port conflicts, perfect test isolation.
:::

**Scenarist fills the testing gap:**
- ✅ **Your backend executes:** API routes, Server Components, middleware chains, validation logic
- ✅ **External APIs mocked:** Stripe, Auth0, SendGrid (via MSW)
- ✅ **Unlimited scenarios:** Test success, errors, edge cases—all in parallel
- ✅ **Instant switching:** No app restarts, no port conflicts
- ✅ **Test isolation:** Each test gets unique ID for parallel execution

**Key features:**
- **Ephemeral endpoints:** Scenario switching only active when `enabled: true` (zero production overhead)
- **Test isolation:** Unique test IDs enable parallel execution without interference
- **Type-safe helpers:** Playwright integration with autocomplete and automatic test ID management
- **Framework-agnostic:** Express, Next.js (Pages + App Router), Fastify, Hono, Remix, and SvelteKit

---

## Playwright Integration with Type Safety

Scenarist includes **first-class Playwright support** with helpers that eliminate boilerplate and guarantee test isolation:

**Without helpers:**
```typescript
const testId = `test-premium-${Date.now()}`;
const response = await page.request.post('http://localhost:3000/api/__scenario__', {
  headers: { 'x-test-id': testId },
  data: { scenario: 'premiumUser' },
});
expect(response.status()).toBe(200);
await page.setExtraHTTPHeaders({ 'x-test-id': testId });
```

**With helpers:**
```typescript
import { test, expect } from '@scenarist/playwright-helpers';
await switchScenario(page, 'premiumUser');
```

**Type-Safe Scenario IDs** - Get autocomplete and compile-time validation:

```typescript
// Define scenarios once
const scenarios = {
  cartWithState: { id: 'cartWithState', name: 'Cart with State', ... },
  premiumUser: { id: 'premiumUser', name: 'Premium User', ... },
} as const satisfies ScenaristScenarios;

// Create typed test object
export const test = withScenarios(scenarios);

// TypeScript autocomplete in tests
test('my test', async ({ page, switchScenario }) => {
  await switchScenario(page, 'cartWithState'); // ✅ Autocomplete works!
  await switchScenario(page, 'typo');          // ❌ TypeScript error
});
```

**Guaranteed Test Isolation** - Unique test IDs prevent collisions in parallel execution (uses `crypto.randomUUID()` per test).

**Easy Composition** - Extend with your existing Playwright fixtures:

```typescript
export const test = withScenarios(scenarios).extend<MyFixtures>({
  authenticatedPage: async ({ page }, use) => { /* your fixture */ },
  database: async ({}, use) => { /* your fixture */ },
});
```

[Learn more about Playwright helpers →](https://github.com/citypaul/scenarist/tree/main/packages/playwright-helpers)

---

## How Scenarist Compares

| What You're Testing | Unit Tests (Jest/Vitest) | E2E Tests (Playwright) | **Scenarist + Playwright** |
|---------------------|-------------------------|------------------------|----------------------------|
| **Framework Mocking** | ⚠️ Mock Request, cookies, headers | ✅ No mocking needed | ✅ **No mocking needed** |
| **Middleware Chains** | ❌ Mocked away (isolated) | ✅ Execute | ✅ **Execute** |
| **Server Components** | ⚠️ Painful framework mocking | ❌ Can't test multiple scenarios | ✅ **Multiple scenarios** |
| **Session Logic** | ⚠️ Mock session store | ✅ Real sessions | ✅ **Real sessions** |
| **Multiple Scenarios** | ✅ Unlimited (with mocks) | ❌ Limited (too slow) | ✅ **Unlimited, in parallel** |
| **Test Speed** | ✅ Very fast | ❌ Slow per scenario | ✅ **Fast** |
| **Parallel Execution** | ✅ Yes | ⚠️ Limited | ✅ **Perfect isolation** |
| **Production-like** | ❌ Mocks create distance | ✅ Real everything | ✅ **Real backend, mocked externals** |

:::tip[What's the Actual Difference?]

**The problem with unit tests:**
```typescript
// You mock framework internals
jest.mock('next/headers', () => ({ cookies: () => mockCookies }));
// Your code doesn't run like production
```

**The problem with E2E tests:**
- Testing multiple scenarios requires multiple test runs (each spawns new server)
- Can't test error states without hitting real APIs
- Too slow for comprehensive coverage of edge cases

**Scenarist's approach:**
```typescript
// No framework mocking, just external API mocking
const scenario = { mocks: [{ url: 'external-api.com', response: {...} }] };
// Your code runs exactly like production
// Multiple scenarios run in parallel against same server
```
:::

---

## Frequently Asked Questions

<details>
<summary><strong>How is this different from unit tests with mocks?</strong></summary>

Unit tests CAN test backend logic, but require extensive mocking of framework internals (request/response objects, sessions, middleware context). This creates distance from production reality. Scenarist tests your code through real HTTP requests with real server-side context—no framework mocking needed.

</details>

<details>
<summary><strong>How is this different from E2E tests?</strong></summary>

Traditional E2E tests are too slow for testing multiple scenarios (error cases, edge cases, different user states). Scenarist runs all scenarios in parallel against the same server process with instant switching—no app restarts, no port conflicts.

</details>

<details>
<summary><strong>What gets mocked vs. what executes?</strong></summary>

**Your code executes:** API routes, Server Components, middleware chains, validation logic, database queries

**External APIs are mocked:** Stripe, Auth0, SendGrid, or any third-party API you don't control

</details>

<details>
<summary><strong>Does this work with Server Components?</strong></summary>

Yes! Next.js Server Components render normally with Scenarist. Your data fetching, logic, and rendering all execute—only external API calls are mocked. No Jest configuration pain.

</details>

<details>
<summary><strong>Can tests run in parallel?</strong></summary>

Yes. Each test gets a unique test ID, enabling perfect isolation. Run hundreds of tests concurrently against the same server with zero interference.

</details>

<details>
<summary><strong>Do I need to restart my app per scenario?</strong></summary>

No. Scenarios switch instantly at runtime via the `switchScenario()` helper. Same server, same process, different external API responses.

</details>

<details>
<summary><strong>What if my test uses page.request.post()?</strong></summary>

Use the `withScenarios()` helper to get automatic test ID propagation:
```typescript
export const test = withScenarios(scenarios);
```

For manual `page.request` calls, the helper returns the test ID so you can include it explicitly in headers.

</details>

<details>
<summary><strong>How do I debug failed tests?</strong></summary>

Enable MSW request logging:
```typescript
server.events.on('request:start', ({ request }) => {
  console.log('[MSW]', request.method, request.url);
});
```

Check active scenario:
```typescript
const response = await page.request.get('http://localhost:3000/__scenario__');
console.log(await response.json());
```

</details>

---

## Get Started

<CardGrid>
  <Card title="Quick Start" icon="rocket">
    Framework-agnostic 5-minute guide. Works with Express, Next.js, Fastify, Hono, Remix, and any Node.js framework.

    [Get Started →](/introduction/quick-start)
  </Card>
  <Card title="Playwright Helpers" icon="approve-check">
    Type-safe scenario switching with automatic test ID management. Guaranteed test isolation for parallel execution.

    [Playwright Guide →](https://github.com/citypaul/scenarist/tree/main/packages/playwright-helpers)
  </Card>
  <Card title="Express Setup" icon="seti:nodejs">
    REST APIs, GraphQL servers, microservices. Zero boilerplate with AsyncLocalStorage.

    [Express Guide →](/frameworks/express/getting-started)
  </Card>
  <Card title="Next.js Setup" icon="seti:next">
    Test Server Components, Server Actions, and API routes. Supports Pages and App Router.

    [Next.js Guide →](/frameworks/nextjs/getting-started)
  </Card>
  <Card title="Example Apps" icon="open-book">
    Explore complete working examples with comprehensive test suites.

    [View Examples →](https://github.com/citypaul/scenarist/tree/main/apps)
  </Card>
</CardGrid>
