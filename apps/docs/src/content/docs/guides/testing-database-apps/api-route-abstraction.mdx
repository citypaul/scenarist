---
title: API Route Abstraction
description: Make database-heavy Next.js apps testable by adding thin HTTP layer
---

import { Aside } from '@astrojs/starlight/components';

This guide shows you how to add API routes between Server Components and your database to make Next.js apps testable with Scenarist. This approach gives you fast, parallel tests without database setup.

## Overview

The pattern is straightforward:
1. Create API routes that wrap existing database calls
2. Update Server Components to call API routes instead of database directly
3. Mock the API routes with Scenarist scenarios
4. Test with instant scenario switching

**Best for:** Teams willing to add thin HTTP layer for fast testing

## Step-by-Step Implementation

### Step 1: Create an API Route Wrapper

Wrap your existing database function in an API route:

```typescript
// app/api/products/route.ts
import { NextResponse } from 'next/server';
import { fetchProducts } from '@/lib/data'; // Your existing database function

export async function GET(request: Request) {
  try {
    const products = await fetchProducts(); // Database call stays unchanged
    return NextResponse.json(products);
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch products' },
      { status: 500 }
    );
  }
}
```

**Key points:**
- Database logic remains in `@/lib/data` (no changes)
- API route is thin wrapper (no business logic)
- Error handling stays in API route

### Step 2: Update Server Components

Change Server Components to call the API route instead of database:

```typescript
// app/products/page.tsx - Server Component
import { scenarist } from '@/lib/scenarist';

export default async function ProductsPage() {
  // ✅ Now makes HTTP request that Scenarist can intercept
  const response = await fetch('http://localhost:3000/api/products', {
    headers: scenarist.getHeaders(request),
    cache: 'no-store', // Ensure fresh data
  });

  if (!response.ok) {
    throw new Error('Failed to fetch products');
  }

  const products = await response.json();
  return <ProductList products={products} />;
}
```

<Aside type="tip">
**Why `cache: 'no-store'`?**

Next.js aggressively caches `fetch()` responses by default. Adding `cache: 'no-store'` ensures each test gets fresh mock data without stale cache interference.
</Aside>

### Step 3: Mock the API Route

Define scenarios that mock the API route responses:

```typescript
// lib/scenarios.ts
export const defaultScenario: ScenaristScenario = {
  id: 'default',
  name: 'Happy Path Products',
  mocks: [
    {
      method: 'GET',
      url: 'http://localhost:3000/api/products',
      response: {
        status: 200,
        body: [
          { id: 1, name: 'Product A', price: 99.99 },
          { id: 2, name: 'Product B', price: 149.99 },
        ],
      },
    },
  ],
};

export const outOfStockScenario: ScenaristScenario = {
  id: 'outOfStock',
  name: 'Out of Stock Products',
  mocks: [
    {
      method: 'GET',
      url: 'http://localhost:3000/api/products',
      response: {
        status: 200,
        body: [
          { id: 1, name: 'Product A', price: 99.99, stock: 0 },
          { id: 2, name: 'Product B', price: 149.99, stock: 0 },
        ],
      },
    },
  ],
};
```

### Step 4: Write Playwright Tests

Test different scenarios by switching mocks:

```typescript
// tests/products.spec.ts
import { test, expect } from '@playwright/test';
import { scenaristFixtures } from '@scenarist/playwright-helpers';

const { switchScenario } = scenaristFixtures({
  testIdHeader: 'x-test-id',
  scenarioEndpoint: 'http://localhost:3000/__scenario__',
});

test.use({ ...switchScenario });

test('should show products with stock', async ({ page, switchScenario }) => {
  await switchScenario(page, 'default');
  await page.goto('/products');

  await expect(page.getByText('Product A')).toBeVisible();
  await expect(page.getByText('Product B')).toBeVisible();
  await expect(page.getByText('£99.99')).toBeVisible();
});

test('should show out of stock message', async ({ page, switchScenario }) => {
  await switchScenario(page, 'outOfStock');
  await page.goto('/products');

  await expect(page.getByText('Out of Stock')).toBeVisible({ count: 2 });
});
```

## Real-World Example: Next.js Learn Dashboard

The [Next.js Learn tutorial dashboard](https://github.com/vercel/next-learn/tree/main/dashboard/final-example) uses direct PostgreSQL access. Here's how to convert it:

**Original code (not testable with Scenarist):**

```typescript
// app/lib/data.ts
import postgres from 'postgres';
const sql = postgres(process.env.POSTGRES_URL!);

export async function fetchRevenue() {
  const data = await sql<Revenue[]>`SELECT * FROM revenue`;
  return data;
}

// app/dashboard/(overview)/page.tsx
export default async function DashboardPage() {
  const revenue = await fetchRevenue(); // Direct database call
  return <RevenueChart data={revenue} />;
}
```

**Converted (testable with Scenarist):**

```typescript
// Step 1: Add API route
// app/api/revenue/route.ts
import { fetchRevenue } from '@/lib/data';

export async function GET() {
  const revenue = await fetchRevenue(); // Still uses database internally
  return NextResponse.json(revenue);
}

// Step 2: Update Server Component
// app/dashboard/(overview)/page.tsx
import { scenarist } from '@/lib/scenarist';

export default async function DashboardPage() {
  const response = await fetch('http://localhost:3000/api/revenue', {
    headers: scenarist.getHeaders(request),
    cache: 'no-store',
  });
  const revenue = await response.json();
  return <RevenueChart data={revenue} />;
}

// Step 3: Mock the API route
// lib/scenarios.ts
export const highRevenueScenario: ScenaristScenario = {
  id: 'highRevenue',
  mocks: [{
    method: 'GET',
    url: 'http://localhost:3000/api/revenue',
    response: {
      status: 200,
      body: [
        { month: 'Jan', revenue: 50000 },
        { month: 'Feb', revenue: 75000 },
        { month: 'Mar', revenue: 100000 },
      ],
    },
  }],
};

export const lowRevenueScenario: ScenaristScenario = {
  id: 'lowRevenue',
  mocks: [{
    method: 'GET',
    url: 'http://localhost:3000/api/revenue',
    response: {
      status: 200,
      body: [
        { month: 'Jan', revenue: 5000 },
        { month: 'Feb', revenue: 7500 },
        { month: 'Mar', revenue: 10000 },
      ],
    },
  }],
};
```

**Test both scenarios:**

```typescript
test('should show high revenue chart', async ({ page, switchScenario }) => {
  await switchScenario(page, 'highRevenue');
  await page.goto('/dashboard');
  await expect(page.getByText('£100,000')).toBeVisible();
});

test('should show low revenue chart', async ({ page, switchScenario }) => {
  await switchScenario(page, 'lowRevenue');
  await page.goto('/dashboard');
  await expect(page.getByText('£10,000')).toBeVisible();
});
```

## Common Pitfalls

### Pitfall 1: Forgetting `cache: 'no-store'`

```typescript
// ❌ WRONG - Next.js caches aggressively
const response = await fetch('http://localhost:3000/api/products');

// ✅ CORRECT - Disable cache for test scenarios
const response = await fetch('http://localhost:3000/api/products', {
  cache: 'no-store',
});
```

### Pitfall 2: Using Relative URLs

```typescript
// ❌ WRONG - Relative URL won't work from Server Components
const response = await fetch('/api/products');

// ✅ CORRECT - Full URL with localhost
const response = await fetch('http://localhost:3000/api/products', {
  headers: scenarist.getHeaders(request),
});
```

<Aside type="caution">
Next.js Server Components run on the server, not the browser. Relative URLs like `/api/products` fail because there's no "current origin" context. Always use full URLs with `http://localhost:PORT`.
</Aside>

### Pitfall 3: Not Propagating Test ID Headers

```typescript
// ❌ WRONG - Scenarist won't know which test this belongs to
const response = await fetch('http://localhost:3000/api/products');

// ✅ CORRECT - Include scenarist headers
const response = await fetch('http://localhost:3000/api/products', {
  headers: scenarist.getHeaders(request),
  cache: 'no-store',
});
```

## Performance Impact

**Short answer: No, most RSC advantages are preserved, with ~5-10ms added latency.**

### What React Server Components Give You:

1. **Server-side rendering** (no client JavaScript)
2. **Direct backend access** (database in same process)
3. **Zero client bundle size**
4. **Streaming** (show data as it arrives)
5. **Reduced round trips** (server makes backend calls without browser involvement)

### With API Route Abstraction:

**✅ PRESERVED:**
- Server-side rendering (component still runs on server, not client)
- Zero client bundle (still no client JavaScript)
- No browser round trips (fetch() happens server-side)
- Parallel data fetching (can still make multiple fetches in parallel on server)

**❌ LOST:**
- **Streaming for large datasets** - Biggest loss
  - Direct DB: Can stream results as they arrive (~10ms for first results)
  - API route: Must wait for complete JSON response (~100ms for full payload)
- **Direct connection efficiency** - Extra network stack traversal
- **~5-10ms latency per request** - Typical overhead

### Performance Breakdown:

**Direct Database Access (RSC as designed):**
```typescript
// Server Component queries database directly
const products = await db.products.findMany();
// Latency: ~2-5ms (same process, TCP socket)
```

**API Route Abstraction:**
```typescript
// Server Component → HTTP → API route → Database
const response = await fetch('http://localhost:3000/api/products');
const products = await response.json();
// Latency: ~7-15ms total
//   - HTTP round trip (localhost): ~2-3ms
//   - Database query: ~2-5ms
//   - JSON serialize/deserialize: ~2-5ms
//   - Route matching: ~1ms
```

**Added overhead: ~5-10ms for typical requests** (3-5x slower than direct access)

### Is 10ms Negligible?

**For most apps: YES**
- Typical page load: 200-500ms
- Network latency to user: 50-200ms
- 10ms = ~2-5% of total page load time
- Users won't notice

**For high-scale apps: MAYBE NOT**
- At 1000+ req/s, every millisecond counts
- Streaming large datasets is valuable
- Consider hybrid approach or traditional E2E

### Next.js Caching Can Eliminate Overhead:

```typescript
// Production: Cache responses for 60 seconds
const response = await fetch('http://localhost:3000/api/products', {
  next: { revalidate: 60 }, // Cached!
});
// First request: ~10ms
// Subsequent requests: ~0ms (served from cache)
// Can be FASTER than direct DB calls!

// Tests: Disable cache for fresh data
const response = await fetch('http://localhost:3000/api/products', {
  cache: 'no-store', // Every test gets fresh mock data
});
```

<Aside type="caution" title="Important: This Affects Production">

The API route abstraction runs in **both production and tests**. There's no way to avoid the overhead in production without branching logic (which defeats E2E testing).

**The trade-off:** ~10ms production overhead for fast, parallelizable tests. For most apps, development velocity >> marginal performance.

</Aside>

## Special Case: Authentication in Middleware

If your Next.js middleware validates sessions via database, you cannot use `fetch()` to the same app (causes infinite loop):

```typescript
// middleware.ts - BLOCKS API route abstraction
export async function middleware(request: NextRequest) {
  const session = request.cookies.get('session');

  // ❌ Database query in middleware
  const user = await db.users.findUnique({
    where: { sessionId: session?.value }
  });

  if (!user && request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.redirect(new URL('/login', request.url));
  }

  return NextResponse.next();
}
```

**Why this blocks the pattern:**
- Middleware runs FIRST (before any Server Component)
- Middleware CANNOT call fetch() to same app (infinite loop)
- Auth decision gates ALL routes

**You have three workarounds:**

### Workaround 1: JWT/Stateless Auth (Recommended)

Switch to stateless authentication where middleware doesn't need database. Middleware verifies JWT tokens cryptographically:

```typescript
// middleware.ts - No database needed!
import { jwtVerify } from 'jose';

export async function middleware(request: NextRequest) {
  const token = request.cookies.get('auth-token')?.value;

  try {
    // ✅ Cryptographic verification (no database)
    const { payload } = await jwtVerify(
      token,
      new TextEncoder().encode(process.env.JWT_SECRET)
    );

    // User ID available without database query
    const userId = payload.sub;

    return NextResponse.next();
  } catch {
    return NextResponse.redirect(new URL('/login', request.url));
  }
}
```

Then use API route abstraction for data fetching (auth is separate).

### Workaround 2: Hybrid Approach

Keep database auth in middleware, use Scenarist only for data fetching:

```typescript
// middleware.ts - Real database (as before)
export async function middleware(request: NextRequest) {
  const session = request.cookies.get('session');
  const user = await db.users.findUnique({ where: { sessionId: session?.value } });
  // ... auth logic
}

// Server Components - API routes (Scenarist mocks)
export default async function DashboardPage() {
  const response = await fetch('http://localhost:3000/api/dashboard-data', {
    headers: scenarist.getHeaders(request),
  });
  // ...
}
```

**Test setup:**
```typescript
beforeAll(async () => {
  // Seed user in real database for auth
  await db.users.create({
    data: {
      id: '123',
      sessionId: 'test-session-premium',
      email: 'premium@example.com',
      tier: 'premium',
    },
  });
});

test('premium user sees premium dashboard', async ({ page, switchScenario }) => {
  // Set session cookie - middleware validates via real database
  await page.context().addCookies([{
    name: 'session',
    value: 'test-session-premium',
    domain: 'localhost',
    path: '/',
  }]);

  // Scenarist mocks dashboard data API
  await switchScenario(page, 'premiumDashboard');

  await page.goto('/dashboard');

  // ✅ Middleware validates session via database (real)
  // ✅ Server Component fetches from API route (mocked)
  await expect(page.getByText('Premium Dashboard')).toBeVisible();
});
```

### Workaround 3: Traditional Database Seeding

Accept that the entire app needs a real database. Use database seeding for all data.

[Learn more about Testcontainers hybrid approach →](./testcontainers-hybrid)

## What You're Actually Testing

With API route abstraction, you test:
- ✅ UI renders correctly with different data
- ✅ Error states display properly
- ✅ Loading states work
- ✅ User interactions work
- ❌ NOT testing: database queries, transactions, constraints

**This is integration testing of the UI layer**, not true E2E testing of the entire stack. If you need to test database behavior, use the [Testcontainers hybrid approach](./testcontainers-hybrid).

## When to Use This Approach

**✅ Use when:**
- You want fast tests with instant scenario switching
- You can add thin API route wrappers
- You don't need to test database-specific behavior
- Parallel test execution is important
- Your database calls are in data fetching logic (not authentication)

**❌ Don't use when:**
- Database is required for authentication/authorization middleware
- You're testing database-specific behavior (transactions, constraints)
- Adding API routes would be a major architectural change
- You need to test Server Actions that mutate database state directly

## Summary

1. **Create API route wrappers** around existing database functions
2. **Update Server Components** to call API routes instead of database
3. **Mock the API routes** with Scenarist scenarios
4. **Use full URLs** (`http://localhost:3000/api/...`)
5. **Disable caching** with `cache: 'no-store'`
6. **Propagate headers** with `scenarist.getHeaders(request)`

This pattern gives you fast, parallel tests without database setup, at the cost of ~10ms production overhead per request.

## Next Steps

- [Testcontainers Hybrid Approach →](./testcontainers-hybrid) - Alternative for teams that cannot/won't add API routes
- [Next.js App Router Getting Started](/frameworks/nextjs-app-router/getting-started)
- [Next.js Pages Router Getting Started](/frameworks/nextjs-pages-router/getting-started)
