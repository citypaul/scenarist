---
title: Testing Apps with Database Access
description: How to test applications that use direct database access with Scenarist
---

import { Aside } from '@astrojs/starlight/components';

## Our Recommendation: Repository Pattern

For teams that want scalable parallel testing of real server-side code, we recommend the **repository pattern**. It abstracts database access behind interfaces and injects test implementations with test ID isolation—the same model Scenarist uses for HTTP mocking.

**Benefits:**
- True test-level parallelism (not just shard-level)
- Fast in-memory execution
- Architectural benefits that extend beyond testing (clean separation, infrastructure flexibility)

**Trade-offs:**
- Requires refactoring database access behind interfaces
- In-memory tests don't catch real database issues (mitigate with Testcontainers)

[Implement the Repository Pattern →](./repository-pattern)

<Aside type="note">
**Different constraints?** [Sequential execution](./parallelism-options#option-1-sequential-execution) works for small test suites. [Sharding](./parallelism-options#option-3-sharding-container-per-shard) provides parallelism without code changes. See the [decision guide](#quick-decision-guide) below.
</Aside>

---

## Why Database Testing Is Hard

Scenarist intercepts HTTP requests via MSW because every HTTP library eventually calls the same underlying APIs. **Databases have no equivalent universal interception point.**

Each ORM and driver is a different API surface:
- Prisma: `prisma.user.findMany()`
- Drizzle: `db.select().from(users)`
- TypeORM: `userRepository.find()`
- Raw SQL: `pg.query('SELECT * FROM users')`

There's no single place to intercept all database queries and inject test isolation.

```typescript
// ❌ Scenarist CANNOT mock this - no HTTP request
export async function fetchProducts() {
  return await db.products.findMany();  // Direct database call
}
```

**The core problem:** Scenarist isolates tests via test ID in HTTP headers. Databases have no equivalent mechanism—without isolation, parallel tests corrupt each other's data.

The repository pattern solves this by letting you inject in-memory implementations that partition data by test ID, just like Scenarist does for HTTP.

---

## Quick Decision Guide

| Your Situation | Use This |
|----------------|----------|
| Want scalable parallel tests | [Repository Pattern](./repository-pattern) |
| Need to test actual SQL queries, constraints | [Testcontainers](./testcontainers-hybrid) |
| Can't change code right now | [Sharding](./parallelism-options#option-3-sharding-container-per-shard) |
| Small test suite, prototyping | [Sequential Execution](./parallelism-options#option-1-sequential-execution) |

---

## What Scenarist Handles

| What You're Testing | Tool |
|---------------------|------|
| External HTTP APIs (Stripe, Auth0, SendGrid) | **Scenarist** |
| Business logic with database state | **Repository Pattern** |
| Actual SQL queries, constraints, transactions | **Testcontainers** |

---

## Next Steps

- [Repository Pattern Guide](./repository-pattern) — Implementation walkthrough
- [Testcontainers Hybrid](./testcontainers-hybrid) — Testing real database behavior
- [All Parallelism Options](./parallelism-options) — Detailed comparison of approaches
