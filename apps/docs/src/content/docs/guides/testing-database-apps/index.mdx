---
title: Testing Next.js Apps with Database Access
description: How to test Next.js applications that use direct database access with Scenarist
---

import { Aside } from '@astrojs/starlight/components';

<Aside type="note" title="Scenarist's Scope">

**Scenarist excels at mocking external HTTP APIs.** For apps that also access databases directly, this guide shows the recommended testing strategy combining Scenarist with database testing tools.

</Aside>

## The Problem

**Next.js apps with direct database access are not directly testable with Scenarist:**

```typescript
// ❌ Scenarist CANNOT mock this - no HTTP request
// app/lib/data.ts
import { db } from './db';

export async function fetchProducts() {
  return await db.products.findMany();
}

// app/products/page.tsx - Server Component
export default async function ProductsPage() {
  const products = await fetchProducts(); // Direct database call
  return <ProductList products={products} />;
}
```

**Why this doesn't work:**
- `db.products.findMany()` is a direct function call to the database driver
- No HTTP request is made
- MSW (which Scenarist uses) only intercepts `fetch()` calls
- Database connections use TCP sockets, not HTTP

<Aside type="caution">
Scenarist intercepts HTTP requests only. It cannot mock:
- Database calls (PostgreSQL, MongoDB, MySQL, etc.)
- File system operations (`fs.readFile`, `fs.writeFile`)
- WebSocket connections
- gRPC calls
- Direct function calls or imports
</Aside>

## Testing Approaches

Many techniques work for database testing—real test databases, in-memory databases (SQLite), seeding scripts, or container-based solutions like Testcontainers. Choose what fits your team's workflow.

### Our Recommendation: Testcontainers + Scenarist

For apps that use both databases AND external HTTP APIs, we recommend combining:
- **Testcontainers** for database testing (real PostgreSQL/MySQL in Docker containers)
- **Scenarist** for mocking external APIs (Stripe, Auth0, SendGrid)

**Key benefits:**
- ✅ No code changes required
- ✅ Tests actual database queries and migrations
- ✅ Mock external APIs with Scenarist
- ✅ Realistic integration testing

**Trade-offs:**
- ⚠️ Slower tests (container startup overhead)
- ⚠️ Docker required in CI/CD
- ⚠️ Must maintain database seeding scripts

[Learn more about Testcontainers Hybrid →](./testcontainers-hybrid)

### Alternative Approaches

Other valid database testing strategies include:
- **Real test database** with seeding scripts
- **In-memory database** (SQLite for development, real DB in CI)
- **Database mocking** at the ORM level (Prisma mock, etc.)

Use whatever approach fits your team. Scenarist handles the external API mocking regardless of how you test your database layer.

## Decision Tree

```mermaid
graph TD
    A[Does your Next.js app use direct database access?] -->|No - Uses HTTP APIs| B[✅ Use Scenarist directly]
    A -->|Yes| C[Have external API dependencies?]
    C -->|Yes| D[✅ Hybrid: Testcontainers + Scenarist]
    C -->|No| E[Use Testcontainers only]

    D --> F[Benefits:<br/>- Test real DB queries<br/>- Mock external APIs<br/>- No code changes]
    B --> G[Benefits:<br/>- Fast parallel tests<br/>- No database setup<br/>- Instant scenario switching]
```

## When to Use Each Tool

| What You're Testing | Tool to Use |
|---------------------|-------------|
| External HTTP APIs (Stripe, SendGrid) | **Scenarist** |
| Database queries | **Testcontainers** or real test database |
| File system operations | **Mock fs** or real files |

## Next Steps

- [Testcontainers Hybrid →](./testcontainers-hybrid) - Complete guide to using Testcontainers with Scenarist
- [Next.js App Router Getting Started](/frameworks/nextjs-app-router/getting-started)
- [Next.js Pages Router Getting Started](/frameworks/nextjs-pages-router/getting-started)
