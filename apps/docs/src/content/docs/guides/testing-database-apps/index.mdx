---
title: Testing Apps with Database Access
description: How to test applications that use direct database access with Scenarist
---

import { Aside } from '@astrojs/starlight/components';

## Use the Repository Pattern

**Abstract database access behind interfaces and inject test implementations with test ID isolation.** This gives you:

- True test-level parallelism (not just shard-level)
- Same test ID isolation model as Scenarist's HTTP mocking
- Fast in-memory execution
- Architectural benefits that extend beyond testing

[Implement the Repository Pattern →](./repository-pattern)

<Aside type="tip">
**Not ready to refactor?** Use [sharding](./parallelism-options#option-3-sharding-container-per-shard) for parallelism without code changes, or [sequential execution](./parallelism-options#option-1-sequential-execution) for small test suites.
</Aside>

---

## Why This Matters

Scenarist intercepts HTTP requests via MSW. Database calls are not HTTP requests—they use direct TCP connections that MSW cannot intercept.

```typescript
// ❌ Scenarist CANNOT mock this - no HTTP request
export async function fetchProducts() {
  return await db.products.findMany();  // Direct database call
}
```

Without the repository pattern, you have two bad options:
- **Sequential execution**: Doesn't scale—CI time grows linearly with test count
- **Sharding**: Only shard-level parallelism—tests within each shard still run sequentially

The repository pattern solves this by letting you inject in-memory implementations that partition data by test ID, just like Scenarist does for HTTP.

---

## Quick Decision Guide

| Your Situation | Use This |
|----------------|----------|
| Want scalable parallel tests | [Repository Pattern](./repository-pattern) |
| Need to test actual SQL queries | Repository Pattern + [Testcontainers](./testcontainers-hybrid) |
| Can't change code right now | [Sharding](./parallelism-options#option-3-sharding-container-per-shard) |
| Small test suite, prototyping | [Sequential Execution](./parallelism-options#option-1-sequential-execution) |

---

## What Scenarist Handles

| What You're Testing | Tool |
|---------------------|------|
| External HTTP APIs (Stripe, Auth0, SendGrid) | **Scenarist** |
| Database queries and constraints | **Repository Pattern** + Testcontainers |
| Business logic with database state | **Repository Pattern** |

---

## Next Steps

- [Repository Pattern Guide](./repository-pattern) — Implementation walkthrough
- [Testcontainers Hybrid](./testcontainers-hybrid) — Testing real database behavior
- [All Parallelism Options](./parallelism-options) — Detailed comparison of approaches
