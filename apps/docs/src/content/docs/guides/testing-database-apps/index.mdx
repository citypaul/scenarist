---
title: Testing Apps with Database Access
description: How to test applications that use direct database access with Scenarist
---

import { Aside } from '@astrojs/starlight/components';

## Use the Repository Pattern

**Abstract database access behind interfaces and inject test implementations with test ID isolation.** This gives you:

- True test-level parallelism (not just shard-level)
- Same test ID isolation model as Scenarist's HTTP mocking
- Fast in-memory execution
- Architectural benefits that extend beyond testing

[Implement the Repository Pattern →](./repository-pattern)

<Aside type="tip">
**Not ready to refactor?** Use [sharding](./parallelism-options#option-3-sharding-container-per-shard) for parallelism without code changes, or [sequential execution](./parallelism-options#option-1-sequential-execution) for small test suites.
</Aside>

---

## Why Database Testing Is Hard

Scenarist intercepts HTTP requests via MSW because every HTTP library eventually calls the same underlying APIs. **Databases have no equivalent universal interception point.**

Each ORM and driver is a different API surface:
- Prisma: `prisma.user.findMany()`
- Drizzle: `db.select().from(users)`
- TypeORM: `userRepository.find()`
- Raw SQL: `pg.query('SELECT * FROM users')`

There's no single place to intercept all database queries and inject test isolation.

```typescript
// ❌ Scenarist CANNOT mock this - no HTTP request
export async function fetchProducts() {
  return await db.products.findMany();  // Direct database call
}
```

**The core problem:** Scenarist isolates tests via test ID in HTTP headers. Databases have no equivalent mechanism—without isolation, parallel tests corrupt each other's data.

The repository pattern solves this by letting you inject in-memory implementations that partition data by test ID, just like Scenarist does for HTTP.

---

## Quick Decision Guide

| Your Situation | Use This |
|----------------|----------|
| Want scalable parallel tests | [Repository Pattern](./repository-pattern) |
| Need to test actual SQL queries, constraints | [Testcontainers](./testcontainers-hybrid) |
| Can't change code right now | [Sharding](./parallelism-options#option-3-sharding-container-per-shard) |
| Small test suite, prototyping | [Sequential Execution](./parallelism-options#option-1-sequential-execution) |

---

## What Scenarist Handles

| What You're Testing | Tool |
|---------------------|------|
| External HTTP APIs (Stripe, Auth0, SendGrid) | **Scenarist** |
| Business logic with database state | **Repository Pattern** |
| Actual SQL queries, constraints, transactions | **Testcontainers** |

---

## Next Steps

- [Repository Pattern Guide](./repository-pattern) — Implementation walkthrough
- [Testcontainers Hybrid](./testcontainers-hybrid) — Testing real database behavior
- [All Parallelism Options](./parallelism-options) — Detailed comparison of approaches
