---
title: Database Testing Parallelism Options
description: Compare strategies for parallel database testing—trade-offs between code changes, schema changes, complexity, and speed
---

import { Aside } from '@astrojs/starlight/components';

<Aside type="note" title="Why This Page Exists">

The [Testcontainers Hybrid approach](./testcontainers-hybrid) requires sequential test execution. This page explores alternatives if you need parallelism, with honest analysis of what each approach costs.

</Aside>

## Why Parallel Database Testing Is Hard

**HTTP mocking has a universal interception point.** MSW intercepts `fetch()` calls in both browser and Node.js. Every HTTP library eventually calls the same underlying APIs.

**Databases have no equivalent.** Each ORM and driver is a different API surface:

- Prisma: `prisma.user.findMany()`
- Drizzle: `db.select().from(users)`
- TypeORM: `userRepository.find()`
- Knex: `knex('users').select()`
- Raw SQL: `pg.query('SELECT * FROM users')`

There's no single place to intercept all database queries and inject test isolation.

### The Core Problem

Scenarist isolates tests via **test ID in HTTP headers**:

```typescript
// Test ID flows automatically through HTTP
fetch('/api/products', {
  headers: { 'x-test-id': 'test-123' }  // Automatic isolation
});
```

Databases have no equivalent mechanism:

```typescript
// No "test ID header" in database protocol
await prisma.user.findMany();  // Which test's data?
```

Without isolation, parallel tests corrupt each other's data.

## Options Comparison

| Approach | Parallelism | No Code Changes | No Schema Changes | ORM Agnostic | Complexity |
|----------|-------------|-----------------|-------------------|--------------|------------|
| Sequential execution | ❌ | ✅ | ✅ | ✅ | Low |
| Repository pattern | ✅ | ❌ | ✅ | ✅ | Medium |
| Multiple containers | ✅ | ✅ | ✅ | ✅ | Medium |
| PostgreSQL RLS | ✅ | ✅ | ❌ | ❌ | High |
| Schema per test | ✅ | ✅ | ✅ | ✅ | Very High |

**No option gives you everything.** Choose based on your priorities.

## Option 1: Sequential Execution (Recommended Default)

**Accept the limitation.** Run database tests sequentially, HTTP tests in parallel.

```typescript
// playwright.config.ts
export default defineConfig({
  projects: [
    {
      name: 'database-tests',
      testMatch: '**/db-*.spec.ts',
      fullyParallel: false,  // Sequential
    },
    {
      name: 'api-tests',
      testMatch: '**/api-*.spec.ts',
      fullyParallel: true,   // Parallel (Scenarist handles isolation)
    },
  ],
});
```

**Best for:**
- Most teams
- Focused database test suites (tens of tests, not hundreds)
- Teams prioritizing simplicity over speed

**Trade-offs:**
- ✅ No code changes
- ✅ No schema changes
- ✅ Works with any ORM
- ❌ Slower for large test suites

## Option 2: Repository Pattern

Abstract database access behind interfaces and inject test implementations.

```typescript
// Define repository interface
interface UserRepository {
  findById(id: string): Promise<User | null>;
  create(user: User): Promise<User>;
  findByEmail(email: string): Promise<User | null>;
}

// Production implementation
class PrismaUserRepository implements UserRepository {
  constructor(private prisma: PrismaClient) {}

  async findById(id: string) {
    return this.prisma.user.findUnique({ where: { id } });
  }

  async create(user: User) {
    return this.prisma.user.create({ data: user });
  }

  async findByEmail(email: string) {
    return this.prisma.user.findFirst({ where: { email } });
  }
}

// Test implementation with test ID isolation
class InMemoryUserRepository implements UserRepository {
  private store = new Map<string, Map<string, User>>();

  constructor(private getTestId: () => string) {}

  private getTestStore() {
    const testId = this.getTestId();
    if (!this.store.has(testId)) {
      this.store.set(testId, new Map());
    }
    return this.store.get(testId)!;
  }

  async findById(id: string) {
    return this.getTestStore().get(id) ?? null;
  }

  async create(user: User) {
    this.getTestStore().set(user.id, user);
    return user;
  }

  async findByEmail(email: string) {
    for (const user of this.getTestStore().values()) {
      if (user.email === email) return user;
    }
    return null;
  }
}
```

```typescript
// Inject based on environment
const userRepository = process.env.NODE_ENV === 'test'
  ? new InMemoryUserRepository(() => getTestIdFromHeader())
  : new PrismaUserRepository(prisma);
```

**Best for:**
- Teams already using hexagonal/clean architecture
- Applications where dependency injection is established
- Need full parallelism with complete isolation

**Trade-offs:**
- ✅ True parallelism with test ID isolation
- ✅ No schema changes
- ✅ ORM agnostic (swap implementations freely)
- ✅ In-memory tests are fast
- ❌ Requires abstracting all database access
- ❌ Must maintain two implementations (production + test)
- ❌ Test implementation may not catch real database issues

## Option 3: Multiple Containers (Playwright Sharding)

Run multiple PostgreSQL containers, one per Playwright shard.

```typescript
// playwright.config.ts
export default defineConfig({
  workers: 4,  // 4 parallel workers
});

// globalSetup.ts
export default async function globalSetup() {
  const workerId = process.env.TEST_WORKER_INDEX || '0';

  // Each worker gets its own container
  const container = await new PostgreSqlContainer()
    .withDatabase(`test_${workerId}`)
    .start();

  process.env.DATABASE_URL = container.getConnectionUrl();
}
```

Run with sharding:
```bash
npx playwright test --shard=1/4
npx playwright test --shard=2/4
npx playwright test --shard=3/4
npx playwright test --shard=4/4
```

**Best for:**
- CI/CD with good parallelization support
- Teams with container orchestration experience
- Large test suites where speed is critical

**Trade-offs:**
- ✅ True parallelism
- ✅ No code or schema changes
- ❌ Resource-intensive (CPU, memory, disk)
- ❌ Complex CI/CD setup
- ❌ Slower container startup (multiplied by shard count)

## Option 4: PostgreSQL Row-Level Security (RLS)

Use PostgreSQL's built-in RLS to isolate by test ID without application code changes.

```sql
-- Add test_id to tables
ALTER TABLE users ADD COLUMN test_id TEXT;

-- Create policy
CREATE POLICY test_isolation ON users
  USING (test_id = current_setting('app.test_id', true));

-- Enable RLS
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
```

```typescript
// Set session variable per request
app.use(async (req, res, next) => {
  const testId = req.headers['x-test-id'];
  await prisma.$executeRaw`SELECT set_config('app.test_id', ${testId}, true)`;
  next();
});
```

**Best for:**
- PostgreSQL users only
- Teams comfortable with database-level security
- Applications where RLS is already used

**Trade-offs:**
- ✅ True parallelism
- ✅ No application code changes (after setup)
- ✅ Database handles isolation
- ❌ PostgreSQL only (not portable)
- ❌ Schema changes required
- ❌ Complex to debug
- ❌ Performance overhead

## Option 5: Schema Per Test

Create a database schema for each test, complete isolation.

```typescript
// Before each test
const testId = generateTestId();
await prisma.$executeRaw`CREATE SCHEMA test_${testId}`;
await prisma.$executeRaw`SET search_path TO test_${testId}`;

// Run migrations in new schema
execSync('npx prisma migrate deploy');

// After test
await prisma.$executeRaw`DROP SCHEMA test_${testId} CASCADE`;
```

**Best for:**
- Complete isolation requirements
- Teams with existing schema management tooling
- Debugging complex test failures

**Trade-offs:**
- ✅ Complete isolation
- ✅ No code changes
- ✅ Works with any ORM
- ❌ Very slow (migrations per test)
- ❌ Complex connection management
- ❌ High resource usage

## Decision Guide

### Priority: Simplicity
**Choose: Sequential Execution**

Most teams don't have hundreds of database tests. The simplicity of sequential execution outweighs the speed benefit of parallelism.

### Priority: Speed (CI/CD)
**Choose: Multiple Containers**

If you have 100+ database tests and CI/CD time matters, run 4-8 containers in parallel via Playwright sharding. Requires good infrastructure but no code changes.

### Priority: Architecture
**Choose: Repository Pattern**

If your team already uses hexagonal/clean architecture with dependency injection, the repository pattern provides true parallelism with test ID isolation. Requires abstracting database access behind interfaces but gives you in-memory speed and full isolation.

### Priority: True Isolation
**Choose: PostgreSQL RLS**

If you need row-level isolation (e.g., testing multi-tenant applications), accept the schema changes and complexity. Note this is PostgreSQL-only.

### Priority: Everything
**Not possible.** Pick your top priority and accept the trade-offs.

## Recommended Strategy

For most teams, we recommend:

1. **Use Scenarist for HTTP mocking** - External APIs (Stripe, Auth0, SendGrid)
2. **Adopt the repository pattern** - Abstractions with test ID isolation for parallelism
3. **Complement with Testcontainers** - For critical paths that need real database validation
4. **Run all tests in parallel** - Both HTTP and database tests benefit from test ID isolation

The repository pattern provides the same isolation model as Scenarist's HTTP mocking, giving you fast parallel tests while following clean architecture principles.

If you need to test actual database behavior (query performance, constraints, transactions), use Testcontainers for those specific tests while running the majority of tests with in-memory repositories.

## Next Steps

- [Repository Pattern Guide](./repository-pattern) - Implement the recommended approach for parallelism
- [Testcontainers Hybrid Guide](./testcontainers-hybrid) - Test real database behavior when needed
- [Testcontainers Documentation](https://testcontainers.com/) - Learn container management
- [PostgreSQL RLS Documentation](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) - Understand RLS if choosing that option
