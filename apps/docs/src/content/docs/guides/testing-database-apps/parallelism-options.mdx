---
title: Database Testing Parallelism Options
description: Compare strategies for parallel database testing—trade-offs between code changes, schema changes, complexity, and speed
---

import { Aside } from '@astrojs/starlight/components';

<Aside type="note" title="Why This Page Exists">

Database testing requires choosing between different parallelism strategies. This page compares all options with honest analysis of what each approach costs, so you can make the right choice for your team.

</Aside>

## Why Parallel Database Testing Is Hard

**HTTP mocking has a universal interception point.** MSW intercepts `fetch()` calls in both browser and Node.js. Every HTTP library eventually calls the same underlying APIs.

**Databases have no equivalent.** Each ORM and driver is a different API surface:

- Prisma: `prisma.user.findMany()`
- Drizzle: `db.select().from(users)`
- TypeORM: `userRepository.find()`
- Knex: `knex('users').select()`
- Raw SQL: `pg.query('SELECT * FROM users')`

There's no single place to intercept all database queries and inject test isolation.

### The Core Problem

Scenarist isolates tests via **test ID in HTTP headers**:

```typescript
// Test ID flows automatically through HTTP
fetch('/api/products', {
  headers: { 'x-test-id': 'test-123' }  // Automatic isolation
});
```

Databases have no equivalent mechanism:

```typescript
// No "test ID header" in database protocol
await prisma.user.findMany();  // Which test's data?
```

Without isolation, parallel tests corrupt each other's data.

## Options Comparison

| Approach | Parallelism | No Code Changes | No Schema Changes | ORM Agnostic | Complexity |
|----------|-------------|-----------------|-------------------|--------------|------------|
| Sequential execution | ❌ | ✅ | ✅ | ✅ | Low |
| Repository pattern | ✅ | ❌ | ✅ | ✅ | Medium |
| Sharding (container per shard) | ✅ | ✅ | ✅ | ✅ | Medium |
| PostgreSQL RLS | ✅ | ✅ | ❌ | ❌ | High |
| Schema per test | ✅ | ✅ | ✅ | ✅ | Very High |

**No option gives you everything.** Choose based on your priorities.

## Option 1: Sequential Execution

**Accept the limitation.** Run database tests sequentially, HTTP tests in parallel.

```typescript
// playwright.config.ts
export default defineConfig({
  projects: [
    {
      name: 'database-tests',
      testMatch: '**/db-*.spec.ts',
      fullyParallel: false,  // Sequential
    },
    {
      name: 'api-tests',
      testMatch: '**/api-*.spec.ts',
      fullyParallel: true,   // Parallel (Scenarist handles isolation)
    },
  ],
});
```

**Best for:**
- Small test suites (tens of tests, not hundreds)
- Teams prioritizing simplicity over speed
- Quick prototypes where test speed doesn't matter yet

**Trade-offs:**
- ✅ No code changes
- ✅ No schema changes
- ✅ Works with any ORM
- ❌ Slower for large test suites
- ❌ Doesn't scale as codebase grows

## Option 2: Repository Pattern

Abstract database access behind interfaces and inject test implementations.

```typescript
// Define repository interface
interface UserRepository {
  findById(id: string): Promise<User | null>;
  create(user: User): Promise<User>;
  findByEmail(email: string): Promise<User | null>;
}

// Production implementation
class PrismaUserRepository implements UserRepository {
  constructor(private prisma: PrismaClient) {}

  async findById(id: string) {
    return this.prisma.user.findUnique({ where: { id } });
  }

  async create(user: User) {
    return this.prisma.user.create({ data: user });
  }

  async findByEmail(email: string) {
    return this.prisma.user.findFirst({ where: { email } });
  }
}

// Test implementation with test ID isolation
class InMemoryUserRepository implements UserRepository {
  private store = new Map<string, Map<string, User>>();

  constructor(private getTestId: () => string) {}

  private getTestStore() {
    const testId = this.getTestId();
    if (!this.store.has(testId)) {
      this.store.set(testId, new Map());
    }
    return this.store.get(testId)!;
  }

  async findById(id: string) {
    return this.getTestStore().get(id) ?? null;
  }

  async create(user: User) {
    this.getTestStore().set(user.id, user);
    return user;
  }

  async findByEmail(email: string) {
    for (const user of this.getTestStore().values()) {
      if (user.email === email) return user;
    }
    return null;
  }
}
```

```typescript
// Inject based on environment
const userRepository = process.env.NODE_ENV === 'test'
  ? new InMemoryUserRepository(() => getTestIdFromHeader())
  : new PrismaUserRepository(prisma);
```

**Best for:**
- Teams wanting true test-level parallelism
- Growing codebases that need scalable testing
- Teams valuing clean architecture and infrastructure flexibility

**Trade-offs:**
- ✅ True parallelism with test ID isolation
- ✅ No schema changes
- ✅ ORM agnostic (swap implementations freely)
- ✅ In-memory tests are fast
- ✅ Infrastructure flexibility (change databases/ORMs later)
- Requires abstracting database access behind interfaces
- Separate tests needed for real database behavior

[**Learn more about the Repository Pattern →**](./repository-pattern)

## Option 3: Sharding (Container per Shard)

Run multiple PostgreSQL containers, one per Playwright shard. This provides parallelism at the shard level (not test level)—tests within each shard still run sequentially against their container.

```typescript
// playwright.config.ts
export default defineConfig({
  workers: 4,  // 4 parallel workers
});

// globalSetup.ts
export default async function globalSetup() {
  const workerId = process.env.TEST_WORKER_INDEX || '0';

  // Each worker gets its own container
  const container = await new PostgreSqlContainer()
    .withDatabase(`test_${workerId}`)
    .start();

  process.env.DATABASE_URL = container.getConnectionUrl();
}
```

Run with sharding:
```bash
npx playwright test --shard=1/4
npx playwright test --shard=2/4
npx playwright test --shard=3/4
npx playwright test --shard=4/4
```

**Best for:**
- CI/CD with good parallelization support
- Teams with container orchestration experience
- Large test suites where speed is critical

**Trade-offs:**
- ✅ Shard-level parallelism (4 shards = 4x faster)
- ✅ No code or schema changes
- ❌ Not test-level parallelism (tests within shard still sequential)
- ❌ Resource-intensive (CPU, memory, disk)
- ❌ Complex CI/CD setup
- ❌ Slower container startup (multiplied by shard count)

## Option 4: PostgreSQL Row-Level Security (RLS)

Use PostgreSQL's built-in RLS to isolate by test ID without application code changes.

```sql
-- Add test_id to tables
ALTER TABLE users ADD COLUMN test_id TEXT;

-- Create policy
CREATE POLICY test_isolation ON users
  USING (test_id = current_setting('app.test_id', true));

-- Enable RLS
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
```

```typescript
// Set session variable per request
app.use(async (req, res, next) => {
  const testId = req.headers['x-test-id'];
  await prisma.$executeRaw`SELECT set_config('app.test_id', ${testId}, true)`;
  next();
});
```

**Best for:**
- PostgreSQL users only
- Teams comfortable with database-level security
- Applications where RLS is already used

**Trade-offs:**
- ✅ True parallelism
- ✅ No application code changes (after setup)
- ✅ Database handles isolation
- ❌ PostgreSQL only (not portable)
- ❌ Schema changes required
- ❌ Complex to debug
- ❌ Performance overhead

## Option 5: Schema Per Test

Create a database schema for each test, complete isolation.

```typescript
// Before each test
const testId = generateTestId();
await prisma.$executeRaw`CREATE SCHEMA test_${testId}`;
await prisma.$executeRaw`SET search_path TO test_${testId}`;

// Run migrations in new schema
execSync('npx prisma migrate deploy');

// After test
await prisma.$executeRaw`DROP SCHEMA test_${testId} CASCADE`;
```

**Best for:**
- Complete isolation requirements
- Teams with existing schema management tooling
- Debugging complex test failures

**Trade-offs:**
- ✅ Complete isolation
- ✅ No code changes
- ✅ Works with any ORM
- ❌ Very slow (migrations per test)
- ❌ Complex connection management
- ❌ High resource usage

## Decision Guide

### Start Here: Sequential Execution

For most teams starting out, sequential execution is the right choice. It's simple, requires no code changes, and works well until your test suite grows large.

### When to Choose Repository Pattern

If you need true test-level parallelism and you value clean architecture. Best for teams who are comfortable with dependency injection and interface abstractions. The architectural benefits extend beyond testing.

### When to Choose Sharding

If you have 100+ database tests and CI/CD time is critical, but you don't want to change your application code. Requires good infrastructure and Docker orchestration.

### When to Choose PostgreSQL RLS

If you need row-level isolation (e.g., testing multi-tenant applications) and you're already using PostgreSQL. Accept the schema changes and complexity.

### When to Choose Schema Per Test

Rarely. Only if you need complete isolation and can tolerate very slow test execution.

## Common Strategy

A pragmatic approach for most teams:

1. **Use Scenarist for HTTP mocking** - External APIs (Stripe, Auth0, SendGrid)
2. **Start with sequential database tests** - Simple, no code changes
3. **Add parallelism when needed** - Choose based on your priorities and constraints
4. **Test real database behavior when critical** - Use Testcontainers for queries, constraints, transactions

As your test suite grows, evaluate whether the investment in parallelism (repository pattern or sharding) is worth the trade-offs for your team.

## Next Steps

- [Repository Pattern Guide](./repository-pattern) - Test-level parallelism with clean architecture
- [Testcontainers Hybrid Guide](./testcontainers-hybrid) - Test real database behavior
- [Testcontainers Documentation](https://testcontainers.com/) - Learn container management
- [PostgreSQL RLS Documentation](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) - Understand RLS
