---
title: Your First Scenario
description: A hands-on tutorial for building your first Scenarist scenario from scratch
---

import { Aside, Steps, Tabs, TabItem } from '@astrojs/starlight/components';

This tutorial walks you through building a complete scenario from scratch. You'll learn the **why** behind each step, not just the how.

**Time to complete:** 15-20 minutes

## What We're Building

You're testing a checkout page that:
1. Submits payment to Stripe
2. Shows success or error messages based on Stripe's response

By the end, you'll have two scenarios testing both paths—running in parallel, completing in seconds.

## Prerequisites

- Scenarist [installed](/introduction/installation) in your project
- A route that calls an external API (we'll use Stripe as the example)
- Basic Playwright knowledge

## Step 1: Understand What to Mock

Before writing any code, identify your **external dependencies**—the HTTP calls that leave your application.

<Aside type="tip" title="Mock External, Not Internal">
Scenarist mocks external APIs (Stripe, Auth0, SendGrid). Your own code—routes, middleware, database calls—runs for real. This is the key difference from traditional mocking.
</Aside>

For our checkout page, the external call is:

```
POST https://api.stripe.com/v1/charges
```

This is what we'll mock. Everything else (your route handler, validation, error handling) executes normally.

## Step 2: Define Your First Mock

Create a scenarios file. Start with the simplest case—a successful response:

```typescript
// scenarios.ts
import type { ScenaristScenario, ScenaristScenarios } from '@scenarist/express-adapter';

const paymentSuccess: ScenaristScenario = {
  id: 'payment-success',
  name: 'Successful Payment',
  description: 'Stripe accepts the charge',
  mocks: [
    {
      method: 'POST',
      url: 'https://api.stripe.com/v1/charges',
      response: {
        status: 200,
        body: {
          id: 'ch_abc123',
          status: 'succeeded',
          amount: 5000,
          currency: 'usd',
        },
      },
    },
  ],
};
```

### Why This Structure?

Each part serves a purpose:

| Field | Purpose |
|-------|---------|
| `id` | Unique identifier used in tests |
| `name` | Human-readable label for debugging |
| `description` | Documents the scenario's intent |
| `mocks` | Array of HTTP responses to return |

The mock definition is **declarative**—you describe *what* response to return, not *how* to generate it. This keeps scenarios inspectable and composable.

## Step 3: Add an Error Scenario

Real applications need error handling. Add a scenario for declined cards:

```typescript
const paymentDeclined: ScenaristScenario = {
  id: 'payment-declined',
  name: 'Card Declined',
  description: 'Stripe rejects the charge',
  mocks: [
    {
      method: 'POST',
      url: 'https://api.stripe.com/v1/charges',
      response: {
        status: 402,
        body: {
          error: {
            type: 'card_error',
            code: 'card_declined',
            message: 'Your card was declined.',
          },
        },
      },
    },
  ],
};
```

<Aside type="note" title="Response Accuracy">
Copy response structures from real API documentation. The more accurate your mocks, the more realistic your tests.
</Aside>

## Step 4: Export the Scenarios Object

Combine scenarios into a single export with a `default` key:

```typescript
export const scenarios = {
  default: paymentSuccess,
  'payment-success': paymentSuccess,
  'payment-declined': paymentDeclined,
} as const satisfies ScenaristScenarios;
```

### Why `default`?

The `default` scenario activates when no scenario is explicitly selected. This provides sensible behavior for:
- Manual testing during development
- Tests that don't need specific scenarios
- Fallback behavior

### Why `as const satisfies`?

This TypeScript pattern gives you:
- **Type-safe IDs**: `switchScenario(page, 'payment-success')` autocompletes
- **Compile-time validation**: Typos in scenario IDs become type errors
- **Schema validation**: Ensures your scenarios match the expected structure

## Step 5: Write Your Tests

<Tabs>
  <TabItem label="Playwright (Browser)">
```typescript
// checkout.spec.ts
import { test, expect } from '@playwright/test';
import { withScenarios } from '@scenarist/playwright-helpers';
import { scenarios } from './scenarios';

const scenarioTest = withScenarios(scenarios);

scenarioTest('shows success message after payment', async ({ page, switchScenario }) => {
  await switchScenario(page, 'payment-success');

  await page.goto('/checkout');
  await page.fill('[name="card"]', '4242424242424242');
  await page.click('button[type="submit"]');

  await expect(page.locator('.success')).toContainText('Payment complete');
});

scenarioTest('shows error when card is declined', async ({ page, switchScenario }) => {
  await switchScenario(page, 'payment-declined');

  await page.goto('/checkout');
  await page.fill('[name="card"]', '4000000000000002');
  await page.click('button[type="submit"]');

  await expect(page.locator('.error')).toContainText('Your card was declined');
});
```
  </TabItem>
  <TabItem label="Supertest (API)">
```typescript
// checkout.test.ts
import { describe, it, expect } from 'vitest';
import request from 'supertest';
import { app } from './app';
import { SCENARIST_TEST_ID_HEADER } from '@scenarist/express-adapter';

describe('POST /api/checkout', () => {
  it('returns success for valid payment', async () => {
    // Switch to success scenario
    await request(app)
      .post('/__scenario__')
      .set(SCENARIST_TEST_ID_HEADER, 'test-success')
      .send({ scenario: 'payment-success' });

    // Make the actual request
    const response = await request(app)
      .post('/api/checkout')
      .set(SCENARIST_TEST_ID_HEADER, 'test-success')
      .send({ amount: 5000, card: '4242424242424242' });

    expect(response.status).toBe(200);
    expect(response.body.status).toBe('succeeded');
  });

  it('returns error for declined card', async () => {
    await request(app)
      .post('/__scenario__')
      .set(SCENARIST_TEST_ID_HEADER, 'test-declined')
      .send({ scenario: 'payment-declined' });

    const response = await request(app)
      .post('/api/checkout')
      .set(SCENARIST_TEST_ID_HEADER, 'test-declined')
      .send({ amount: 5000, card: '4000000000000002' });

    expect(response.status).toBe(402);
    expect(response.body.error.code).toBe('card_declined');
  });
});
```
  </TabItem>
</Tabs>

## Step 6: Run and Verify

```bash
npx playwright test
# or
npx vitest
```

Both tests run **in parallel**—each with its own scenario, isolated by test ID. No race conditions, no flaky tests.

## What You've Learned

<Steps>
1. **Identify external dependencies** — Mock HTTP calls that leave your app, nothing else
2. **Define declarative mocks** — Describe responses as data, not functions
3. **Use `default` scenario** — Provide fallback behavior for development
4. **Type-safe exports** — `as const satisfies` enables autocomplete and validation
5. **Test isolation** — Each test gets its own scenario via test ID
</Steps>

## Common Patterns

### Multiple Mocks per Scenario

Scenarios can mock multiple endpoints:

```typescript
const fullCheckoutFlow: ScenaristScenario = {
  id: 'full-checkout',
  mocks: [
    { method: 'POST', url: 'https://api.stripe.com/v1/charges', response: { ... } },
    { method: 'POST', url: 'https://api.sendgrid.com/v3/mail/send', response: { ... } },
    { method: 'GET', url: 'https://api.taxjar.com/v2/rates', response: { ... } },
  ],
};
```

### URL Patterns with Regex

Match dynamic URLs:

```typescript
{
  method: 'GET',
  url: /https:\/\/api\.stripe\.com\/v1\/charges\/ch_\w+/,
  response: { status: 200, body: { id: 'ch_123', status: 'succeeded' } },
}
```

### Response Headers

Include headers in responses:

```typescript
{
  method: 'POST',
  url: 'https://api.stripe.com/v1/charges',
  response: {
    status: 200,
    headers: { 'X-Request-Id': 'req_abc123' },
    body: { id: 'ch_123' },
  },
}
```

## Next Steps

You've built your first scenario. Now explore advanced capabilities:

- [Scenario Format](/introduction/scenario-format) — All available mock options
- [Dynamic Capabilities](/introduction/capabilities) — Matching, sequences, state capture
- [Default Mocks & Overrides](/introduction/default-mocks) — Reduce duplication
- Framework guides: [Express](/frameworks/express/getting-started) | [Next.js App Router](/frameworks/nextjs-app-router/getting-started) | [Next.js Pages Router](/frameworks/nextjs-pages-router/getting-started)
