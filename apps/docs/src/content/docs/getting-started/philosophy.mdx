---
title: Testing Philosophy
description: Core principles behind Scenarist - testing behavior, not implementation, with declarative patterns
---

import { Aside, Card, CardGrid, Tabs, TabItem, Badge } from '@astrojs/starlight/components';

Scenarist is built on a core testing principle: **test behavior, not implementation**. This philosophy shapes everything about how you write scenarios and structure your tests.

## The Behavior Testing Mindset

Traditional testing often focuses on implementation details—mocking internal functions, spying on method calls, verifying that specific code paths execute. This creates **fragile tests** that break whenever you refactor, even when the external behavior stays exactly the same.

Behavior-focused testing asks a different question: **"What does the user experience?"**

### Implementation-Focused vs Behavior-Focused

<Tabs>
  <TabItem label="Implementation (Fragile)">
```typescript
// Tests are coupled to internal structure
it('should call stripe.charges.create with correct params', () => {
  const stripeMock = jest.spyOn(stripe.charges, 'create');

  await processPayment({ amount: 100 });

  expect(stripeMock).toHaveBeenCalledWith({
    amount: 10000,
    currency: 'usd',
    source: expect.any(String),
  });
});
```

**Problems:**
- Breaks if you switch from `stripe.charges.create` to `stripe.paymentIntents.create`
- Breaks if you add a wrapper function
- Tests internal structure, not user experience
  </TabItem>
  <TabItem label="Behavior (Robust)">
```typescript
// Tests describe user-visible outcomes
it('displays success message after valid payment', async ({ page, switchScenario }) => {
  await switchScenario(page, 'payment-success');

  await page.goto('/checkout');
  await page.fill('[name="card"]', '4242424242424242');
  await page.click('button[type="submit"]');

  await expect(page.locator('.success')).toContainText('Payment complete');
});
```

**Benefits:**
- Tests what users actually see
- Survives internal refactoring
- Documents expected behavior
  </TabItem>
</Tabs>

### From "How It Works" to "What It Does"

The shift from implementation to behavior testing changes how you think about tests:

| Instead of asking... | Ask... |
|---------------------|--------|
| "Did the Stripe SDK get called?" | "Can users complete a purchase?" |
| "Was the auth token validated?" | "Are unauthorized users blocked?" |
| "Did the email service return 200?" | "Does the user see a confirmation message?" |
| "Was the cache hit?" | "Does the page load quickly?" |

Your tests become **documentation of expected behavior**, not a specification of internal mechanisms.

## Why Declarative Patterns Matter

Scenarist enforces **declarative scenario definitions**—you describe **what** should happen, not **how** to make it happen. This isn't an arbitrary constraint; it's fundamental to maintainable testing.

### Declarative: Describe the Outcome

```typescript
// ✅ Declarative - describes what response to return
{
  method: 'POST',
  url: 'https://api.stripe.com/v1/charges',
  response: {
    status: 200,
    body: { id: 'ch_123', status: 'succeeded' },
  },
}
```

### Imperative: Describe the Steps

```typescript
// ❌ Imperative - describes how to generate response
server.use('/api/charges', (req, res) => {
  const amount = req.body.amount;
  if (amount > 10000) {
    return res.status(402).json({ error: 'amount_too_large' });
  }
  if (!validateCard(req.body.card)) {
    return res.status(402).json({ error: 'card_invalid' });
  }
  return res.status(200).json({ id: generateId(), status: 'succeeded' });
});
```

### Why the Difference Matters

<CardGrid>
  <Card title="Inspectable" icon="magnifier">
    Declarative scenarios are data structures. You can see exactly what response will be returned by reading the definition—no need to trace through conditional logic.
  </Card>
  <Card title="Composable" icon="puzzle">
    Declarative patterns combine naturally. Add request matching, sequences, or state capture without rewriting procedural logic.
  </Card>
  <Card title="Testable" icon="approve-check">
    Scenarios themselves can be validated. You can check that a scenario definition is well-formed before running tests.
  </Card>
  <Card title="Versionable" icon="document">
    Declarative definitions produce clean diffs in version control. You can see exactly what changed between commits.
  </Card>
</CardGrid>

### The Constraint Enables Better Design

When you can't write imperative logic, you're forced to discover better patterns:

```typescript
// Imperative temptation: if/else for user tiers
// ❌ Can't write this in Scenarist
(req) => {
  if (req.headers['x-tier'] === 'premium') {
    return { price: 99.99, discount: true };
  }
  return { price: 149.99, discount: false };
}

// Declarative solution: match criteria
// ✅ Explicit, scannable, composable
[
  {
    method: 'GET',
    url: '/api/pricing',
    match: { headers: { 'x-tier': 'premium' } },
    response: { status: 200, body: { price: 99.99, discount: true } },
  },
  {
    method: 'GET',
    url: '/api/pricing',
    response: { status: 200, body: { price: 149.99, discount: false } },
  },
]
```

The declarative version is **more explicit** (you can see both cases at a glance) and **more maintainable** (add new tiers by adding new mock definitions, not modifying if/else chains).

## The Testing Gap Scenarist Fills

Modern web development has a testing problem. Traditional testing approaches were designed for a world where frontend and backend were separate concerns. Today's frameworks blur those lines.

### The Three-Layer Testing Model

Most testing guidance describes three layers:

```
┌─────────────────────────────────────────┐
│           Unit Tests                     │
│   Fast, isolated, mock everything        │
└─────────────────────────────────────────┘
                   ▼
┌─────────────────────────────────────────┐
│       Integration Tests                  │
│   Test module boundaries                 │
└─────────────────────────────────────────┘
                   ▼
┌─────────────────────────────────────────┐
│          E2E Tests                       │
│   Full system, real dependencies         │
└─────────────────────────────────────────┘
```

**The problem:** Where do Server Components fit? They're not isolated units (they fetch data), they're not traditional integration tests (they render UI), and full E2E is too slow for comprehensive scenario coverage.

### Where Scenarist Fits

```
┌─────────────────────────────────────────┐
│           Unit Tests                     │
│   Pure functions, utilities              │
└─────────────────────────────────────────┘
                   ▼
┌─────────────────────────────────────────┐
│   ★ Scenarist (HTTP Layer Tests) ★      │
│   Real server, mocked external APIs      │
│   Server Components, loaders, routes     │
│   Full scenario coverage, parallel       │
└─────────────────────────────────────────┘
                   ▼
┌─────────────────────────────────────────┐
│          E2E Tests                       │
│   Complete user journeys                 │
│   Real external services (sparingly)     │
└─────────────────────────────────────────┘
```

Scenarist fills the gap: **test your real server-side code with controlled external API responses**, enabling comprehensive scenario coverage without the speed penalty of E2E tests.

### What Each Layer Tests Best

| Layer | Tests | Speed | Scenario Coverage |
|-------|-------|-------|-------------------|
| **Unit** | Pure functions, utilities | Fastest | Limited (no I/O) |
| **Scenarist** | Server Components, API routes, middleware | Fast | Comprehensive |
| **E2E** | Complete user journeys | Slowest | Representative |

<Aside type="tip" title="The 80/20 Rule">
For most web applications, 80% of your tests should be Scenarist-style (real server, mocked external APIs). Use unit tests for complex pure logic, and E2E tests for critical user journeys.
</Aside>

## When Scenarist Is the Right Choice

### Perfect For

<CardGrid>
  <Card title="External API Integration" icon="external">
    Testing how your app behaves when Stripe returns different responses, Auth0 times out, or SendGrid rate-limits you.
  </Card>
  <Card title="Server Components" icon="seti:react">
    Testing async Server Components that fetch data, without mocking React or Next.js internals.
  </Card>
  <Card title="Error Handling" icon="warning">
    Verifying your app handles edge cases gracefully—network errors, malformed responses, auth failures.
  </Card>
  <Card title="Parallel Testing" icon="rocket">
    Running hundreds of scenarios in parallel, each test isolated by test ID, completing in seconds.
  </Card>
</CardGrid>

### Concrete Examples

**Payment Flow Testing:**
```typescript
// Test card declined scenario
test('shows error when card is declined', async ({ page, switchScenario }) => {
  await switchScenario(page, 'card-declined');

  await page.goto('/checkout');
  await page.fill('[name="card"]', '4000000000000002');
  await page.click('button[type="submit"]');

  await expect(page.locator('.error')).toContainText('Card declined');
});
```

**Auth Timeout Testing:**
```typescript
// Test auth service timeout
test('shows fallback UI when auth service times out', async ({ page, switchScenario }) => {
  await switchScenario(page, 'auth-timeout');

  await page.goto('/dashboard');

  await expect(page.locator('.auth-fallback')).toBeVisible();
});
```

**Multi-Step Journey Testing:**
```typescript
// Test polling flow with sequence
test('shows status progression during async job', async ({ page, switchScenario }) => {
  await switchScenario(page, 'async-job-sequence');

  await page.goto('/process');
  await page.click('[data-testid="start-job"]');

  // Sequence returns: pending → processing → complete
  await expect(page.locator('.status')).toContainText('pending');
  await page.waitForTimeout(1000);
  await expect(page.locator('.status')).toContainText('processing');
  await page.waitForTimeout(1000);
  await expect(page.locator('.status')).toContainText('complete');
});
```

## When Scenarist Is NOT the Right Choice

Scenarist is focused on HTTP-layer testing. It's **not** the right tool for:

### Direct Database Testing

```typescript
// ❌ Scenarist can't intercept this
const users = await prisma.user.findMany();
```

If your app uses direct database access (Prisma, Drizzle, raw SQL), Scenarist can't intercept those calls—they don't go over HTTP.

<Aside type="note" title="Database Testing Alternatives">
For database-backed apps, see [Testing Database Apps](/guides/testing-database-apps) for recommended patterns like the Repository Pattern that provides similar test isolation.
</Aside>

### Same-Host Internal Routes

```typescript
// ❌ Scenarist can't intercept this in Next.js
// Server Component calling same-host API route
const data = await fetch('http://localhost:3000/api/users');
```

When a Server Component calls an API route on the same host, Next.js handles this internally without an HTTP request. MSW (which Scenarist uses) only sees requests that traverse the network.

### Client-Only Applications

If your app has no server-side code (pure SPA with all data fetching in the browser), Scenarist adds unnecessary complexity. Use MSW directly in the browser instead.

### Contract Testing

Scenarist mocks don't validate against real API contracts. If you need to verify your mocks match real API schemas, use contract testing tools (Pact, Prism) alongside Scenarist.

## Applying the Philosophy

### Start with Behavior Questions

When writing tests, start by asking:

1. **What does the user see?** Focus on visible outcomes, not internal state.
2. **What scenarios matter?** List the external conditions that affect behavior.
3. **What could go wrong?** Error cases are often more important than happy paths.

### Write Scenarios, Not Mocks

Don't think of Scenarist definitions as "mocking Stripe"—think of them as **describing scenarios**:

```typescript
// ❌ Thinking in mocks
const stripeMock = { /* ... */ };

// ✅ Thinking in scenarios
const scenarios = {
  'premium-checkout-success': { /* describes what happens */ },
  'card-declined-insufficient-funds': { /* describes what happens */ },
  'stripe-timeout': { /* describes what happens */ },
} satisfies ScenaristScenarios;
```

Scenario names describe **business outcomes**, not technical implementations.

### Test the Edges

Happy paths are important, but edge cases reveal the quality of your error handling:

<CardGrid>
  <Card title="Network Failures" icon="warning">
    Timeouts, connection refused, DNS failures
  </Card>
  <Card title="Rate Limiting" icon="prohibited">
    429 responses, retry-after headers
  </Card>
  <Card title="Malformed Responses" icon="error">
    Invalid JSON, missing fields, wrong types
  </Card>
  <Card title="Partial Failures" icon="warning">
    First call succeeds, second fails (webhooks, callbacks)
  </Card>
</CardGrid>

### Keep Scenarios Focused

Each scenario should test **one thing**:

```typescript
// ❌ Kitchen sink scenario
const scenarios = {
  'everything': {
    id: 'everything',
    mocks: [
      { /* stripe success */ },
      { /* auth success */ },
      { /* email success */ },
      { /* analytics success */ },
    ],
  },
};

// ✅ Focused scenarios
const scenarios = {
  'payment-success': { /* only stripe */ },
  'payment-declined': { /* only stripe, declined */ },
  'email-failure': { /* stripe success, email failure */ },
} satisfies ScenaristScenarios;
```

Focused scenarios make failures clear: when `payment-declined` fails, you know it's a payment handling issue.

## Summary

Scenarist's testing philosophy is built on three principles:

1. **Test behavior, not implementation.** Focus on what users experience, not internal code structure.

2. **Use declarative patterns.** Describe what should happen, not how to make it happen. This leads to inspectable, composable, maintainable tests.

3. **Fill the testing gap.** Use Scenarist for HTTP-layer testing that's too slow for E2E but too integrated for unit tests.

## Next Steps

Ready to apply these principles?

- [Quick Start](/getting-started/quick-start) — Set up your first scenario in 5 minutes
- [First Scenario Tutorial](/getting-started/first-scenario) — Step-by-step guide with more context
- [Scenario Format](/introduction/scenario-format) — All the declarative patterns available
- [Declarative Design Deep Dive](/introduction/declarative-design) — Advanced patterns and philosophy
