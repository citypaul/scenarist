---
title: Dynamic Response Capabilities
description: Request matching, sequences, and stateful mocks for realistic test scenarios
---

Scenarist supports three types of dynamic responses for realistic test scenarios. These capabilities work together to simulate complex external API behaviors.

## Request Content Matching

Return different responses based on request content. Multiple mocks can exist for the same URL, and Scenarist selects the most specific match based on the actual request.

### Matching Criteria

Match on request body, headers, or query parameters:

```typescript
{
  method: 'POST',
  url: '/api/checkout',
  match: {
    body: { tier: 'premium' },
    headers: { 'x-api-version': 'v2' },
    query: { detailed: 'true' }
  },
  response: { status: 200, body: { discount: 20 } }
}
```

### Specificity-Based Selection

When multiple mocks match the same URL, Scenarist uses specificity scoring:

- Mocks with match criteria are more specific than mocks without
- Among mocks with criteria, more fields = higher specificity
- Ties are broken by position (first wins)

**Example:**

```typescript
const premiumScenario = {
  id: 'premium',
  mocks: [
    // Specificity: 2 (body.tier + body.category)
    {
      method: 'POST',
      url: '/api/products',
      match: {
        body: { tier: 'premium', category: 'electronics' }
      },
      response: { status: 200, body: { discount: 30 } }
    },
    // Specificity: 1 (body.tier only)
    {
      method: 'POST',
      url: '/api/products',
      match: {
        body: { tier: 'premium' }
      },
      response: { status: 200, body: { discount: 20 } }
    },
    // Specificity: 0 (no match criteria, fallback)
    {
      method: 'POST',
      url: '/api/products',
      response: { status: 200, body: { discount: 10 } }
    }
  ]
};

// Request with tier='premium' and category='electronics'
// → Returns 30% discount (specificity 2 wins)

// Request with tier='premium' only
// → Returns 20% discount (specificity 1 wins)

// Request with neither
// → Returns 10% discount (fallback)
```

### Partial Body Matching

Body matching is **partial** - only the specified fields must match:

```typescript
{
  method: 'POST',
  url: '/api/create-order',
  match: {
    body: { itemType: 'premium' }  // Only checks itemType field
  },
  response: { status: 201, body: { orderId: 'premium-order-123' } }
}

// Matches requests with itemType='premium', regardless of other fields:
// { itemType: 'premium', quantity: 5, color: 'red' } ✓
// { itemType: 'premium' } ✓
// { itemType: 'standard' } ✗
```

### Header and Query Matching

Header and query parameter matching is **exact** for specified keys:

```typescript
{
  method: 'GET',
  url: '/api/data',
  match: {
    headers: { 'x-tier': 'premium' },  // Exact match
    query: { format: 'json' }          // Exact match
  },
  response: { status: 200, body: { detailed: true } }
}
```

### Pattern Matching with Regex

For flexible pattern matching, use regex instead of exact values. This is useful for marketing campaigns, user agents, referer patterns, or any dynamic string matching.

#### String Matching Strategies

Scenarist supports five matching strategies:

```typescript
{
  method: 'GET',
  url: '/api/products',
  match: {
    headers: {
      // Exact match (default)
      'x-api-version': 'v2',

      // Contains substring
      'user-agent': { contains: 'Mobile' },

      // Starts with prefix
      'referer': { startsWith: 'https://example.com' },

      // Ends with suffix
      'accept': { endsWith: 'json' },

      // Regex pattern matching
      'x-campaign': {
        regex: { source: 'premium|vip', flags: 'i' }  // Case-insensitive
      }
    }
  },
  response: { status: 200, body: { /* ... */ } }
}
```

#### Regex Examples

**Marketing Campaigns:**

```typescript
{
  method: 'GET',
  url: '/api/products',
  match: {
    headers: {
      'x-campaign': {
        regex: { source: 'premium|vip|exclusive', flags: 'i' }
      }
    }
  },
  response: {
    status: 200,
    body: { pricing: 'premium', discount: 25 }
  }
}

// Matches:
// x-campaign: 'summer-premium-sale' ✓
// x-campaign: 'early-VIP-access' ✓ (case-insensitive)
// x-campaign: 'exclusive-members-2024' ✓
// x-campaign: 'standard-sale' ✗ (falls back to default)
```

**Referer Patterns:**

```typescript
{
  method: 'POST',
  url: '/api/checkout',
  match: {
    headers: {
      'referer': {
        regex: { source: '/checkout/(confirm|review)', flags: '' }
      }
    }
  },
  response: { status: 200, body: { allowCheckout: true } }
}

// Matches:
// referer: 'https://example.com/checkout/confirm' ✓
// referer: 'https://example.com/checkout/review' ✓
// referer: 'https://example.com/checkout/cart' ✗
```

**User Agent Detection:**

```typescript
{
  method: 'GET',
  url: '/api/config',
  match: {
    headers: {
      'user-agent': {
        regex: { source: '(iPhone|iPad|Android)', flags: 'i' }
      }
    }
  },
  response: {
    status: 200,
    body: { layout: 'mobile', features: ['touch', 'swipe'] }
  }
}
```

#### Security: ReDoS Protection

Scenarist validates all regex patterns for **ReDoS (Regular Expression Denial of Service)** vulnerabilities:

```typescript
// ✅ SAFE - Simple alternation
{ regex: { source: 'premium|vip', flags: 'i' } }

// ✅ SAFE - Character classes
{ regex: { source: '[A-Z]{3}-\\d{4}', flags: '' } }

// ❌ REJECTED - Catastrophic backtracking risk
{ regex: { source: '(a+)+b', flags: '' } }
// Error: Regex pattern may cause ReDoS attack
```

Additionally, regex matching has a **100ms timeout** to prevent slow patterns from blocking tests.

#### When to Use Regex

**Use regex when:**
- Matching campaign codes with variable formats
- Detecting mobile vs desktop user agents
- Validating referer patterns (checkout flows, auth redirects)
- Matching version patterns (`v1.2.3`, `2024-01-15`)

**Use exact/contains when:**
- Simple substring matching is sufficient
- Performance is critical (regex is slower)
- Pattern is known exactly

[Learn more about scenario format →](/introduction/scenario-format)

## Response Sequences

Simulate multi-step processes like polling, where each request advances through a sequence of responses.

### Basic Sequence

```typescript
{
  method: 'GET',
  url: '/api/job/status',
  sequence: {
    responses: [
      { status: 200, body: { status: 'pending' } },
      { status: 200, body: { status: 'processing' } },
      { status: 200, body: { status: 'complete' } }
    ],
    repeat: 'last'  // Options: 'last' | 'cycle' | 'none'
  }
}
```

**Behavior:**
1. First request → returns 'pending'
2. Second request → returns 'processing'
3. Third request → returns 'complete'
4. Fourth+ requests → returns 'complete' (repeats last)

### Repeat Modes

**`repeat: 'last'`** - Repeat the last response indefinitely (most common)

```typescript
sequence: {
  responses: [
    { status: 200, body: { status: 'pending' } },
    { status: 200, body: { status: 'complete' } }
  ],
  repeat: 'last'
}
// Request 1: pending
// Request 2: complete
// Request 3+: complete (keeps repeating)
```

**`repeat: 'cycle'`** - Loop back to the beginning

```typescript
sequence: {
  responses: [
    { status: 200, body: { weather: 'sunny' } },
    { status: 200, body: { weather: 'cloudy' } },
    { status: 200, body: { weather: 'rainy' } }
  ],
  repeat: 'cycle'
}
// Request 1: sunny
// Request 2: cloudy
// Request 3: rainy
// Request 4: sunny (cycles back)
// Request 5: cloudy
```

**`repeat: 'none'`** - After sequence exhausts, fall through to next mock

```typescript
{
  mocks: [
    {
      method: 'POST',
      url: '/api/payment',
      sequence: {
        responses: [
          { status: 200, body: { id: 'ch_1', status: 'pending' } },
          { status: 200, body: { id: 'ch_2', status: 'pending' } },
          { status: 200, body: { id: 'ch_3', status: 'succeeded' } }
        ],
        repeat: 'none'  // After 3rd request, sequence exhausted
      }
    },
    {
      method: 'POST',
      url: '/api/payment',
      response: { status: 429, body: { error: 'Rate limit exceeded' } }
    }
  ]
}
// Request 1-3: Sequence responses
// Request 4+: Rate limit error (sequence exhausted, falls through to next mock)
```

### Combining Sequences with Matching

Sequences can be combined with match criteria:

```typescript
{
  method: 'GET',
  url: '/api/onboarding/step',
  match: {
    headers: { 'x-tier': 'premium' }
  },
  sequence: {
    responses: [
      { status: 200, body: { step: 1, message: 'Welcome!' } },
      { status: 200, body: { step: 2, message: 'Configure...' } },
      { status: 200, body: { step: 3, message: 'Complete!' } }
    ],
    repeat: 'last'
  }
}
```

**Important:** Only matching requests advance the sequence. Non-matching requests don't affect sequence position.

## Stateful Mocks

Capture data from requests and inject it into subsequent responses, enabling stateful scenarios like shopping carts.

### Basic State Capture and Injection

```typescript
{
  mocks: [
    // Capture state from POST request
    {
      method: 'POST',
      url: '/api/cart/add',
      captureState: {
        cartItems: { from: 'body', path: 'productId' }
      },
      response: { status: 201 }
    },
    // Inject state into GET response
    {
      method: 'GET',
      url: '/api/cart',
      response: {
        status: 200,
        body: {
          items: '{{state.cartItems}}'
        }
      }
    }
  ]
}
```

**How it works:**

1. POST to `/api/cart/add` with body `{ productId: 'prod-1' }`
2. Scenarist captures `productId` value and stores as `cartItems`
3. GET to `/api/cart` returns `{ items: 'prod-1' }`

### Array Append Syntax

Use `stateKey[]` to append values to an array:

```typescript
{
  method: 'POST',
  url: '/api/cart/add',
  captureState: {
    'cartItems[]': { from: 'body', path: 'productId' }  // Note the [] suffix
  },
  response: { status: 201 }
}
```

**Behavior:**

```typescript
// Request 1: { productId: 'prod-1' }
// State: { cartItems: ['prod-1'] }

// Request 2: { productId: 'prod-2' }
// State: { cartItems: ['prod-1', 'prod-2'] }

// Request 3: { productId: 'prod-3' }
// State: { cartItems: ['prod-1', 'prod-2', 'prod-3'] }
```

### Nested Path Support

Capture deeply nested values using dot notation:

```typescript
{
  method: 'POST',
  url: '/api/profile/update',
  captureState: {
    userName: { from: 'body', path: 'user.profile.name' }
  },
  response: { status: 200 }
}

// Request body:
// {
//   user: {
//     profile: {
//       name: 'John Doe',
//       email: 'john@example.com'
//     }
//   }
// }

// Captured: userName = 'John Doe'
```

### Template Replacement

Use `{{state.key}}` syntax to inject captured state into responses:

```typescript
{
  method: 'GET',
  url: '/api/profile',
  response: {
    status: 200,
    body: {
      username: '{{state.userName}}',
      items: '{{state.cartItems}}',
      itemCount: '{{state.cartItems.length}}'  // Can access array length
    }
  }
}
```

### State Isolation Per Test ID

State is isolated per test ID, ensuring parallel tests don't interfere:

```typescript
// Test 1 (test-id: abc-123)
POST /api/cart/add { productId: 'prod-1' }
GET /api/cart  // Returns { items: ['prod-1'] }

// Test 2 (test-id: xyz-789) - runs simultaneously
POST /api/cart/add { productId: 'prod-999' }
GET /api/cart  // Returns { items: ['prod-999'] }

// No interference - each test has isolated state
```

### State Reset on Scenario Switch

When a test switches scenarios, all state for that test ID is cleared:

```typescript
test('cart workflow', async ({ page, switchScenario }) => {
  await switchScenario(page, 'cart-scenario');

  // Add items...
  await fetch('/api/cart/add', { body: { productId: 'prod-1' } });

  // Switch to different scenario
  await switchScenario(page, 'different-scenario');

  // State is cleared when switching - cart is now empty
});
```

## Combining All Three Capabilities

The power comes from combining request matching, sequences, and state together:

```typescript
{
  mocks: [
    // Match premium users, advance through onboarding sequence, capture profile
    {
      method: 'POST',
      url: '/api/onboarding',
      match: {
        headers: { 'x-tier': 'premium' }
      },
      sequence: {
        responses: [
          { status: 200, body: { step: 1, message: 'Welcome premium user!' } },
          { status: 200, body: { step: 2, message: 'Set up your profile' } },
          { status: 200, body: { step: 3, message: 'You are all set!' } }
        ],
        repeat: 'last'
      },
      captureState: {
        'completedSteps[]': { from: 'body', path: 'stepNumber' }
      }
    },
    // Use captured state in dashboard
    {
      method: 'GET',
      url: '/api/dashboard',
      response: {
        status: 200,
        body: {
          completedSteps: '{{state.completedSteps}}',
          onboardingComplete: '{{state.completedSteps.length >= 3}}'
        }
      }
    }
  ]
}
```

**This enables:**
- Request with premium header triggers premium onboarding sequence
- Each step is captured in state
- Dashboard shows progress based on captured steps
- All isolated per test ID for parallel execution

## Application Headers vs Infrastructure Headers

Understanding the separation between **application data** and **infrastructure headers** is crucial for effective testing with Scenarist.

### The Architecture

Scenarist handles **infrastructure concerns** automatically:
- Test ID propagation (`x-test-id` header)
- Scenario isolation per test
- State management per test ID

**Your application** handles **business logic**:
- User authentication (tier, role, permissions)
- Marketing campaigns
- Feature flags
- Custom routing parameters

### Why This Separation Matters

**Scenarist's Job:**
```typescript
// Infrastructure - Scenarist manages this automatically
const headers = {
  ...scenarist.getHeaders(request),  // x-test-id header
};
```

**Your Job:**
```typescript
// Application logic - Extract YOUR business data
const campaign = request.query.campaign;
const userTier = request.session.tier || 'standard';

// Combine infrastructure + application
const headers = {
  ...scenarist.getHeaders(request),  // Infrastructure
  'x-campaign': campaign,            // Your business logic
  'x-user-tier': userTier,           // Your business logic
};
```

**Why not auto-forward everything?**
1. **Data Source Unknown:** Campaign might come from query params, cookies, JWT, database, session...
2. **Transformation Needed:** `campaign` (query param) → `x-campaign` (header name)
3. **Framework Differences:** Each framework accesses data differently
4. **Business Logic:** Only YOU know which data matters for YOUR scenarios
5. **Serialization:** Cannot serialize extraction functions (breaks scenario portability)

### Express Example

In Express, application data extraction is explicit and framework-appropriate:

```typescript
// routes/products.ts
app.get('/api/products', async (req, res) => {
  // Extract application data from Express request
  const campaign = req.query.campaign as string | undefined;
  const userTier = req.session?.tier || 'standard';

  // Combine with Scenarist infrastructure
  const headers: Record<string, string> = {
    // No need for getHeaders() - AsyncLocalStorage handles test ID automatically
  };

  // Add application headers conditionally
  if (campaign) {
    headers['x-campaign'] = campaign;
  }
  if (userTier) {
    headers['x-user-tier'] = userTier;
  }

  // Fetch from external API
  const response = await fetch('https://api.example.com/products', { headers });
  const data = await response.json();

  res.json(data);
});
```

**Key Points:**
- ✅ Express uses AsyncLocalStorage for test ID (automatic propagation)
- ✅ Application data (`campaign`, `tier`) extracted from Express-specific APIs
- ✅ Conditional logic (only add if present)
- ✅ Clear separation: infrastructure vs application

### Next.js Pages Router Example

In Next.js Pages Router, extraction happens in `getServerSideProps`:

```typescript
// pages/products.tsx
export const getServerSideProps: GetServerSideProps = async (context) => {
  // Extract application data from Next.js context
  const campaignParam = context.query.campaign;
  const campaign = Array.isArray(campaignParam) ? campaignParam[0] : campaignParam;

  const tierParam = context.query.tier;
  const tier = Array.isArray(tierParam) ? tierParam[0] : tierParam || 'standard';

  // Combine Scenarist infrastructure + application headers
  const headers: Record<string, string> = {
    ...scenarist.getHeaders(context.req),  // Infrastructure: x-test-id
    'x-user-tier': tier,                   // Application: user tier
  };

  // Add campaign header if present
  if (campaign) {
    headers['x-campaign'] = campaign;
  }

  // Fetch from external API
  const response = await fetch('http://localhost:3001/products', { headers });
  const data = await response.json();

  return {
    props: { products: data.products }
  };
};
```

**Key Points:**
- ✅ Next.js requires explicit `getHeaders()` (different execution model than Express)
- ✅ Query params might be arrays - need normalization
- ✅ Application logic decides header names and transformations
- ✅ Conditional extraction (campaign optional)

### Next.js App Router Example

In Next.js App Router, extraction happens in route handlers or server components:

```typescript
// app/api/products/route.ts
export async function GET(request: NextRequest) {
  // Extract application data from Next.js request
  const campaign = request.nextUrl.searchParams.get('campaign');
  const userTier = request.headers.get('x-user-tier') || 'standard';

  // Combine Scenarist infrastructure + application headers
  const headers: Record<string, string> = {
    ...scenarist.getHeaders(request),  // Infrastructure: x-test-id
    'x-user-tier': userTier,           // Application: user tier
  };

  // Add campaign header if present
  if (campaign) {
    headers['x-campaign'] = campaign;
  }

  // Fetch from external API
  const response = await fetch('http://localhost:3001/products', { headers });
  const data = await response.json();

  return NextResponse.json(data);
}
```

**Key Points:**
- ✅ App Router uses Web Request API (`searchParams.get()`)
- ✅ Explicit `getHeaders()` required (like Pages Router)
- ✅ Application determines which data to extract and how to transform it
- ✅ Framework-appropriate APIs used

### Optional: Reusable Extraction Helpers

If you have **many routes** with identical extraction logic, create your own helpers:

```typescript
// utils/scenarist-helpers.ts (your code, not Scenarist's)
import type { NextRequest } from 'next/server';
import { scenarist } from '@/lib/scenarist';

export const extractProductHeaders = (request: NextRequest) => {
  const campaign = request.nextUrl.searchParams.get('campaign');
  const tier = request.nextUrl.searchParams.get('tier') || 'standard';

  return {
    ...scenarist.getHeaders(request),  // Infrastructure
    ...(campaign && { 'x-campaign': campaign }),
    'x-user-tier': tier,
  };
};

// Then in routes:
export async function GET(request: NextRequest) {
  const headers = extractProductHeaders(request);  // Reusable helper

  const response = await fetch('http://localhost:3001/products', { headers });
  return NextResponse.json(await response.json());
}
```

**Benefits:**
- ✅ DRY (Don't Repeat Yourself) if you truly have duplication
- ✅ Logic stays in YOUR codebase (not Scenarist's)
- ✅ Framework-specific (Next.js helper for Next.js apps)
- ✅ Type-safe and testable
- ✅ Encapsulates YOUR business logic

### Key Takeaways

**Scenarist's Responsibility:**
- ✅ Manage test IDs
- ✅ Track active scenarios
- ✅ Isolate parallel tests
- ✅ Match requests to mocks

**Your Responsibility:**
- ✅ Extract application data (query params, cookies, headers, session, DB)
- ✅ Transform values (query param → header name)
- ✅ Apply business logic (user tier, campaigns, feature flags)
- ✅ Framework-appropriate extraction (Express vs Next.js APIs)

**This separation:**
- ✅ Keeps Scenarist focused and framework-agnostic
- ✅ Gives you full control over YOUR data
- ✅ Makes scenarios serializable (no extraction functions)
- ✅ Documents your business logic explicitly in code
- ✅ Remains flexible for your specific needs

The 3-5 lines of extraction code per route are **valuable application code**, not boilerplate to eliminate. They document what data matters for your scenarios and where it comes from.

## Next Steps

- [Scenario Format Reference →](/introduction/scenario-format) - Complete schema and syntax
- [Declarative Design Philosophy →](/introduction/declarative-design) - Why scenarios are pure data
- [Example Apps →](/frameworks/express/example-app) - See capabilities in action
- [Framework Guides →](/frameworks/nextjs-app-router/getting-started) - Start building tests
