---
title: Scenario Format
description: Complete structure and all features of Scenarist scenarios
---

Scenarist scenarios are **serializable JSON objects** that define how your application behaves during testing. Unlike traditional mocking where you write functions and closures, scenarios are pure data that can be:

- Version controlled (TypeScript scenario definitions in git)
- Shared across test files
- Sent over HTTP
- Generated programmatically

The serializable design enables future features like remote storage (Redis, PostgreSQL) without breaking changes.

:::tip[Why Serializable?]
Scenarist scenarios are pure data (no functions) to enforce **declarative design patterns**. This constraint leads to clearer, more maintainable tests.

[Learn about the declarative philosophy →](/introduction/declarative-design)
:::

## Basic Scenario Structure

Every scenario follows this structure:

```typescript
import type { ScenaristScenario } from '@scenarist/core';

const myScenario: ScenaristScenario = {
  id: 'my-scenario',                    // Unique identifier (required)
  name: 'My Scenario',                  // Human-readable name (required)
  description: 'What this scenario represents',  // Documentation (required)
  mocks: [                              // Array of mock definitions (required)
    // Mock definitions go here
  ],
};
```

### Required Fields

- **`id`**: Unique string identifier used when switching scenarios in tests
- **`name`**: Human-readable name displayed in documentation and tooling
- **`description`**: Explains when and why to use this scenario
- **`mocks`**: Array of mock definitions (at least one required)

## Mock Definition Structure

Mocks define how to intercept HTTP requests and what responses to return:

```typescript
{
  method: 'GET',                        // HTTP method (required)
  url: 'https://api.example.com/user',  // URL pattern (required)

  // EITHER response OR sequence (at least one required)
  response: {                           // Single static response
    status: 200,
    body: { id: 1, name: 'Test User' },
    headers: { 'x-custom': 'value' },
    delay: 1000,                        // Optional delay in ms
  },

  // OR
  sequence: {                           // Response sequence (polling, multi-step)
    responses: [                        // Array of responses
      { status: 200, body: { status: 'pending' } },
      { status: 200, body: { status: 'complete' } },
    ],
    repeat: 'last',                     // 'last' | 'cycle' | 'none'
  },

  // Optional: Request matching criteria
  match: {
    body: { itemType: 'premium' },      // Partial body match
    headers: { 'x-tier': 'premium' },   // Exact header match
    query: { detailed: 'true' },        // Exact query param match
  },

  // Optional: State capture for stateful mocks
  captureState: {
    'userId': 'body.id',                // Capture from request
    'cartItems[]': 'body.item',         // Append to array
  },
}
```

### HTTP Methods

Supported methods:
- `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `OPTIONS`, `HEAD`

### URL Patterns

URLs can be:
- **Exact match**: `https://api.example.com/user`
- **Path parameters**: `https://api.example.com/users/:id`
- **Glob patterns**: `https://api.example.com/users/*`

### Response Structure

Every response (single or in sequence) contains:

```typescript
{
  status: 200,          // HTTP status code (100-599, required)
  body: { },            // Response body (any JSON-serializable value, optional)
  headers: { },         // Response headers (string key-value pairs, optional)
  delay: 1000,          // Delay in milliseconds (optional)
}
```

## Feature 1: Request Matching

Match mocks based on request content to return different responses for the same URL:

```typescript
const scenario: ScenaristScenario = {
  id: 'tiered-pricing',
  name: 'Tiered Pricing',
  description: 'Different pricing based on user tier',
  mocks: [
    // Premium users get discounted pricing
    {
      method: 'POST',
      url: 'https://api.stripe.com/v1/charges',
      match: { body: { itemType: 'premium' } },      // Match on body content
      response: {
        status: 200,
        body: { amount: 8000, discount: 'premium_discount' },
      },
    },
    // Standard users get regular pricing
    {
      method: 'POST',
      url: 'https://api.stripe.com/v1/charges',
      match: { body: { itemType: 'standard' } },
      response: {
        status: 200,
        body: { amount: 10000 },
      },
    },
    // Fallback for other item types (no match criteria = fallback)
    {
      method: 'POST',
      url: 'https://api.stripe.com/v1/charges',
      response: {
        status: 200,
        body: { amount: 5000 },
      },
    },
  ],
};
```

### Match Criteria

**Body Matching** (partial match - request can have additional fields):
```typescript
match: {
  body: {
    itemType: 'premium',
    quantity: 5,
  }
}
// Matches if request body contains these fields with exact values
```

**Header Matching** (exact match on specified headers):
```typescript
match: {
  headers: {
    'x-user-tier': 'premium',
    'x-region': 'eu',
  }
}
// Matches if request has these headers with exact values
```

**Query Parameter Matching** (exact match on specified params):
```typescript
match: {
  query: {
    detailed: 'true',
    units: 'metric',
  }
}
// Matches if request query has these params with exact values
```

**Combined Matching** (all criteria must match):
```typescript
match: {
  body: { itemType: 'premium' },
  headers: { 'x-user-tier': 'gold' },
  query: { region: 'us' },
}
// All three must match for this mock to be selected
```

### Specificity-Based Selection

When multiple mocks match the same URL, Scenarist uses **specificity scoring** to choose the best match:

- Each body field = +1 point
- Each header = +1 point
- Each query param = +1 point
- No match criteria = 0 points (fallback)

**Most specific mock wins**, regardless of order.

Example:
```typescript
// Specificity: 2 (body: itemType, quantity)
match: { body: { itemType: 'premium', quantity: 5 } }

// Specificity: 1 (body: itemType)
match: { body: { itemType: 'premium' } }

// Specificity: 0 (fallback)
// No match criteria
```

Request with `{ itemType: 'premium', quantity: 5 }` → First mock wins (specificity 2)

## Feature 2: Response Sequences

Test polling, multi-step workflows, and async operations with declarative sequences:

```typescript
const scenario: ScenaristScenario = {
  id: 'github-polling',
  name: 'GitHub Job Polling',
  description: 'Simulates async job progression',
  mocks: [
    {
      method: 'GET',
      url: 'https://api.github.com/repos/:owner/:repo/actions/runs/:id',
      sequence: {
        responses: [
          { status: 200, body: { status: 'queued', progress: 0 } },
          { status: 200, body: { status: 'in_progress', progress: 50 } },
          { status: 200, body: { status: 'completed', progress: 100 } },
        ],
        repeat: 'last',  // After sequence exhausts, repeat last response
      },
    },
  ],
};
```

### Repeat Modes

**`repeat: 'last'`** - Repeat final response after sequence exhausts (default):
```
Call 1 → Response 1 (queued)
Call 2 → Response 2 (in_progress)
Call 3 → Response 3 (completed)
Call 4 → Response 3 (completed)  ← Repeats last
Call 5 → Response 3 (completed)  ← Repeats last
```

**`repeat: 'cycle'`** - Cycle back to first response after sequence exhausts:
```
Call 1 → Response 1 (sunny)
Call 2 → Response 2 (cloudy)
Call 3 → Response 3 (rainy)
Call 4 → Response 1 (sunny)  ← Cycles back
Call 5 → Response 2 (cloudy) ← Cycles back
```

**`repeat: 'none'`** - After sequence exhausts, mock becomes inactive (allows fallback):
```
Call 1 → Response 1 (attempt 1)
Call 2 → Response 2 (attempt 2)
Call 3 → Response 3 (succeeded)
Call 4 → [Exhausted - falls through to next mock or error]
```

### Sequence with Fallback

Combine `repeat: 'none'` with a fallback mock for rate limiting:

```typescript
mocks: [
  {
    method: 'POST',
    url: 'https://api.example.com/payment',
    sequence: {
      responses: [
        { status: 200, body: { status: 'pending' } },
        { status: 200, body: { status: 'pending' } },
        { status: 200, body: { status: 'succeeded' } },
      ],
      repeat: 'none',  // Exhausts after 3 calls
    },
  },
  {
    method: 'POST',
    url: 'https://api.example.com/payment',
    response: {
      status: 429,
      body: { error: 'Rate limit exceeded' },
    },
  },
],
```

After 3 calls, sequence exhausts and fallback mock returns 429 error.

## Feature 3: Stateful Mocks

Capture state from requests and inject it into responses for dynamic behavior:

```typescript
const scenario: ScenaristScenario = {
  id: 'shopping-cart',
  name: 'Shopping Cart',
  description: 'Cart with state persistence',
  mocks: [
    // Add item - captures product ID
    {
      method: 'POST',
      url: 'https://api.store.com/cart/add',
      captureState: {
        'cartItems[]': 'body.productId',  // Append to array
      },
      response: {
        status: 200,
        body: { success: true },
      },
    },
    // Get cart - injects captured items
    {
      method: 'GET',
      url: 'https://api.store.com/cart',
      response: {
        status: 200,
        body: {
          items: '{{state.cartItems}}',  // Inject array
          count: '{{state.cartItems.length}}',  // Inject array length
        },
      },
    },
  ],
};
```

### State Capture Syntax

**Path expressions** extract values from requests:

```typescript
captureState: {
  'userId': 'body.user.id',        // Extract from nested body field
  'email': 'headers.x-user-email', // Extract from header
  'region': 'query.region',        // Extract from query param
}
```

**Array append syntax** builds arrays over multiple requests:

```typescript
captureState: {
  'cartItems[]': 'body.item',  // Appends to array (creates if doesn't exist)
  'tags[]': 'body.tag',        // Another array
}
```

### State Injection Syntax

**Template syntax** injects captured state into responses:

```typescript
response: {
  status: 200,
  body: {
    user: '{{state.userId}}',            // Inject scalar value
    items: '{{state.cartItems}}',        // Inject array
    count: '{{state.cartItems.length}}', // Inject array property
    profile: {
      name: '{{state.userName}}',        // Inject nested value
      email: '{{state.email}}',
    },
  },
}
```

### State Lifecycle

1. **Capture**: Extract values from request when mock is matched
2. **Store**: Save values keyed by test ID (isolated per test)
3. **Inject**: Replace templates in responses with stored values
4. **Reset**: Clear state when scenario switches (clean slate)

## Feature 4: Composition

All features compose together for powerful scenarios:

```typescript
const scenario: ScenaristScenario = {
  id: 'premium-onboarding',
  name: 'Premium User Onboarding',
  description: 'Multi-step onboarding with state and sequences',
  mocks: [
    // Only premium users get onboarding sequence
    {
      method: 'GET',
      url: 'https://api.example.com/onboarding/step',
      match: { headers: { 'x-tier': 'premium' } },  // Request matching
      sequence: {                                    // Response sequences
        responses: [
          { status: 200, body: { step: 1, message: 'Welcome!' } },
          { status: 200, body: { step: 2, message: 'Configure...' } },
          { status: 200, body: { step: 3, message: 'Complete!' } },
        ],
        repeat: 'last',
      },
      captureState: {                                // State capture
        'onboardingProgress[]': 'query.step',
      },
    },
    // Standard users see upgrade message
    {
      method: 'GET',
      url: 'https://api.example.com/onboarding/step',
      response: {
        status: 200,
        body: { message: 'Upgrade to premium for onboarding' },
      },
    },
  ],
};
```

**Key insight:** Non-matching requests (standard users) don't advance the sequence. Each feature works independently while maintaining its guarantees.

## Scenarios Object Pattern

Organize scenarios in a typed object for type-safe access:

```typescript
import type { ScenaristScenarios } from '@scenarist/core';

export const scenarios = {
  default: defaultScenario,        // Required: 'default' key
  success: successScenario,
  error: errorScenario,
  premiumUser: premiumUserScenario,
} as const satisfies ScenaristScenarios;

// TypeScript extracts scenario IDs for autocomplete
type ScenarioId = keyof typeof scenarios;
// 'default' | 'success' | 'error' | 'premiumUser'
```

### The 'default' Scenario Requirement

Every scenarios object **must** have a 'default' key (enforced by schema validation):

```typescript
// ✅ CORRECT
export const scenarios = {
  default: defaultScenario,  // Required key
  other: otherScenario,
} as const satisfies ScenaristScenarios;

// ❌ WRONG - Missing 'default' key
export const scenarios = {
  success: successScenario,
  error: errorScenario,
} as const satisfies ScenaristScenarios;
// Error: Scenarios object must have a 'default' key
```

The 'default' scenario serves as the baseline when:
- No scenario is explicitly set for a test
- A test ID header is missing
- Scenario switching fails

## Real-World Example

Complete scenario from production code:

```typescript
export const contentMatchingScenario: ScenaristScenario = {
  id: 'content-matching',
  name: 'Content Matching',
  description: 'Different responses based on request content',
  mocks: [
    // Premium items get discounted pricing
    {
      method: 'POST',
      url: 'https://api.stripe.com/v1/charges',
      match: { body: { itemType: 'premium' } },
      response: {
        status: 200,
        body: {
          id: 'ch_premium123',
          status: 'succeeded',
          amount: 8000,
          discount: 'premium_item_discount',
        },
      },
    },
    // Standard items get regular pricing
    {
      method: 'POST',
      url: 'https://api.stripe.com/v1/charges',
      match: { body: { itemType: 'standard' } },
      response: {
        status: 200,
        body: {
          id: 'ch_standard123',
          status: 'succeeded',
          amount: 5000,
        },
      },
    },
    // Fallback for other payment types
    {
      method: 'POST',
      url: 'https://api.stripe.com/v1/charges',
      response: {
        status: 200,
        body: {
          id: 'ch_fallback123',
          status: 'succeeded',
          amount: 1000,
        },
      },
    },
  ],
};
```

## Why Serializable?

Scenarios are pure JSON data (no functions, closures, regex, or classes) to enable future flexibility:

1. **Version Control**: Store scenarios as TypeScript definitions in git
2. **Future Remote Storage**: Architecture supports Redis, PostgreSQL, or remote APIs (not yet implemented)
3. **File System**: Read/write scenarios from configuration files
4. **Distribution**: Send scenarios over HTTP between services
5. **Testing**: Easy to generate test scenarios programmatically

**This is fundamental:** If scenarios contained functions, you could only ever have in-memory implementations. The serializable rule is in place now to give flexibility for future distributed testing features without breaking changes.

## Next Steps

- [Default Mocks →](/introduction/default-mocks) - Learn how default scenarios and override behavior work
- [Ephemeral Endpoints →](/introduction/ephemeral-endpoints) - Understand test-only activation
- [Endpoint APIs →](/introduction/endpoint-apis) - Reference for GET/POST /__scenario__
