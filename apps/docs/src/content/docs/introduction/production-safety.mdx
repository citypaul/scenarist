---
title: Production Safety
description: How Scenarist ensures zero test code in production bundles
---

import { Aside } from '@astrojs/starlight/components';

Scenarist is **safe to use in production** - your test mocking code will never reach production users.

## How It Works

When you deploy to production with `NODE_ENV=production`, Scenarist automatically returns `undefined` without loading any test code. Your bundler (Webpack, Vite, esbuild, etc.) then performs **tree-shaking** to eliminate all Scenarist code from your production bundle.

```typescript
import { createScenarist } from '@scenarist/express-adapter';
import { scenarios } from './scenarios';

// In production: returns undefined
// In development/test: returns working Scenarist instance
export const scenarist = createScenarist({
  enabled: true,
  scenarios,
});
```

### The Production Wrapper Pattern

All Scenarist adapters use a **production wrapper** that checks `NODE_ENV` before loading any test code:

```typescript
// Simplified view of what happens inside createScenarist()
export const createScenarist = (options) => {
  if (process.env.NODE_ENV === 'production') {
    return undefined;  // ← Returns immediately, no test code loaded
  }

  // Development/test: load implementation
  return createScenaristImpl(options);
};
```

This pattern ensures:
- ✅ **Zero runtime impact** - Production code paths never execute test logic
- ✅ **Automatic tree-shaking** - Bundlers eliminate dead code
- ✅ **No configuration needed** - Works automatically based on NODE_ENV
- ✅ **Type-safe** - TypeScript enforces null checks via `| undefined` return type

## Bundle Size Impact

**Before tree-shaking:** Adding Scenarist to your codebase increases bundle size by ~300KB

**After tree-shaking:** Production bundles contain **zero Scenarist code** (~0KB impact)

### Verification

**Critical:** Always verify tree-shaking is working in your production builds. This section provides multiple methods to confirm Scenarist code is eliminated.

#### Quick Verification (30 seconds)

The fastest way to verify tree-shaking:

```bash
# Build for production
NODE_ENV=production npm run build

# Search production bundle for Scenarist code
grep -r "scenarist\|msw" dist/ .next/ build/
```

**Expected result:** No matches (exit code 1). If you find matches, tree-shaking failed.

#### Visual Bundle Analysis

Visual analysis tools provide the most comprehensive verification. Choose the tool matching your bundler:

**Next.js (Webpack):**

```bash
# Install analyzer
npm install --save-dev @next/bundle-analyzer

# Add to next.config.js
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
});

module.exports = withBundleAnalyzer({
  // ... your config
});

# Build and analyze
ANALYZE=true NODE_ENV=production npm run build
```

Opens interactive visualization in browser. Search for "scenarist" or "msw" - should find nothing.

**Vite:**

```bash
# Install visualizer
npm install --save-dev rollup-plugin-visualizer

# Add to vite.config.ts
import { visualizer } from 'rollup-plugin-visualizer';

export default defineConfig({
  plugins: [
    visualizer({
      open: true,
      gzipSize: true,
      brotliSize: true,
    }),
  ],
});

# Build and analyze
NODE_ENV=production npm run build
```

Opens `stats.html` showing bundle composition. Scenarist/MSW should be absent.

**Webpack (standalone):**

```bash
# Install analyzer
npm install --save-dev webpack-bundle-analyzer

# Generate stats during build
webpack --mode production --profile --json > stats.json

# Analyze
npx webpack-bundle-analyzer stats.json
```

**Rollup:**

```bash
# Install visualizer
npm install --save-dev rollup-plugin-visualizer

# Add to rollup.config.js
import { visualizer } from 'rollup-plugin-visualizer';

export default {
  plugins: [
    visualizer({
      filename: 'bundle-stats.html',
      open: true,
    }),
  ],
};

# Build
NODE_ENV=production npm run build
```

#### Source Map Analysis (Framework-Agnostic)

Works with any bundler:

```bash
# Install source-map-explorer
npm install --save-dev source-map-explorer

# Build with source maps
NODE_ENV=production npm run build

# Analyze (adjust paths to your build output)
npx source-map-explorer 'dist/**/*.js' 'dist/**/*.js.map'
```

Generates treemap showing code origins. Scenarist/MSW should not appear.

#### Size Comparison (Before/After)

Measure actual bundle size impact:

```bash
# Baseline: Build without Scenarist
# (Comment out scenarist imports temporarily)
NODE_ENV=production npm run build
du -sh dist/ .next/static/ build/
# Note the size

# With Scenarist: Build normally
# (Uncomment scenarist imports)
NODE_ENV=production npm run build
du -sh dist/ .next/static/ build/
# Compare sizes - should be identical or negligible difference
```

**Expected:** ≤ 1KB difference (rounding/metadata only)

#### Framework-Specific Verification

**Express (Bundled Deployments):**

If you bundle Express apps for deployment (e.g., with esbuild):

```bash
# Build production bundle
NODE_ENV=production npm run build

# Check bundle size
ls -lh dist/server.js

# Search bundle
grep -o "scenarist\|msw" dist/server.js
# Should output nothing
```

**Next.js (Detailed):**

Next.js has separate client and server bundles. Verify both:

```bash
# Build
NODE_ENV=production npm run build

# Check client bundles
find .next/static -name "*.js" -exec grep -l "scenarist\|msw" {} \;
# Should output nothing

# Check server bundles
find .next/server -name "*.js" -exec grep -l "scenarist\|msw" {} \;
# Should output nothing
```

**Vercel Deployment:**

If deployed to Vercel, check production bundle size in deployment logs:

```
Build Output:
├ ƒ /                    1.2 kB        123 B
├ ○ /404                 2.1 kB        456 B
└ ƒ /api/products       450 B          78 B
```

Compare with pre-Scenarist deployment - sizes should be nearly identical.

#### Automated CI/CD Verification

Prevent tree-shaking regressions by adding checks to CI:

**GitHub Actions Example:**

```yaml
name: Verify Production Safety

on:
  pull_request:
    paths:
      - 'package.json'
      - 'src/**'

jobs:
  verify-bundle:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3

      - name: Install dependencies
        run: npm ci

      - name: Build production bundle
        run: NODE_ENV=production npm run build
        env:
          NODE_ENV: production

      - name: Verify no Scenarist code in bundle
        run: |
          if grep -r "scenarist\|msw" dist/ .next/ build/ 2>/dev/null; then
            echo "❌ ERROR: Scenarist code found in production bundle!"
            echo "Tree-shaking failed. Check NODE_ENV and bundler config."
            exit 1
          fi
          echo "✅ Verified: No Scenarist code in production bundle"

      - name: Compare bundle sizes
        run: |
          # Store baseline size (first run) or compare
          BUNDLE_SIZE=$(du -sb dist/ .next/ build/ 2>/dev/null | awk '{sum+=$1} END {print sum}')
          echo "Bundle size: $BUNDLE_SIZE bytes"
          # Add budget check if needed
```

**npm script:**

Add to `package.json` for manual verification:

```json
{
  "scripts": {
    "verify:production": "NODE_ENV=production npm run build && ! grep -r 'scenarist\\|msw' dist/ .next/ build/"
  }
}
```

Run: `npm run verify:production`

#### What Success Looks Like

**✅ Passing verification:**
- Bundle analyzer shows NO `scenarist` or `msw` packages
- `grep` search returns no matches (exit code 1)
- Bundle size same as before adding Scenarist (±1KB)
- Source maps show NO Scenarist source files
- Production deployment works normally

**❌ Failed verification (tree-shaking didn't work):**
- Bundle contains `scenarist` or `msw` strings
- Bundle size increased by ~300KB
- `createScenarist` function visible in bundle
- MSW handlers appear in production code

#### Troubleshooting Failed Verification

If verification fails, check these common issues:

**1. NODE_ENV not set to 'production':**

```bash
# ❌ Wrong - tree-shaking won't work
npm run build

# ✅ Correct - enables tree-shaking
NODE_ENV=production npm run build
```

**2. Bundler not configured for tree-shaking:**

Most bundlers enable tree-shaking by default in production mode. Verify config:

**Webpack:**
```js
// webpack.config.js
module.exports = {
  mode: 'production',  // ← Required
  optimization: {
    usedExports: true,  // ← Should be true (default in production)
    sideEffects: true,  // ← Should be true (default)
  },
};
```

**Vite:**
```js
// vite.config.js - tree-shaking automatic in production
export default defineConfig({
  build: {
    minify: 'terser',  // Or 'esbuild' - both tree-shake
  },
});
```

**3. Dynamic imports preventing tree-shaking:**

```js
// ❌ Wrong - prevents tree-shaking
const scenarist = require('@scenarist/express-adapter');

// ✅ Correct - enables tree-shaking
import { createScenarist } from '@scenarist/express-adapter';
```

**4. package.json sideEffects field:**

Check if your bundler respects `sideEffects: false` in Scenarist's package.json:

```bash
cat node_modules/@scenarist/*/package.json | grep sideEffects
# Should show: "sideEffects": false
```

If this is missing, [file an issue](https://github.com/citypaul/scenarist/issues) - this is a bug.

**5. TypeScript compilation settings:**

Ensure TypeScript preserves ES modules:

```json
// tsconfig.json
{
  "compilerOptions": {
    "module": "ES2020",     // ← Or "ESNext", not "CommonJS"
    "moduleResolution": "bundler",  // ← Or "node16"
  }
}
```

CommonJS modules prevent tree-shaking in most bundlers.

#### Still Having Issues?

If tree-shaking still fails after checking the above:

1. **Check your bundler version** - Update to latest version
2. **Review bundler logs** - Look for warnings about side effects
3. **Minimal reproduction** - Test in fresh project to isolate issue
4. **Open an issue** - [Report it](https://github.com/citypaul/scenarist/issues) with:
   - Bundler name and version
   - Framework name and version
   - Bundler config
   - Output of `npm ls @scenarist/*`

For additional help, see the [Verification Guide](/reference/verification) for general Scenarist testing verification.

## Type Safety

The return type `ExpressScenarist<T> | undefined` (or equivalent for your adapter) forces you to handle the production case:

```typescript
// TypeScript enforces null checks
if (!scenarist) {
  // Production mode - scenarist is undefined
  return;
}

// Development/test mode - scenarist is defined
scenarist.start();
```

This prevents accidentally calling test methods in production code.

## Framework-Specific Notes

### Express

```typescript
import { createScenarist } from '@scenarist/express-adapter';

export const scenarist = await createScenarist({
  enabled: true,
  scenarios,
});

// Type-safe null check required
if (scenarist) {
  scenarist.start();  // Only runs in development/test
}
```

### Next.js (App Router)

```typescript
import { createScenarist } from '@scenarist/nextjs-adapter/app';

export const scenarist = createScenarist({
  enabled: true,
  scenarios,
});

// Singleton pattern handles production automatically
// Returns same undefined instance on every call in production
```

### Next.js (Pages Router)

```typescript
import { createScenarist } from '@scenarist/nextjs-adapter/pages';

export const scenarist = createScenarist({
  enabled: true,
  scenarios,
});

// Same production wrapper pattern
```

## Common Questions

### Does Scenarist run in production if I forget NODE_ENV?

**No.** Even without `NODE_ENV=production`, Scenarist only activates when explicitly started. The `scenarist?.start()` call is typically in development server setup, not production runtime.

However, **you should always set NODE_ENV=production** for:
- Optimal performance
- Correct framework behavior
- Automatic tree-shaking

### What about CI/CD environments?

CI/CD environments should use:
- `NODE_ENV=test` for running tests
- `NODE_ENV=production` for building production bundles

Scenarist works in both modes:
- **Test mode:** Full functionality for E2E tests
- **Production mode:** Returns undefined, enabling tree-shaking

### Can I verify tree-shaking before deploying?

Yes! See the [Verification Guide](/reference/verification) for:
- Bundle analysis tools
- Size comparison techniques
- Automated verification scripts

### What if tree-shaking fails?

If your bundler doesn't tree-shake Scenarist:

1. **Check NODE_ENV:** Ensure `NODE_ENV=production` during build
2. **Check bundler config:** Verify tree-shaking is enabled (it usually is by default)
3. **Check sideEffects:** Scenarist marks itself as side-effect-free in package.json
4. **File an issue:** If tree-shaking still fails, [open an issue](https://github.com/citypaul/scenarist/issues) with your bundler details

## Best Practices

1. **Always use `NODE_ENV=production` for production builds**
   ```bash
   NODE_ENV=production npm run build
   ```

2. **Add null checks where you use Scenarist**
   ```typescript
   if (scenarist) {
     scenarist.start();
   }
   ```

3. **Verify bundle size in CI/CD**
   ```yaml
   - name: Check bundle size
     run: npm run build && npm run analyze
   ```

4. **Monitor production bundles**
   - Set up bundle size budgets
   - Alert on unexpected size increases
   - Review bundle composition regularly

## Summary

Scenarist is designed for production safety:

| Aspect | Guarantee |
|--------|-----------|
| Production runtime | Zero test code execution |
| Bundle size | Zero Scenarist code after tree-shaking |
| Configuration | No environment-specific config needed |
| Type safety | TypeScript enforces null checks |
| Performance | No runtime overhead in production |

**The bottom line:** Scenarist's production wrapper + tree-shaking = zero production impact.
